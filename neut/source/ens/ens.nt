import {
  core.bool {all},
  this.app.app {app},
  this.app.run {raise-error, text-join},
  this.ens.ens-type {ET-Bool, ET-Dictionary, ET-Float, ET-Int, ET-List, ET-String, ens-type, show-ens-type},
  this.logger.hint {hint, internal-hint},
  this.syntax-tree.block {block},
  this.syntax-tree.comment {comment, comment-item},
  this.syntax-tree.series {Series, series},
}

data ens-f(a: type) {
| E-Int(a, int)
| E-Float(a, float)
| E-Bool(a, bool)
| E-String(a, text)
| E-List(a, series(ens-f(a)))
| E-Dictionary(a, series(pair(text, ens-f(a))))
}

inline ens: type {
  ens-f(hint)
}

data top-ens {
| Top-Ens(ens, comment)
}

inline full-ens {
  block(ens)
}

define _eq-bool(b1: bool, b2: bool): bool {
  match b1, b2 {
  | True, True =>
    True
  | False, False =>
    True
  | _, _ =>
    False
  }
}

nominal {
  eq-ens(e1: &ens, e2: &ens): bool,
}

define _eq-ens-list(
  xs1: &list(pair(list(comment-item), ens)),
  xs2: &list(pair(list(comment-item), ens)),
): bool {
  case xs1, xs2 {
  | Nil, Nil =>
    True
  | Cons(Pair(c1, x1), rest1), Cons(Pair(c2, x2), rest2) =>
    let b1 = eq-data(c1, c2);
    let b2 = eq-ens(x1, x2);
    if and(b1, b2) {
      _eq-ens-list(rest1, rest2)
    } else {
      False
    }
  | _, _ =>
    False
  }
}

define _eq-ens-kvs(
  xs1: &list(pair(list(comment-item), pair(text, ens))),
  xs2: &list(pair(list(comment-item), pair(text, ens))),
): bool {
  case xs1, xs2 {
  | Nil, Nil =>
    True
  | Cons(Pair(c1, Pair(k1, x1)), rest1), Cons(Pair(c2, Pair(k2, x2)), rest2) =>
    let b1 = eq-data(c1, c2);
    let b2 = eq-text(k1, k2);
    let b3 = eq-ens(x1, x2);
    if all[b1, b2, b3] {
      _eq-ens-kvs(rest1, rest2)
    } else {
      False
    }
  | _, _ =>
    False
  }
}

define eq-ens(e1: &ens, e2: &ens): bool {
  case e1, e2 {
  | E-Int(_, x1), E-Int(_, x2) =>
    eq-int(*x1, *x2)
  | E-Float(_, x1), E-Float(_, x2) =>
    eq-float(*x1, *x2)
  | E-Bool(_, x1), E-Bool(_, x2) =>
    _eq-bool(*x1, *x2)
  | E-String(_, x1), E-String(_, x2) =>
    eq-text(x1, x2)
  | E-List(_, xs1), E-List(_, xs2) =>
    tie Series of {elems := elems1, trailing-comment := tc1, prefix := p1} = xs1;
    tie Series of {elems := elems2, trailing-comment := tc2, prefix := p2} = xs2;
    all[
      _eq-ens-list(elems1, elems2),
      eq-data(tc1, tc2),
      eq-data(p1, p2),
    ]
  | E-Dictionary(_, kvs1), E-Dictionary(_, kvs2) =>
    tie Series of {elems := elems1, trailing-comment := tc1, prefix := p1} = kvs1;
    tie Series of {elems := elems2, trailing-comment := tc2, prefix := p2} = kvs2;
    all[
      _eq-ens-kvs(elems1, elems2),
      eq-data(tc1, tc2),
      eq-data(p1, p2),
    ]
  | _, _ =>
    False
  }
}

define _lookup<a>(k: &text, kvs: &list(pair(a, pair(text, ens)))): ?&ens {
  case kvs {
  | Nil =>
    none
  | Cons(Pair(_, Pair(k', v)), rest) =>
    if eq-text(k, k') {
      Right(v)
    } else {
      _lookup(k, rest)
    }
  }
}

define has-key(k: &text, e: &ens): bool {
  case e {
  | E-Dictionary(_, kvs) =>
    tie Series of {elems} = kvs;
    match _lookup(k, elems) {
    | Left(_) =>
      False
    | Right(_) =>
      True
    }
  | _ =>
    False
  }
}

define raise-key-not-found-error<a>(m: hint, k: &text): app(a) {
  raise-error(m, text-join["Could not find the required key `", k, "`."])
}

define raise-type-error<a>(m: hint, expected-type: ens-type, actual-type: ens-type): app(a) {
  raise-error(m, text-join[
    "The value here is expected to be of type `",
    show-ens-type(expected-type),
    "`, but is: `",
    show-ens-type(actual-type),
    "`",
  ])
}

define type-of(e: &ens): ens-type {
  case e {
  | E-Int of {} =>
    ET-Int
  | E-Float of {} =>
    ET-Float
  | E-Bool of {} =>
    ET-Bool
  | E-String of {} =>
    ET-String
  | E-List of {} =>
    ET-List
  | E-Dictionary of {} =>
    ET-Dictionary
  }
}

define _hint-of(e: &ens): hint {
  case e {
  | E-Int(m, _) =>
    *m
  | E-Float(m, _) =>
    *m
  | E-Bool(m, _) =>
    *m
  | E-String(m, _) =>
    *m
  | E-List(m, _) =>
    *m
  | E-Dictionary(m, _) =>
    *m
  }
}

define to-string(e: &ens): app(pair(&hint, &text)) {
  case e {
  | E-String(m, x) =>
    Right(Pair(m, x))
  | _ =>
    raise-type-error(_hint-of(e), ET-String, type-of(e))
  }
}

define to-dictionary(e: &ens): app(pair(&hint, &series(pair(text, ens)))) {
  case e {
  | E-Dictionary(m, kvs) =>
    Right(Pair(m, kvs))
  | _ =>
    raise-type-error(_hint-of(e), ET-Dictionary, type-of(e))
  }
}

define to-list(e: &ens): app(pair(&hint, &series(ens))) {
  case e {
  | E-List(m, xs) =>
    Right(Pair(m, xs))
  | _ =>
    raise-type-error(_hint-of(e), ET-List, type-of(e))
  }
}

define zen(): unit {
  pin v: app(int) = raise-key-not-found-error(internal-hint, "test");
  vet(v);
  pin e = E-Int(internal-hint, 123);
  pin v = to-dictionary(e);
  vet(v);
}
