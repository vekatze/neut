import {
  core.dictionary {dictionary, to-list},
  core.list {for-each, is-empty},
  path.path {drop-last},
  this.ens.ens {E-List, E-String, dict-from-list-vertical, ens},
  this.kernel.common.clang-option {Clang-Option},
  this.kernel.common.module-URL {module-URL},
  this.kernel.common.target {Target-Summary, target-summary},
  this.kernel.common.zen-config {zen-config},
  this.language.common.base-name {base-name},
  this.language.common.module-alias {module-alias},
  this.language.common.module-digest {module-digest},
  this.language.common.module-id {module-id},
  this.language.common.source-locator {text-from-source-locator},
  this.logger.hint {hint, internal-hint},
  this.syntax-tree.series {Bracket, Comma, from-list, series},
}

inline locator-name: type {
  text
}

inline preset-map: type {
  dictionary(locator-name, list(base-name))
}

inline alias-preset-map: type {
  dictionary(text, preset-map)
}

data dependency {
| Dependency(
    mirror-list: list(module-URL),
    digest: module-digest,
    preset-enabled: bool,
  )
}

data foreign {
| Foreign(
    input: list(text),
    output: list(text),
    script: list(text),
  )
}

inline target-name: type {
  text
}

data module {
| Module(
    id: module-id,
    source-dir: text,
    target: dictionary(target-name, target-summary),
    zenconfig: zen-config,
    archive-dir: text,
    cache-dir: text,
    dependency: dictionary(module-alias, dependency),
    extra-contents: list(text),
    antecedents: list(module-digest),
    location: text,
    foreign: foreign,
    static-files: dictionary(text, text),
    inline-limit: ?int,
    preset-map: preset-map,
  )
}

data main-module {
| Main-Module(module)
}

define extract-module(m: main-module): module {
  let Main-Module(m) = m;
  m
}

inline key-archive: &text {
  "archive"
}

inline key-cache: &text {
  "cache"
}

inline key-source: &text {
  "source"
}

inline key-target: &text {
  "target"
}

inline key-zen: &text {
  "zen"
}

inline key-main: &text {
  "main"
}

inline key-build-option: &text {
  "build-option"
}

inline key-compile-option: &text {
  "compile-option"
}

inline key-link-option: &text {
  "link-option"
}

inline key-dependency: &text {
  "dependency"
}

inline key-digest: &text {
  "digest"
}

inline key-mirror: &text {
  "mirror"
}

inline key-enable-preset: &text {
  "enable-preset"
}

inline key-extra-content: &text {
  "extra-content"
}

inline key-antecedent: &text {
  "antecedent"
}

inline key-static: &text {
  "static"
}

inline key-foreign: &text {
  "foreign"
}

inline key-foreign-input: &text {
  "input"
}

inline key-foreign-output: &text {
  "output"
}

inline key-foreign-script: &text {
  "script"
}

inline key-prefix: &text {
  "prefix"
}

inline key-inline-limit: &text {
  "inline-limit"
}

inline key-preset: &text {
  "preset"
}

define get-module-root-dir(m: &module): text {
  tie Module of {location} = m;
  drop-last(location)
}

define get-source-dir(m: &module): text {
  tie Module of {source-dir} = m;
  pin tmp = get-module-root-dir(m);
  path.path.append(tmp, source-dir)
}

define get-archive-dir(m: &module): text {
  tie Module of {archive-dir} = m;
  pin tmp = get-module-root-dir(m);
  path.path.append(tmp, archive-dir)
}

define _values<k, v>(d: &dictionary(k, v)): list(&v) {
  case d {
  | core.dictionary.Tip =>
    Nil
  | core.dictionary.Bin(_, _, v, d1, d2) =>
    let xs = _values(d1);
    let ys = _values(d2);
    core.list.append(xs, Cons(v, ys))
  }
}

define get-target-path-list(m: &module): list(text) {
  tie Module of {source-dir, target} = m;
  for-each(_values(target), function (v) {
    tie Target-Summary of {entry-point} = v;
    let tmp = text-from-source-locator(entry-point);
    let result on tmp = path.path.append(source-dir, tmp);
    let _ = tmp;
    result
  })
}

define get-target-path(m: &module, target-key: &text): ?text {
  tie Module of {source-dir, target} = m;
  let lookup = core.dictionary.make-lookup(core.text.ord.as-ord);
  try v = lookup(target, target-key);
  tie Target-Summary of {entry-point} = v;
  pin tmp = text-from-source-locator(entry-point);
  Right(path.path.append(source-dir, tmp))
}

define get-extra-contents(m: &module): &list(text) {
  tie Module of {extra-contents} = m;
  extra-contents
}

inline _m: hint {
  internal-hint
}

define _series-from-list<a>(xs: list(a)): series(a) {
  from-list(Bracket, Comma, xs)
}
