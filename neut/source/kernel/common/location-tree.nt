import {
  core.bool {all},
  core.dictionary {dictionary, to-list},
  core.int.ord,
  core.list {filter-some, for-each},
  this.language.common.definite-description {definite-description, local-locator-from-dd},
  this.language.common.external-name {External-Name, external-name},
  this.language.common.is-const-like {is-const-like},
  this.language.raw-term.raw-term {Loc, loc},
  this.logger.hint {get-column, get-file-path, get-line, hint},
}

inline line: type {
  int
}

inline column: type {
  int
}

inline col-from: type {
  int
}

inline col-to: type {
  int
}

inline def-symbol-len: type {
  int
}

inline col-interval: type {
  pair(col-from, col-to)
}

data symbol-name {
| Local(int, def-symbol-len)
| Global(definite-description, is-const-like)
| Foreign(external-name)
}

data loc-type {
| File-Loc
| Symbol-Loc(symbol-name)
}

data loc-item {
| Loc-Item(int, col-interval, loc-type, hint)
}

inline location-tree: type {
  dictionary(loc, loc-item)
}

inline ord-loc: ord(loc) {
  let Ord of {compare := !cmp-int} = core.int.ord.as-ord;
  Ord of {
    compare := {
      function (l1, l2) {
        tie Loc(x1, y1) = l1;
        tie Loc(x2, y2) = l2;
        match !cmp-int(x1, x2) {
        | EQ =>
          !cmp-int(y1, y2)
        | c =>
          c
        }
      }
    },
  }
}

define insert(k: &ord(loc), lt: loc-type, p: pair(line, col-interval), m: hint, t: location-tree): location-tree {
  let Pair(l, Pair(from, to)) = p;
  core.dictionary.insert(k, t, Loc(l, from), Loc-Item(l, Pair(from, to), lt, m))
}

define _get-length(s: &symbol-name): def-symbol-len {
  case s {
  | Local(_, len) =>
    *len
  | Global(dd, _) =>
    pin tmp = local-locator-from-dd(dd);
    core.text.length(tmp)
  | Foreign(External-Name(t)) =>
    core.text.length(t)
  }
}

data found-loc {
| Found-Loc(loc-type, &hint, &col-interval, def-symbol-len)
}

define find(k: &ord(loc), loc: &loc, t: &location-tree): ?found-loc {
  try Pair(_, li) = core.dictionary.lookup-LE(k, t, loc);
  tie Loc-Item(line, col-interval, lt, m) = li;
  tie Loc(l, c) = loc;
  tie Pair(col-from, col-to) = col-interval;
  if or(lt-int(*col-to, *c), ne-int(*line, *l)) {
    none
  } else {
    case lt {
    | File-Loc =>
      Right(Found-Loc(File-Loc, m, col-interval, sub-int(*col-from, *col-to)))
    | Symbol-Loc(sym) =>
      Right(Found-Loc(File-Loc, m, col-interval, _get-length(sym)))
    }
  }
}

define _is-sym-loc(lt: &loc-type): bool {
  case lt {
  | File-Loc =>
    False
  | Symbol-Loc(_) =>
    True
  }
}

define find-ref(l: &loc, t: location-tree): list(pair(text, pair(line, col-interval))) {
  let kvs = to-list(t);
  filter-some(for-each(kvs, function (p) {
    let Pair(Loc(line, _), Loc-Item(_, col-interval, lt, m)) = p;
    pin lt = lt;
    tie Loc(l1, c1) = l;
    let l2 on m = get-line(m);
    let c2 on m = get-column(m);
    if all[_is-sym-loc(lt), eq-int(*l1, l2), eq-int(*c1, c2)] {
      pin m = m;
      let file-path = *get-file-path(m);
      Right(Pair(file-path, Pair(line, col-interval)))
    } else {
      none
    }
  }))
}
