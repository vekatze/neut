import {
  core.cell {make-cell},
  core.control {discard},
  core.dictionary {dictionary, empty},
  core.environment {get-env},
  core.system {get-error-message, system, system-error},
  path.io {create-directory, is-directory},
  path.path {drop-last, split-extension},
  this.app.app {app},
  this.app.run {app-from-system, raise-error, raise-error'},
  this.kernel.common.const {env-var-core-module-URL, source-file-extension},
  this.kernel.common.module {Module, extract-module, get-module-root-dir, main-module, module},
  this.kernel.common.module-URL {Module-URL, module-URL},
  this.language.common.module-digest {Module-Digest},
  this.language.common.module-id {Base, Library, Main, module-id},
  this.logger.hint {hint},
}

data module-kit {
| _Module-Kit(
    cache-map-cell: cell(dictionary(text, module)),
  )
}

define make-module-kit(): module-kit {
  let cache-map-cell = make-cell(box {empty});
  _Module-Kit of {cache-map-cell}
}

define _has-source-extension(path: &text): bool {
  let Pair(_, ext) = split-extension(path);
  pin ext = ext;
  eq-text(ext, source-file-extension)
}

define _ensure-directory(path: &text): system(unit) {
  if is-directory(path) {
    Right(Unit)
  } else {
    create-directory(path)
  }
}

define _return-directory(path: text): app(text) {
  let result: either(system-error, unit) on path = _ensure-directory(path);
  match result {
  | Left(e) =>
    raise-error'(get-error-message(e))
  | Right(_) =>
    Right(path)
  }
}

define _get-dependency-dir-path(m: &module): app(text) {
  tie Module of {id, cache-dir} = m;
  let module-root-dir = get-module-root-dir(m);
  case id {
  | Library(_) =>
    let lib-dir on module-root-dir = drop-last(module-root-dir);
    let _ = module-root-dir;
    _return-directory(lib-dir)
  | _ =>
    let tmp on module-root-dir = path.path.append(module-root-dir, cache-dir);
    let result on tmp = path.path.append(tmp, "dependency");
    let _ = module-root-dir;
    let _ = tmp;
    Right(result)
  }
}

define get-module-dir-by-id(m: &main-module, hint-or-none: ?&hint, mid: &module-id): app(text) {
  case mid {
  | Base =>
    let message = "The base module cannot be used here";
    match hint-or-none {
    | Left(_) =>
      raise-error'(*message)
    | Right(hint) =>
      raise-error(*hint, *message)
    }
  | Main =>
    Right(get-module-root-dir(extract-module(m)))
  | Library(Module-Digest(digest)) =>
    try dep-dir = _get-dependency-dir-path(extract-module(m));
    let result on dep-dir = path.path.append(dep-dir, digest);
    discard(dep-dir);
    Right(result)
  }
}

define get-core-module-URL(): app(module-URL) {
  match get-env(env-var-core-module-URL) {
  | Right(core-module-URL) =>
    Right(Module-URL(core-module-URL))
  | Left(_) =>
    let tmp = core.text.append("The URL of the core module is not specified; set it via ", env-var-core-module-URL);
    raise-error'(tmp)
  }
}

define zen(): unit {
  pin result = _has-source-extension("foo.nt");
  vet(result);
  pin result = _has-source-extension("foo.txt");
  vet(result);
  pin result = _has-source-extension("nt");
  vet(result);
  pin result = get-core-module-URL();
  vet(result)
}
