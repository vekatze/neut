import {
  core.dictionary {dictionary},
  core.text-builder {append-text, extract, make-text-builder, text-builder},
  core.text.eq {eq-prefix},
  this.kernel.common.const {hole-var-prefix},
  this.kernel.common.module {main-module},
  this.language.common.definite-description {definite-description},
  this.language.common.is-const-like {is-const-like},
  this.language.raw-term.key {key},
}

inline exp-key: type {
  key
}

inline imp-key: type {
  key
}

data _key-arg-value {
| _Key-Arg-Value(is-const-like, list(imp-key), list(exp-key))
}

data key-arg-kit {
| _Key-Arg-Kit(
    main-module: main-module,
    key-arg-map-cell: cell(dictionary(definite-description, _key-arg-value)),
  )
}

define _is-hole(k: &key): bool {
  eq-prefix(k, hole-var-prefix)
}

define _eq-keys(ks1: &list(key), ks2: &list(key)): bool {
  case ks1, ks2 {
  | Nil, Nil =>
    True
  | Cons(_, _), Nil =>
    False
  | Nil, Cons(_, _) =>
    False
  | Cons(k1, rest1), Cons(k2, rest2) =>
    match _is-hole(k1), _is-hole(k2) {
    | True, True =>
      _eq-keys(rest1, rest2)
    | True, False =>
      False
    | False, True =>
      False
    | False, False =>
      if eq-text(k1, k2) {
        _eq-keys(rest1, rest2)
      } else {
        False
      }
    }
  }
}

define _text-from-keys(ks: &list(key)): text {
  let buf = make-text-builder(64);
  let f =
    define loop(buf: text-builder, ks: &list(key)): text {
      case ks {
      | Nil =>
        extract(buf)
      | Cons(k, rest) =>
        let _ on buf = append-text(buf, k);
        loop(buf, rest)
      }
    };
  f(buf, ks)
}
