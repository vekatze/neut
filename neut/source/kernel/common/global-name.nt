import {
  this.language.common.arg-num {Arg-Num, arg-num},
  this.language.common.definite-description {definite-description},
  this.language.common.discriminant {discriminant},
  this.language.common.is-const-like {is-const-like},
  this.language.common.prim-op {prim-op},
  this.language.common.prim-type {prim-type},
  this.language.common.rule-kind {rule-kind},
  this.logger.hint {hint},
}

data global-name {
| Top-Level-Func(arg-num, is-const-like)
| Prim-Type(prim-type)
| Prim-Op(prim-op)
| Data(arg-num, list(pair(definite-description, pair(hint, global-name))), is-const-like)
| Data-Intro(arg-num, arg-num, discriminant, is-const-like)
| Rule(rule-kind)
}

define get-is-const-like(gn: &global-name): is-const-like {
  case gn {
  | Top-Level-Func(_, is-const-like) =>
    *is-const-like
  | Data(_, _, is-const-like) =>
    *is-const-like
  | Data-Intro(_, _, _, is-const-like) =>
    *is-const-like
  | _ =>
    False
  }
}

define has-no-args(gn: &global-name): bool {
  case gn {
  | Top-Level-Func(arg-num, _) =>
    tie Arg-Num(i) = arg-num;
    eq-int(*i, 0)
  | Data(arg-num, _, _) =>
    tie Arg-Num(i) = arg-num;
    eq-int(*i, 0)
  | Data-Intro(data-arg-num, cons-arg-num, _, _) =>
    tie Arg-Num(i) = data-arg-num;
    tie Arg-Num(j) = cons-arg-num;
    and(eq-int(*i, 0), eq-int(*j, 0))
  | Rule(_) =>
    False
  | Prim-Type(_) =>
    True
  | Prim-Op(_) =>
    False
  }
}

define disable-const-like-flag(gn: global-name): global-name {
  match gn {
  | Top-Level-Func(arg-num, _) =>
    Top-Level-Func(arg-num, False)
  | Data(arg-num, cons-info, _) =>
    Data(arg-num, cons-info, False)
  | Data-Intro(data-arg-num, cons-arg-num, discriminant, _) =>
    Data-Intro(data-arg-num, cons-arg-num, discriminant, False)
  | gn =>
    gn
  }
}
