import {
  this.language.raw-term.locator {text-from-locator},
  this.language.raw-term.name {Locator, Var, name},
  this.language.raw-term.raw-binder {raw-binder},
  this.language.raw-term.raw-ident {is-hole},
  this.language.raw-term.raw-term {Elem, Hole, Tau, elem, imp-params, raw-term},
  this.logger.hint {hint},
  this.pretty-printer.doc {Empty, Inline-Comment, Line, Text, _is-multi, doc, indent, is-multi, join, line, make-text, nest},
  this.pretty-printer.piece {arrange, inject, parameter},
  this.syntax-tree.comment {comment},
  this.syntax-tree.comment.to-doc {as-prefix, as-suffix},
  this.syntax-tree.series {series},
  this.syntax-tree.series.to-doc,
}

define doc-from-raw-term(e: &raw-term): doc {
  case e {
  | Tau(_) =>
    make-text(*"tau")
  | Hole(_, _) =>
    make-text(*"_")
  }
}

define attach-comment(c: comment, d: doc): doc {
  join[as-prefix(c), d]
}

define _decode-block(x: elem(doc)): doc {
  let Elem(c1, body, c2) = x;
  join[
    make-text(*"{"),
    nest(indent, join[line, attach-comment(c1, body), as-suffix(c2)]),
    make-text(*"}"),
  ]
}

define _doc-from-name(n: &name): doc {
  case n {
  | Var(var) =>
    if is-hole(var) {
      make-text(*"_")
    } else {
      make-text(*var)
    }
  | Locator(locator) =>
    make-text(text-from-locator(locator))
  }
}

define type-annot(t: doc): doc {
  let b on t = _is-multi(t);
  if b {
    join[make-text(*":"), line, t]
  } else {
    join[make-text(*": "), t]
  }
}
