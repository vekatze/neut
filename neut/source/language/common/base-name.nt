import {
  core.bool {all},
  core.int.show {show-int},
  core.list {for-each-E},
  core.text {is-empty, text-byte-length},
  sero.common.get {get-text},
  sero.common.put {put-int64, put-text},
  sero.sero {Sero, sero},
  this.app.error {error, new-error, new-error'},
  this.language.common.const {ns-sep},
  this.logger.hint {hint, internal-hint},
}

data base-name {
| _Base-Name(text)
| _Base-Name-N(&text)
}

define base-name-by-split(m: hint, name: &text): either(error, list(base-name)) {
  for-each-E(core.text.split(name, ns-sep), function (t) {
    let b on t = is-empty(t);
    if b {
      Left(new-error(m, core.text.append("No succeeding dots are allowed here: ", name)))
    } else {
      Right(_Base-Name(t))
    }
  })
}

define base-name-from-text(m: hint, name: &text): either(error, base-name) {
  let tmp = core.text.split(name, ns-sep);
  match tmp {
  | Cons(b, Nil) =>
    Right(_Base-Name(b))
  | _ =>
    Left(new-error(m, core.text.append("No dots are allowed here: ", name)))
  }
}

define base-name-from-text-unsafe(name: text): base-name {
  _Base-Name(name)
}

define base-name-from-text-without-hint(name: &text): either(error, base-name) {
  let tmp = core.text.split(name, ns-sep);
  match tmp {
  | Cons(b, Nil) =>
    Right(_Base-Name(b))
  | _ =>
    Left(new-error'(core.text.append("No dots are allowed here: ", name)))
  }
}

define _get-first-rune<r := rho>(t: &text): ?rune {
  try _ = r;
  if gt-int(text-byte-length(t), 0) {
    Right(core.text._get-rune(t, 0))
  } else {
    none
  }
}

define _get-text(bn: &base-name): &text {
  case bn {
  | _Base-Name(t) =>
    t
  | _Base-Name-N(t) =>
    *t
  }
}

define is-capitalized(bn: &base-name): bool {
  let t = _get-text(bn);
  if gt-int(text-byte-length(t), 0) {
    let r = core.text._get-rune(t, 0);
    all[le-rune(`A`, r), le-rune(r, `Z`)]
  } else {
    False
  }
}

define length(bn: &base-name): int {
  let t = _get-text(bn);
  core.text.length(t)
}

inline this: base-name {
  _Base-Name-N("this")
}

inline base: base-name {
  _Base-Name-N("base")
}

inline core: base-name {
  _Base-Name-N("core")
}

define main-name: base-name {
  _Base-Name-N("main")
}

define zen-name: base-name {
  _Base-Name-N("zen")
}

define imm-type: base-name {
  _Base-Name-N("imm-type")
}

define imm-noema: base-name {
  _Base-Name-N("imm-noema")
}

define imm-int1: base-name {
  _Base-Name-N("imm-int1")
}

define imm-int2: base-name {
  _Base-Name-N("imm-int2")
}

define imm-int4: base-name {
  _Base-Name-N("imm-int4")
}

define imm-int8: base-name {
  _Base-Name-N("imm-int8")
}

define imm-int16: base-name {
  _Base-Name-N("imm-int16")
}

define imm-int32: base-name {
  _Base-Name-N("imm-int32")
}

define imm-int64: base-name {
  _Base-Name-N("imm-int64")
}

define imm-float16: base-name {
  _Base-Name-N("imm-float16")
}

define imm-float32: base-name {
  _Base-Name-N("imm-float32")
}

define imm-float64: base-name {
  _Base-Name-N("imm-float64")
}

define imm-rune: base-name {
  _Base-Name-N("imm-rune")
}

define imm-pointer: base-name {
  _Base-Name-N("imm-pointer")
}

define imm-null: base-name {
  _Base-Name-N("imm-null")
}

define cls: base-name {
  _Base-Name-N("cls")
}

define sigma-name(i: int): base-name {
  let ti = show-int(i);
  let name on ti = core.text.append("sigma;", ti);
  let _ = ti;
  _Base-Name(name)
}

define lambda-name(name-or-none: ?text, i: int): base-name {
  let ti = show-int(i);
  match name-or-none {
  | Right(lam-name) =>
    let tmp on lam-name = core.text.append("lambda;", lam-name);
    let _ = lam-name;
    let name on tmp, ti = core.text.append(tmp, ti);
    let _ = tmp;
    let _ = ti;
    _Base-Name(name)
  | Left(_) =>
    let name on ti = core.text.append("lambda;anon;", ti);
    let _ = ti;
    _Base-Name(name)
  }
}

define mu-name(name: text, i: int): base-name {
  let ti = show-int(i);
  let tmp on name = core.text.append("mu;", name);
  let _ = name;
  let name on tmp, ti = core.text.append(tmp, ti);
  let _ = tmp;
  let _ = ti;
  _Base-Name(name)
}

define resource-name(i: int): base-name {
  let ti = show-int(i);
  let name on ti = core.text.append("resource;", ti);
  let _ = ti;
  _Base-Name(name)
}

define text-name(i: int): base-name {
  let ti = show-int(i);
  let name on ti = core.text.append("text;", ti);
  let _ = ti;
  _Base-Name(name)
}

define form: base-name {
  _Base-Name-N("form")
}

define node: base-name {
  _Base-Name-N("node")
}

define leaf: base-name {
  _Base-Name-N("leaf")
}

define root: base-name {
  _Base-Name-N("root")
}

define is-reserved-alias(k: &base-name): bool {
  let t = _get-text(k);
  pin this = this;
  pin base = base;
  if eq-text(t, _get-text(this)) {
    True
  } else-if eq-text(t, _get-text(base)) {
    True
  } else {
    False
  }
}

define extend(x: &base-name, y: &base-name): base-name {
  let t1 = _get-text(x);
  let t2 = _get-text(y);
  let tmp = core.text.append(t1, "#");
  let name on tmp = core.text.append(tmp, t2);
  let _ = tmp;
  _Base-Name(name)
}

define base-name-sero: sero(base-name) {
  Sero of {
    put := {
      function (k, v) {
        case v {
        | _Base-Name(t) =>
          put-text(k, t);
        | _Base-Name-N(t) =>
          put-text(k, *t);
        }
      }
    },
    get := {
      function (k) {
        try t = get-text(k);
        Right(box {
          letbox t = quote {t};
          _Base-Name(t)
        })
      }
    },
  }
}

define zen(): unit {
  pin v = base-name-from-text(internal-hint, "foo.bar");
  vet(v);
  pin v = base-name-by-split(internal-hint, "foo.bar");
  vet(v);
  pin bn = _Base-Name(*"Foo");
  pin v = is-capitalized(bn);
  vet(v);
  pin bn = _Base-Name(*"foo");
  pin v = is-capitalized(bn);
  vet(v);
  pin bn = _Base-Name(*"");
  pin v = is-capitalized(bn);
  vet(v);
}
