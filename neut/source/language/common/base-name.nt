import {
  core.bool {all},
  core.int.show {show-int},
  core.list {for-each-E},
  core.text {is-empty, text-byte-length},
  this.app.error {error, new-error, new-error'},
  this.language.common.const {ns-sep},
  this.language.common.ident {ident},
  this.logger.hint {hint, internal-hint},
}

data base-name {
| Base-Name(text)
| Base-Name-N(&text)
}

define base-name-by-split(m: hint, name: &text): either(error, list(base-name)) {
  for-each-E(core.text.split(name, ns-sep), function (t) {
    let b on t = is-empty(t);
    if b {
      Left(new-error(m, core.text.append("No succeeding dots are allowed here: ", name)))
    } else {
      Right(Base-Name(t))
    }
  })
}

define base-name-from-text(m: hint, name: &text): either(error, base-name) {
  let tmp = core.text.split(name, ns-sep);
  match tmp {
  | Cons(b, Nil) =>
    Right(Base-Name(b))
  | _ =>
    Left(new-error(m, core.text.append("No dots are allowed here: ", name)))
  }
}

define base-name-from-text-unsafe(name: text): base-name {
  Base-Name(name)
}

define base-name-from-text-without-hint(name: &text): either(error, base-name) {
  let tmp = core.text.split(name, ns-sep);
  match tmp {
  | Cons(b, Nil) =>
    Right(Base-Name(b))
  | _ =>
    Left(new-error'(core.text.append("No dots are allowed here: ", name)))
  }
}

define _get-first-rune<r := rho>(t: &text): ?rune {
  try _ = r;
  if gt-int(text-byte-length(t), 0) {
    Right(core.text._get-rune(t, 0))
  } else {
    none
  }
}

define _get-text(bn: &base-name): &text {
  case bn {
  | Base-Name(t) =>
    t
  | Base-Name-N(t) =>
    *t
  }
}

define is-capitalized(bn: &base-name): bool {
  let t = _get-text(bn);
  if gt-int(text-byte-length(t), 0) {
    let r = core.text._get-rune(t, 0);
    all[le-rune(`A`, r), le-rune(r, `Z`)]
  } else {
    False
  }
}

define length(bn: &base-name): int {
  let t = _get-text(bn);
  core.text.length(t)
}

define this: base-name {
  Base-Name-N("this")
}

define base: base-name {
  Base-Name-N("base")
}

define core: base-name {
  Base-Name-N("core")
}

define main-name: base-name {
  Base-Name-N("main")
}

define zen-name: base-name {
  Base-Name-N("zen")
}

define imm-type: base-name {
  Base-Name-N("imm-type")
}

define imm-noema: base-name {
  Base-Name-N("imm-noema")
}

define imm-int1: base-name {
  Base-Name-N("imm-int1")
}

define imm-int2: base-name {
  Base-Name-N("imm-int2")
}

define imm-int4: base-name {
  Base-Name-N("imm-int4")
}

define imm-int8: base-name {
  Base-Name-N("imm-int8")
}

define imm-int16: base-name {
  Base-Name-N("imm-int16")
}

define imm-int32: base-name {
  Base-Name-N("imm-int32")
}

define imm-int64: base-name {
  Base-Name-N("imm-int64")
}

define imm-float16: base-name {
  Base-Name-N("imm-float16")
}

define imm-float32: base-name {
  Base-Name-N("imm-float32")
}

define imm-float64: base-name {
  Base-Name-N("imm-float64")
}

define imm-rune: base-name {
  Base-Name-N("imm-rune")
}

define imm-pointer: base-name {
  Base-Name-N("imm-pointer")
}

define imm-null: base-name {
  Base-Name-N("imm-null")
}

define cls: base-name {
  Base-Name-N("cls")
}

define sigma-name(i: int): base-name {
  let ti = show-int(i);
  let name on ti = core.text.append("sigma;", ti);
  let _ = ti;
  Base-Name(name)
}

define lambda-name(name-or-none: ?text, i: int): base-name {
  let ti = show-int(i);
  match name-or-none {
  | Right(lam-name) =>
    let tmp on lam-name = core.text.append("lambda;", lam-name);
    let _ = lam-name;
    let name on tmp, ti = core.text.append(tmp, ti);
    let _ = tmp;
    let _ = ti;
    Base-Name(name)
  | Left(_) =>
    let name on ti = core.text.append("lambda;anon;", ti);
    let _ = ti;
    Base-Name(name)
  }
}

define mu-name(name: text, i: int): base-name {
  let ti = show-int(i);
  let tmp on name = core.text.append("mu;", name);
  let _ = name;
  let name on tmp, ti = core.text.append(tmp, ti);
  let _ = tmp;
  let _ = ti;
  Base-Name(name)
}

define resource-name(i: int): base-name {
  let ti = show-int(i);
  let name on ti = core.text.append("resource;", ti);
  let _ = ti;
  Base-Name(name)
}

define text-name(i: int): base-name {
  let ti = show-int(i);
  let name on ti = core.text.append("text;", ti);
  let _ = ti;
  Base-Name(name)
}

define form: base-name {
  Base-Name-N("form")
}

define node: base-name {
  Base-Name-N("node")
}

define leaf: base-name {
  Base-Name-N("leaf")
}

define root: base-name {
  Base-Name-N("root")
}

define zen(): unit {
  pin v = base-name-from-text(internal-hint, "foo.bar");
  vet(v);
  pin v = base-name-by-split(internal-hint, "foo.bar");
  vet(v);
  pin bn = Base-Name(*"Foo");
  pin v = is-capitalized(bn);
  vet(v);
  pin bn = Base-Name(*"foo");
  pin v = is-capitalized(bn);
  vet(v);
  pin bn = Base-Name(*"");
  pin v = is-capitalized(bn);
  vet(v);
}
