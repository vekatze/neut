import {
  core.bool {all},
  core.list {for-each-E},
  core.text {is-empty, text-byte-length},
  this.app.error {error, new-error, new-error'},
  this.language.common.const {ns-sep},
  this.logger.hint {hint, internal-hint},
}

data base-name {
| Base-Name(text)
| Base-Name-N(&text)
}

define base-name-by-split(m: hint, name: &text): either(error, list(base-name)) {
  for-each-E(core.text.split(name, ns-sep), function (t) {
    let b on t = is-empty(t);
    if b {
      Left(new-error(m, core.text.append("No succeeding dots are allowed here: ", name)))
    } else {
      Right(Base-Name(t))
    }
  })
}

define base-name-from-text(m: hint, name: &text): either(error, base-name) {
  let tmp = core.text.split(name, ns-sep);
  match tmp {
  | Cons(b, Nil) =>
    Right(Base-Name(b))
  | _ =>
    Left(new-error(m, core.text.append("No dots are allowed here: ", name)))
  }
}

define base-name-from-text-without-hint(name: &text): either(error, base-name) {
  let tmp = core.text.split(name, ns-sep);
  match tmp {
  | Cons(b, Nil) =>
    Right(Base-Name(b))
  | _ =>
    Left(new-error'(core.text.append("No dots are allowed here: ", name)))
  }
}

define _get-first-rune<r := rho>(t: &text): ?rune {
  try _ = r;
  if gt-int(text-byte-length(t), 0) {
    Right(core.text._get-rune(t, 0))
  } else {
    none
  }
}

define _get-text(bn: &base-name): &text {
  case bn {
  | Base-Name(t) =>
    t
  | Base-Name-N(t) =>
    *t
  }
}

define is-capitalized(bn: &base-name): bool {
  let t = _get-text(bn);
  if gt-int(text-byte-length(t), 0) {
    let r = core.text._get-rune(t, 0);
    all[le-rune(`A`, r), le-rune(r, `Z`)]
  } else {
    False
  }
}

define length(bn: &base-name): int {
  let t = _get-text(bn);
  core.text.length(t)
}

define this: base-name {
  Base-Name-N("this")
}

define base: base-name {
  Base-Name-N("base")
}

define core: base-name {
  Base-Name-N("core")
}

define main-name: base-name {
  Base-Name-N("main")
}

define zen(): unit {
  pin v = base-name-from-text(internal-hint, "foo.bar");
  vet(v);
  pin v = base-name-by-split(internal-hint, "foo.bar");
  vet(v);
  pin bn = Base-Name(*"Foo");
  pin v = is-capitalized(bn);
  vet(v);
  pin bn = Base-Name(*"foo");
  pin v = is-capitalized(bn);
  vet(v);
  pin bn = Base-Name(*"");
  pin v = is-capitalized(bn);
  vet(v);
}
