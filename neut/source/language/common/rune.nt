import {
  core.text.parse {Parse-Error, parse-text},
}

define rune-from-text(x: &text): either(text, rune) {
  match parse-text(x) {
  | Left(Parse-Error(reason)) =>
    pin reason = reason;
    pin tmp = core.text.append("Could not interpret the following as a rune: ", x);
    pin tmp2 = core.text.append(tmp, "\nReason: ");
    Left(core.text.append(tmp2, reason))
  | Right(x) =>
    match core.text.uncons(x) {
    | Left(_) =>
      Left(*"The content of a rune literal must be of length 1")
    | Right(Pair(r, rest)) =>
      pin rest = rest;
      if eq-int(core.text.length(rest), 0) {
        Right(r)
      } else {
        Left(*"The content of a rune literal must be of length 1")
      }
    }
  }
}

define zen(): unit {
  pin foo = rune-from-text("„ÅÇ");
  vet(foo);
}
