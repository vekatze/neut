import {
  core.list {filter-some, for-each-N},
  this.language.common.binder {binder-f},
  this.language.common.definite-description {definite-description},
  this.language.common.discriminant {discriminant},
  this.language.common.ident {ident},
  this.language.common.is-const-like {is-const-like},
  this.language.common.literal {literal},
  this.logger.hint {hint},
}

nominal {
  case-list(a: type): type,
}

data decision-tree(a) {
| Leaf(list(ident), list(pair(binder-f(a), a)), a)
| Unreachable
| Switch(pair(ident, a), case-list(a))
}

data tree-case(a) {
| Cons-Case(
    m-cons: hint,
    cons-dd: definite-description,
    is-const-like: is-const-like,
    disc: discriminant,
    data-args: list(pair(a, a)),
    cons-params: list(binder-f(a)),
    cont: decision-tree(a),
  )
| Literal-Case(hint, literal, decision-tree(a))
}

inline case-list(a: type): type {
  pair(decision-tree(a), list(tree-case(a)))
}

define get-constructors<a>(cs: &list(tree-case(a))): list(pair(&definite-description, &is-const-like)) {
  filter-some(for-each-N(cs, function (c) {
    case c {
    | Cons-Case of {cons-dd, is-const-like} =>
      Right(Pair(cons-dd, is-const-like))
    | Literal-Case of {} =>
      none
    }
  }))
}

define is-unreachable<a>(tree: &decision-tree(a)): bool {
  case tree {
  | Unreachable =>
    True
  | _ =>
    False
  }
}
