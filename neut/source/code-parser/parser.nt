import {
  this.syntax-tree.comment {Comment-item, Inline-Comment, Line-Comment, comment, comment-item, comment-type},
  zonk.parse {chunk, many, optional, parsed, zonk},
  zonk.zonk-kit {zonk-kit},
}

define is-non-symbol-char(r: rune): bool {
  match r {
  | `=` =>
    True
  | `(` =>
    True
  | `)` =>
    True
  | ` ` =>
    True
  | `\`` =>
    True
  | `"` =>
    True
  | `\n` =>
    True
  | `\t` =>
    True
  | `:` =>
    True
  | `;` =>
    True
  | `,` =>
    True
  | `<` =>
    True
  | `>` =>
    True
  | `[` =>
    True
  | `]` =>
    True
  | `{` =>
    True
  | `}` =>
    True
  | `/` =>
    True
  | `*` =>
    True
  | `|` =>
    True
  | `&` =>
    True
  | `?` =>
    True
  | _ =>
    False
  }
}

define skip-space<r := rho>(k: &zonk-kit): parsed(unit) {
  try _ = r;
  try _ =
    zonk.parse.take-while(function (r) {
      match r {
      | ` ` =>
        True
      | `\n` =>
        True
      | _ =>
        False
      }
    })(k);
  Right(Unit)
}

define skip-space-without-newline<r := rho>(k: &zonk-kit): parsed(unit) {
  try _ = r;
  try _ =
    zonk.parse.take-while(function (r) {
      eq-rune(r, ` `)
    })(k);
  Right(Unit)
}

define parse-comment-item<r := rho>(k: &zonk-kit, comment-type: comment-type): parsed(comment-item) {
  try _ = r;
  try _ = chunk("//")(k);
  try comment-text =
    zonk.parse.take-while(function (r) {
      ne-rune(r, `\n`)
    })(k);
  Right(Comment-item of {comment-text, comment-type})
}

define parse-line-comment<r := rho>(k: &zonk-kit): parsed(comment-item) {
  try _ = r;
  try _ = skip-space(k);
  parse-comment-item(k, Line-Comment)
}

define space-consumer<r := rho>(k: &zonk-kit): parsed(comment) {
  try _ = r;
  try _ = skip-space-without-newline(k);
  try maybe-inline-comment =
    optional(function (k) {
      parse-comment-item(k, Inline-Comment)
    })(k);
  try _ = skip-space(k);
  try line-comments =
    many(function (k) {
      try c = parse-line-comment(k);
      try _ = skip-space(k);
      Right(c)
    })(k);
  match maybe-inline-comment {
  | Left(_) =>
    Right(line-comments)
  | Right(ic) =>
    Right(Cons(ic, line-comments))
  }
}

inline lexeme<a, r := rho>(k: &zonk-kit, p: zonk(a)): parsed(pair(a, comment)) {
  try _ = r;
  try v = p(k);
  try c = space-consumer(k);
  Right(Pair(v, c))
}

define delimiter<r := rho>(k: &zonk-kit, expected: &text): parsed(comment) {
  try _ = r;
  try Pair(_, c) =
    lexeme(k, function (k) {
      try _ = chunk(expected)(k);
      Right(Unit)
    });
  Right(c)
}
