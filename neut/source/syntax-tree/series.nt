import {
  this.syntax-tree.comment {comment},
}

data separator {
| Comma
| Bar
}

data container {
| Paren
| Brace
| Bracket
| Angle
}

inline prefix: type {
  ?pair(text, comment)
}

data series(a) {
| Series(
    elems: list(pair(comment, a)),
    trailing-comment: comment,
    prefix: prefix,
    container: ?container,
    separator: separator,
    has-optional-separator: bool,
  )
}

inline for-each<a, b>(xs: series(a), f: (a) -> b): series(b) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = xs;
  let elems =
    core.list.for-each(elems, function (p) {
      let Pair(c, val) = p;
      let val = f(val);
      Pair(c, val)
    });
  Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator}
}

define empty-series<a>(container: ?container, separator: separator): series(a) {
  Series of {
    elems := Nil,
    trailing-comment := Nil,
    prefix := Left(Unit),
    container,
    separator,
    has-optional-separator := False,
  }
}

define singleton<a>(
  container: ?container,
  separator: separator,
  leading-comment: comment,
  value: a,
  trailing-comment: comment,
): series(a) {
  Series of {
    elems := List[Pair(leading-comment, value)],
    trailing-comment,
    prefix := Left(Unit),
    container,
    separator,
    has-optional-separator := False,
  }
}

inline replace<a, b>(xs: series(pair(a, b)), !new-value: b, predicate: (&a) -> bool): series(pair(a, b)) {
  for-each(xs, function (p) {
    let Pair(k, v) = p;
    let b on k = predicate(k);
    if b {
      Pair(k, !new-value)
    } else {
      Pair(k, v)
    }
  })
}

define uncons<a>(s: series(a)): ?pair(pair(comment, a), series(a)) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  match elems {
  | Nil =>
    none
  | Cons(first-elem, rest) =>
    let remaining-series =
      Series of {
        elems := rest,
        trailing-comment,
        prefix,
        container,
        separator,
        has-optional-separator,
      };
    Right(Pair(first-elem, remaining-series))
  }
}

define cons<a>(elem: pair(comment, a), xs: series(a)): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = xs;
  Series of {
    elems := Cons(elem, elems),
    trailing-comment,
    prefix,
    container,
    separator,
    has-optional-separator,
  }
}

define empty-series-paren-comma<a>(): series(a) {
  empty-series(Right(Paren), Comma)
}
