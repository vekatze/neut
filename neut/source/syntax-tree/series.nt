import {
  core.vector.ord,
  this.syntax-tree.comment {comment},
}

data separator {
| Comma
| Bar
}

data container {
| Paren
| Brace
| Bracket
| Angle
}

inline prefix: type {
  ?pair(text, comment)
}

data series(a) {
| Series(
    elems: list(pair(comment, a)),
    trailing-comment: comment,
    prefix: prefix,
    container: ?container,
    separator: separator,
    has-optional-separator: bool,
  )
}

inline for-each<a, b>(xs: series(a), f: (a) -> b): series(b) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = xs;
  let elems =
    core.list.for-each(elems, function (p) {
      let Pair(c, val) = p;
      let val = f(val);
      Pair(c, val)
    });
  Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator}
}

define empty-series<a>(container: ?container, separator: separator): series(a) {
  Series of {
    elems := Nil,
    trailing-comment := Nil,
    prefix := Left(Unit),
    container,
    separator,
    has-optional-separator := False,
  }
}

define singleton<a>(
  container: ?container,
  separator: separator,
  leading-comment: comment,
  value: a,
  trailing-comment: comment,
): series(a) {
  Series of {
    elems := List[Pair(leading-comment, value)],
    trailing-comment,
    prefix := Left(Unit),
    container,
    separator,
    has-optional-separator := False,
  }
}

inline replace<a, b>(xs: series(pair(a, b)), !new-value: b, predicate: (&a) -> bool): series(pair(a, b)) {
  for-each(xs, function (p) {
    let Pair(k, v) = p;
    let b on k = predicate(k);
    if b {
      Pair(k, !new-value)
    } else {
      Pair(k, v)
    }
  })
}

define uncons<a>(s: series(a)): ?pair(pair(comment, a), series(a)) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  match elems {
  | Nil =>
    none
  | Cons(first-elem, rest) =>
    let remaining-series =
      Series of {
        elems := rest,
        trailing-comment,
        prefix,
        container,
        separator,
        has-optional-separator,
      };
    Right(Pair(first-elem, remaining-series))
  }
}

define cons<a>(elem: pair(comment, a), xs: series(a)): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = xs;
  Series of {
    elems := Cons(elem, elems),
    trailing-comment,
    prefix,
    container,
    separator,
    has-optional-separator,
  }
}

define empty-series-paren-comma<a>(): series(a) {
  empty-series(Right(Paren), Comma)
}

define empty-series-angle-comma<a>(): series(a) {
  empty-series(Right(Angle), Comma)
}

define from-list<a>(container: container, separator: separator, values: list(a)): series(a) {
  let elems =
    core.list.for-each(values, function (v) {
      Pair(Nil, v)
    });
  Series of {
    elems,
    trailing-comment := Nil,
    prefix := none,
    container := Right(container),
    separator,
    has-optional-separator := False,
  }
}

define from-list-paren<a>(values: list(a)): series(a) {
  from-list(Paren, Comma, values)
}

define from-list-bare<a>(values: list(a)): series(a) {
  let elems =
    core.list.for-each(values, function (v) {
      Pair(Nil, v)
    });
  Series of {
    elems,
    trailing-comment := Nil,
    prefix := none,
    container := none,
    separator := Comma,
    has-optional-separator := False,
  }
}

define _assoc<a>(es: list(pair(comment, pair(a, comment))), c: comment): pair(list(pair(comment, a)), comment) {
  match es {
  | Nil =>
    Pair(Nil, c)
  | Cons(Pair(c1, Pair(e, c2)), Nil) =>
    Pair(List[Pair(c1, e)], core.list.append(c2, c))
  | Cons(Pair(c11, Pair(e1, c12)), Cons(Pair(c21, Pair(e2, c22)), rest)) =>
    let Pair(tmp, c') = _assoc(Cons(Pair(core.list.append(c12, c21), Pair(e2, c22)), rest), c);
    Pair(Cons(Pair(c11, e1), tmp), c')
  }
}

define from-list-with-comment<a>(
  container: container,
  separator: separator,
  values: list(pair(comment, pair(a, comment))),
): series(a) {
  let Pair(elems, trailing-comment) = _assoc(values, Nil);
  Series of {
    elems,
    trailing-comment,
    prefix := none,
    container := Right(container),
    separator,
    has-optional-separator := False,
  }
}

define push-comment<a>(comment: comment, s: series(a)): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  match elems {
  | Nil =>
    Series of {
      elems := Nil,
      trailing-comment := core.list.append(comment, trailing-comment),
      prefix,
      container,
      separator,
      has-optional-separator,
    }
  | Cons(first-pair, rest) =>
    let Pair(first-comment, first-value) = first-pair;
    let new-first = Pair(core.list.append(comment, first-comment), first-value);
    Series of {
      elems := Cons(new-first, rest),
      trailing-comment,
      prefix,
      container,
      separator,
      has-optional-separator,
    }
  }
}

define assoc<a>(s: series(pair(a, comment))): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  let Pair(elems, trailing-comment) = _assoc(elems, trailing-comment);
  Series of {
    elems,
    trailing-comment,
    prefix,
    container,
    separator,
    has-optional-separator,
  }
}

define join-c<a>(s: series(pair(comment, a))): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  let new-elems =
    core.list.for-each(elems, function (e) {
      let Pair(c1, Pair(c2, v)) = e;
      Pair(core.list.append(c1, c2), v)
    });
  Series of {
    elems := new-elems,
    trailing-comment,
    prefix,
    container,
    separator,
    has-optional-separator,
  }
}

define get-container-pair(cont: container): pair(&text, &text) {
  match cont {
  | Paren =>
    Pair("(", ")")
  | Brace =>
    Pair("{", "}")
  | Bracket =>
    Pair("[", "]")
  | Angle =>
    Pair("<", ">")
  }
}

define get-separator-text(sep: separator): &text {
  match sep {
  | Comma =>
    ","
  | Bar =>
    "|"
  }
}

define extract<a>(s: series(a)): list(a) {
  let Series of {elems} = s;
  core.list.for-each(elems, function (e) {
    let Pair(_, v) = e;
    v
  })
}

define is-empty<a>(s: &series(a)): bool {
  tie Series of {elems, trailing-comment} = s;
  let b1 = core.list.is-empty(elems);
  let b2 = core.list.is-empty(trailing-comment);
  and(b1, b2)
}

define sort-series-by<a>(
  o: &ord(pair(comment, a)),
  nes: &(pair(comment, a)) -> meta pair(comment, a),
  s: series(a),
): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  let elems-vec = core.vector.from-list(elems);
  let elems-vec = core.vector.ord.vector-quicksort(o, nes, elems-vec);
  let elems = core.vector.to-list(elems-vec);
  Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator}
}
