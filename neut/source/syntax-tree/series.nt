import {
  this.syntax-tree.comment {comment},
}

data separator {
| Comma
| Bar
}

data container {
| Paren
| Brace
| Bracket
| Angle
}

inline prefix: type {
  ?pair(text, comment)
}

data series(a) {
| Series(
    elems: list(pair(comment, a)),
    trailing-comment: comment,
    prefix: prefix,
    container: ?container,
    separator: separator,
    has-optional-separator: bool,
  )
}

inline for-each<a, b>(xs: series(a), f: (a) -> b): series(b) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = xs;
  let elems =
    core.list.for-each(elems, function (p) {
      let Pair(c, val) = p;
      let val = f(val);
      Pair(c, val)
    });
  Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator}
}

define empty-series<a>(container: ?container, separator: separator): series(a) {
  Series of {
    elems := Nil,
    trailing-comment := Nil,
    prefix := Left(Unit),
    container,
    separator,
    has-optional-separator := False,
  }
}

define singleton<a>(
  container: ?container,
  separator: separator,
  leading-comment: comment,
  value: a,
  trailing-comment: comment,
): series(a) {
  Series of {
    elems := List[Pair(leading-comment, value)],
    trailing-comment,
    prefix := Left(Unit),
    container,
    separator,
    has-optional-separator := False,
  }
}

inline replace<a, b>(xs: series(pair(a, b)), !new-value: b, predicate: (&a) -> bool): series(pair(a, b)) {
  for-each(xs, function (p) {
    let Pair(k, v) = p;
    let b on k = predicate(k);
    if b {
      Pair(k, !new-value)
    } else {
      Pair(k, v)
    }
  })
}

define uncons<a>(s: series(a)): ?pair(pair(comment, a), series(a)) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = s;
  match elems {
  | Nil =>
    none
  | Cons(first-elem, rest) =>
    let remaining-series =
      Series of {
        elems := rest,
        trailing-comment,
        prefix,
        container,
        separator,
        has-optional-separator,
      };
    Right(Pair(first-elem, remaining-series))
  }
}

define cons<a>(elem: pair(comment, a), xs: series(a)): series(a) {
  let Series of {elems, trailing-comment, prefix, container, separator, has-optional-separator} = xs;
  Series of {
    elems := Cons(elem, elems),
    trailing-comment,
    prefix,
    container,
    separator,
    has-optional-separator,
  }
}

define empty-series-paren-comma<a>(): series(a) {
  empty-series(Right(Paren), Comma)
}

define empty-series-angle-comma<a>(): series(a) {
  empty-series(Right(Angle), Comma)
}

define from-list<a>(container: container, separator: separator, values: list(a)): series(a) {
  let elems =
    core.list.for-each(values, function (v) {
      Pair(Nil, v)
    });
  Series of {
    elems,
    trailing-comment := Nil,
    prefix := none,
    container := Right(container),
    separator,
    has-optional-separator := False,
  }
}

define from-list-paren<a>(values: list(a)): series(a) {
  from-list(Paren, Comma, values)
}

define from-list-bare<a>(values: list(a)): series(a) {
  let elems =
    core.list.for-each(values, function (v) {
      Pair(Nil, v)
    });
  Series of {
    elems,
    trailing-comment := Nil,
    prefix := none,
    container := none,
    separator := Comma,
    has-optional-separator := False,
  }
}

define _assoc<a>(es: list(pair(comment, pair(a, comment))), c: comment): pair(list(pair(comment, a)), comment) {
  match es {
  | Nil =>
    Pair(Nil, c)
  | Cons(Pair(c1, Pair(e, c2)), Nil) =>
    Pair(List[Pair(c1, e)], core.list.append(c2, c))
  | Cons(Pair(c11, Pair(e1, c12)), Cons(Pair(c21, Pair(e2, c22)), rest)) =>
    let Pair(tmp, c') = _assoc(Cons(Pair(core.list.append(c12, c21), Pair(e2, c22)), rest), c);
    Pair(Cons(Pair(c11, e1), tmp), c')
  }
}
