import {
  core.list {is-empty},
  core.text {replicate},
  this.pretty-printer.doc {Empty, doc, indent, join, line, make-text, nest},
  this.pretty-printer.piece {delimiter-bar, inject, piece},
  this.syntax-tree.comment {comment},
  this.syntax-tree.comment.to-doc {as-clause-header, as-prefix-indented, as-suffix},
  this.syntax-tree.series {Bar, Series, get-separator-text, series},
}

inline _c-decode {
  this.syntax-tree.comment.to-doc.decode
}

define _decode-prefix<a>(s: &series(a)): doc {
  tie Series of {prefix} = s;
  case prefix {
  | Left(_) =>
    Empty
  | Right(Pair(p, c)) =>
    pin p = core.text.append(" ", p);
    let p = make-text(core.text.append(p, " "));
    if is-empty(c) {
      p
    } else {
      join[
        p,
        line,
        _c-decode(*c),
        line,
      ]
    }
  }
}

define _bar-seq-cont(
  elems: list(pair(comment, doc)),
  trailing-comment: comment,
): list(piece) {
  let sep = get-separator-text(Bar);
  match elems {
  | Nil =>
    List[inject(nest(indent, as-suffix(trailing-comment)))]
  | Cons(Pair(c, d), rest) =>
    core.list.append(
      List[
        inject(as-clause-header(c)),
        delimiter-bar(make-text(*sep)),
        inject(nest(indent, d)),
      ],
      _bar-seq-cont(rest, trailing-comment),
    )
  }
}
