<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Statements - Neut Programming Language</title>
    <meta name="description" content="A functional programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Statements - Neut Programming Language" />
    <meta property="og:description" content="A functional programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/statements.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules-and-sources.html"><strong aria-hidden="true">3.1.</strong> Modules and Sources</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html" class="active"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#import">import</a></li>
<li><a href="#define">define</a></li>
<li><a href="#inline">inline</a></li>
<li><a href="#data">data</a></li>
<li><a href="#resource">resource</a></li>
<li><a href="#rule-right">rule-right</a></li>
<li><a href="#rule-left">rule-left</a></li>
<li><a href="#nominal">nominal</a></li>
<li><a href="#foreign">foreign</a></li>
</ul>
<h2 id="import"><a class="header" href="#import"><code>import</code></a></h2>
<p><code>import</code> imports names from other files. It should look like the following:</p>
<pre><code class="language-neut">import {
  Qux,
  ZZ,
  sample.buz,
  this.foo,
  this.foo.bar {some-func, other-func},
}
</code></pre>
<p><code>import</code> can only be at the top of a file.</p>
<p>Every item in <code>import</code> is something like the following:</p>
<ul>
<li><code>this.foo</code></li>
<li><code>this.foo.bar {some-func, other-func}</code></li>
<li><code>sample.buz</code></li>
</ul>
<p>An import item starts from the alias of the module (<code>this</code>, <code>sample</code>). The alias of the module is specified in <code>dependency</code> in <code>module.ens</code>. If the file we want to import is inside the current module, we'll write <code>this</code>.</p>
<p>The remaining part of the item is the relative path from the source directory. For example, if we want to import <code>(source-dir)/foo/bar</code>, we'll have to write <code>foo.bar</code> after the alias of the module.</p>
<p>An import item can be constructed by concatenating the alias and the path with <code>.</code>. In the case of <code>this.foo.bar</code>, the alias part is <code>this</code>, and the path part is <code>foo.bar</code>.</p>
<p>You can specify names in <code>{}</code>. The names specified here can be used without qualifiers:</p>
<pre><code class="language-neut">import {
  this.foo.bar {some-func},
}

define yo(): unit {
  some-func(arg-1, arg-2)
}
</code></pre>
<p>Unlisted names must be qualified:</p>
<pre><code class="language-neut">import {
  this.foo.bar,
}

define yo(): unit {
  this.foo.bar.some-func(arg-1, arg-2)
}
</code></pre>
<p>You can also list static files in <code>import</code>:</p>
<pre><code class="language-neut">import {
  static {some-file, other-file}
}
</code></pre>
<p>For more on static files, please see <a href="modules.html#static">the section in Modules</a>.</p>
<h2 id="define"><a class="header" href="#define"><code>define</code></a></h2>
<p><code>define</code> defines a function. It should look like the following:</p>
<pre><code class="language-neut">define foo(x: int, y: int): int {
  add-int(x, y)
}

define identity-1(a: type, x: a): a {
  x
}

// a function with an implicit parameter
define identity-2&lt;a&gt;(x: a): a {
  x
}
</code></pre>
<p>Defined functions can then be used:</p>
<pre><code class="language-neut">define use-foo(): int {
  foo(1, 2)
}
</code></pre>
<p><code>define</code> can optionally have implicit parameters, as in <code>identity-2</code> in the above example. The compiler inserts these implicit parameters at compile time, so you don't have to write them explicitly:</p>
<pre><code class="language-neut">define use-func-with-implicit-arg(): int {
  let x = 10;
  let y = identity-1(int, x); // ← explicit version
  let z = identity-2(x);      // ← implicit version
  z
}
</code></pre>
<p>You can also use <code>define</code> without any explicit parameters:</p>
<pre><code class="language-neut">define foo: int {
  10
}

define empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo;
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">define foo(): int {
  10
}

define empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo();
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of a <code>define</code> into a value at compile time if the <code>define</code> doesn't have any explicit parameters. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">define bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<p>A function with the same name can't be defined in the same file.</p>
<p>All the tail-recursions in Neut are optimized into loops (thanks to geniuses in the LLVM team).</p>
<p>Note that statements are order-sensitive as in F#. Thus, the following code results in an error:</p>
<pre><code class="language-neut">define bar(): int {
  foo() // `foo` is undefined here
}

define foo(): int {
  10
}
</code></pre>
<p>You have to use the statement <code>nominal</code> explicitly for forward references.</p>
<h2 id="inline"><a class="header" href="#inline"><code>inline</code></a></h2>
<p><code>inline</code> defines an inline function. It should look like the following:</p>
<pre><code class="language-neut">inline foo(x: int, y: int): int {
  print(&quot;foo&quot;);
  add-int(x, y)
}
</code></pre>
<p><code>inline</code> is the same as <code>define</code> except that the definition is always expanded at compile-time. For example, if you write</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val = foo(10, 20);
  val
}
</code></pre>
<p>The compiler will translate the above code into the following:</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val = {
    let x = 10;
    let y = 20;
    print(&quot;foo&quot;);
    add-int(x, y)
  };
  val
}
</code></pre>
<p>You can also use <code>inline</code> without any explicit parameters:</p>
<pre><code class="language-neut">inline foo: int {
  10
}

inline empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo;
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">inline foo(): int {
  10
}

inline empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo();
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of an <code>inline</code> into a value at compile time if the <code>inline</code> doesn't have any explicit parameters. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">inline bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<h2 id="data"><a class="header" href="#data"><code>data</code></a></h2>
<p><code>data</code> defines an algebraic data type (ADT). It should look like the following:</p>
<pre><code class="language-neut">data nat {
| Zero
| Succ(nat)
}

data list(a) {
| Nil
| Cons(a, list(a))
}

data config {
| Config(
    count: int,
    foo-path: &amp;text,
    colorize: bool,
  )
}
</code></pre>
<p>You can use the content of an ADT value by using <code>match</code> or <code>case</code>:</p>
<pre><code class="language-neut">define length&lt;a&gt;(xs: list(a)): int {
  // destruct ADT values using `match`
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}

define length-noetic&lt;a&gt;(xs: &amp;list(a)): int {
  // read noetic ADT values using `case`
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length-noetic(ys))
  }
}

define use-config(c: config) {
  // pattern-matching in `let` is also possible
  let Config of {count, some-path} = c;
  print(count)
}
</code></pre>
<h2 id="resource"><a class="header" href="#resource"><code>resource</code></a></h2>
<p><code>resource</code> defines a new type by specifying how to discard/copy the values of the type. It should look like the following:</p>
<pre><code class="language-neut">resource my-type {
  function (value: pointer) {
    // .. discard the value ..
  },
  function (value: pointer) {
    // .. create a new clone of the value and return it as int ..
  },
  tag, // integer value
}
</code></pre>
<p><code>resource</code> takes three terms. The first term (&quot;discarder&quot;) receives a value of the type and discards it. The second term (&quot;copier&quot;) receives a value of the type and returns a clone of the value (keeping the original value intact). The third term is a tag that is returned when calling <code>magic call-type(my-type, 2, (..))</code>.</p>
<p>The type of a discarder is <code>(a) -&gt; unit</code> for some <code>a</code>. You might want to call functions like <code>free</code> in this term.</p>
<p>The type of a copier is <code>(a) -&gt; a</code> for some <code>a</code>. This <code>a</code> must be the same as the <code>a</code> used in the discarder. You might want to call functions like <code>malloc</code> in this term.</p>
<p>The type of a tag is <code>int</code>. See also: <a href="./terms.html#semantics-call-type">Semantics (call-type)</a></p>
<p>For example, the following is a definition of a &quot;boxed&quot; integer type with some noisy messages:</p>
<pre><code class="language-neut">resource boxed-int {
  // discarder: (pointer) -&gt; unit
  function (v: pointer) {
    print(&quot;discarded!\n&quot;);
    free(v)
  },
  // copier: (pointer) -&gt; pointer
  function (v: pointer) {
    let orig-value = load-int(v);
    let new-ptr = malloc(1);
    magic store(int, orig-value, new-ptr);
    new-ptr
  },
  // You should use `type-tag-to-int(Opaque)` as long as the structure of your
  // resource type isn't the same as one of the `type-tag` values defined in `core.type-tag`.
  // If your resource type has the same structure as one of the `type-tag` values, you can
  // use something like `type-tag-to-int(Int32)` so it can be, for example,
  // printed using `core.debug.vet: (&amp;a) -&gt; unit`.
  type-tag-to-int(Opaque),
}

// provide a way to introduce new boxed integer
define create-new-boxed-int(x: int): boxed-int {
  let new-ptr = malloc(8);
  store-int(x, new-ptr);
  magic cast(int, boxed-int, new-ptr)
}
</code></pre>
<p>A value of type <code>boxed-int</code> prints <code>&quot;discarded!\n&quot;</code> when the value is discarded.</p>
<p><code>resource</code> can be used to define low-level types like arrays.</p>
<p>You can find an example usage of <code>resource</code> in the <code>binary.nt</code> in the <a href="https://github.com/vekatze/neut-core/blob/main/source/binary.nt">core library</a>.</p>
<h2 id="rule-right"><a class="header" href="#rule-right"><code>rule-right</code></a></h2>
<p><code>rule-right</code> defines a macro-like construct that expands bracketed expressions in a fold-right manner. It should look like the following:</p>
<pre><code class="language-neut">rule-right name {
  leaf,
  node,
  root,
}
</code></pre>
<p>Once defined, <code>name</code> can be used with square brackets to accept variable-length arguments:</p>
<pre><code class="language-neut">name[x, y, z, w]
</code></pre>
<p>This expands in a fold-right manner to:</p>
<pre><code class="language-neut">root(node(x, node(y, node(z, node(w, leaf(4))))))
</code></pre>
<p>where the <code>4</code> is the length of <code>[x, y, z, w]</code>.</p>
<h3 id="example-list-construction"><a class="header" href="#example-list-construction">Example: List Construction</a></h3>
<p>The <code>List</code> construct available in the core library is defined using <code>rule-right</code>:</p>
<pre><code class="language-neut">rule-right List {
  function leaf&lt;a&gt;(_: int): list(a) {
    Nil
  },
  function node&lt;a&gt;(x: a, acc: list(a)): list(a) {
    Cons(x, acc)
  },
  function root&lt;a&gt;(x: a): a {
    x
  },
}
</code></pre>
<p>With this definition, <code>List[x, y, z]</code> simplifies as follows:</p>
<pre><code class="language-neut">List[x, y, z]

↓

root(node(x, node(y, node(z, leaf(3)))))

↓

Cons(1, Cons(2, Cons(3, Nil)))
</code></pre>
<h2 id="rule-left"><a class="header" href="#rule-left"><code>rule-left</code></a></h2>
<p><code>rule-left</code> defines a macro-like construct that expands bracketed expressions in a fold-left manner. It should look like the following:</p>
<pre><code class="language-neut">rule-left name {
  leaf,
  node,
  root,
}
</code></pre>
<p>Once defined, <code>name</code> can be used with square brackets to accept variable-length arguments:</p>
<pre><code class="language-neut">name[x, y, z, w]
</code></pre>
<p>This expands in a fold-left manner to:</p>
<pre><code class="language-neut">root(node(node(node(node(leaf(4), x), y), z), w))
</code></pre>
<p>where the <code>4</code> is the length of <code>[x, y, z, w]</code>.</p>
<h3 id="example-vector-construction"><a class="header" href="#example-vector-construction">Example: Vector Construction</a></h3>
<p>The <code>Vector</code> construct available in the core library is defined using <code>rule-left</code>:</p>
<pre><code class="language-neut">rule-left Vector {
  function leaf&lt;a&gt;(size: int): vector(a) {
    make(size)
  },
  function node&lt;a&gt;(acc: vector(a), x: a): vector(a) {
    push-back(acc, x)
  },
  function root&lt;a&gt;(x: a): a {
    x
  },
}
</code></pre>
<p>With this definition, <code>Vector[a, b, c]</code> simplifies as follows:</p>
<pre><code class="language-neut">Vector[a, b, c]

↓

root(node(node(node(leaf(3), a), b), c),)

↓

push-back(push-back(push-back(make(3), a), b), c)
</code></pre>
<h2 id="nominal"><a class="header" href="#nominal"><code>nominal</code></a></h2>
<p><code>nominal</code> declares functions for forward references. It should look like the following:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int,
}
</code></pre>
<p>An entry of <code>nominal</code> is the same form as found in <code>define</code>. Nominal definitions can be used to achieve mutual recursions:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int, // nominal definition of `is-odd`
}

// given a non-negative integer `x`, returns true if `x` is even.
define is-even(x: int): bool {
  if eq-int(x, 0) {
    True
  } else {
    is-odd(sub-int(x, 1)) // ← using nominal definition
  }
}

// given a non-negative integer `x`, returns true if `x` is odd.
// (&quot;real&quot; definition of `is-odd`)
define is-odd(x: int): bool {
  if eq-int(x, 0) {
    False
  } else {
    is-even(sub-int(x, 1))
  }
}
</code></pre>
<p>If a nominal definition isn't followed by a real definition, the compiler reports an error.</p>
<h2 id="foreign"><a class="header" href="#foreign"><code>foreign</code></a></h2>
<p><code>foreign</code> declares functions that are defined in linked objects. It should look like the following:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}
</code></pre>
<p>Foreign functions declared here can be called by using <code>magic external(..)</code>.</p>
<p>Suppose that you have a C source file with the following definition:</p>
<pre><code class="language-c">// add_const.c

int64_t neut_myapp_v1_add_const(int64_t value) {
  return value + 100;
}
</code></pre>
<p>You can add the field <code>foreign</code> to your <code>module.ens</code> to compile and link this C source file, as written <a href="modules.html#foreign">here</a>. Under this setting, the following code can utilize <code>neut_myapp_v1_add_const</code>:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}

define my-func(): int {
  let x: int = 10;
  magic external neut_myapp_v1_add_const(x)
}
</code></pre>
<p>An example project that uses <code>foreign</code> can be found <a href="https://github.com/vekatze/neut/tree/main/test/misc/foreign">here</a>.</p>
<p>You can also use LLVM intrinsics. For example, the LLVM langref states that <code>llvm.sin.*</code> intrinsic is <a href="https://llvm.org/docs/LangRef.html#llvm-sin-intrinsic">available</a>:</p>
<pre><code class="language-llvm">declare float     @llvm.sin.f32(float  %Val)
declare double    @llvm.sin.f64(double %Val)
declare x86_fp80  @llvm.sin.f80(x86_fp80  %Val)
declare fp128     @llvm.sin.f128(fp128 %Val)
declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128  %Val)
</code></pre>
<p>Thus, the next is a valid use of <code>foreign</code>:</p>
<pre><code class="language-neut">foreign {
  llvm.sin.f64(float): float,
}

define sin(x: float): float {
  magic external llvm.sin.f64(x)
}
</code></pre>
<p>Syscall wrapper functions and library functions are also available:</p>
<pre><code class="language-neut">foreign {
  exit(c-int): void,
  sleep(c-int): c-int,
}
</code></pre>
<p>Here, the definition of <code>c-int</code> is as follows:</p>
<pre><code class="language-neut">inline _c-int: type {
  introspect architecture {
  | amd64 =&gt;
    int32
  | arm64 =&gt;
    int32
  }
}

data c-int {
| C-Int(_c-int)
}
</code></pre>
<p>The type of each parameter in every foreign entry must be a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation. For example, the <code>c-int</code> in <code>exit(c-int): void</code> is valid because it compiles to <code>int32</code> (thanks to an optimization like Haskell's <code>newtype</code>).</p>
<p>The resulting type of every foreign entry must be <code>void</code> or a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation.</p>
<p>When declaring a variadic function, declare only the non-variadic part:</p>
<pre><code class="language-neut">foreign {
  printf(pointer): void,
}
</code></pre>
<p>Then, specify the types of variadic arguments when using <code>magic external</code>:</p>
<pre><code class="language-neut">define print(t: &amp;text): unit {
  // ..
  magic external printf(fmt)(len: int, val: pointer)
  //                         ^^^^^^^^^^^^^^^^^^^^^^
  //                         passing variadic arguments with types
}
</code></pre>

            <footer id="footer-paginator">
              <a rel="prev" href="modules.html" class="nav previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                ← Previous Page
              </a>

              <div id="footer-spacer"></div>

              <a rel="next" href="terms.html" class="nav next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                Next Page →
              </a>
            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules-and-sources.html"><strong aria-hidden="true">3.1.</strong> Modules and Sources</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html" class="active"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
