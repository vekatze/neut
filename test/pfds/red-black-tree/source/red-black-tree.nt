import {
- core.bool
}

use {
- core.bool
- this.red-black-tree::color
- this.red-black-tree::tree
}

enum color() {
- red()
- black()
}

enum tree(a) {
- leaf() // â† considered to be black
- node(color(), tree(a), a, tree(a))
}

// Invariant 1. No red node has a red child.
// Invariant 2. Every path from the root to an empty node contains the same number of black nodes.

enum order() {
- lt()
- eq()
- gt()
}

define-inline Cmp(a: tau): tau {
  (a, a) -> order()
}

define member<a>(cmp: Cmp(a), x: a, t: &tree(a)): bool() {
  case t {
  - leaf() =>
    bool.false()
  - node(c, t1, v, t2) =>
    match cmp(x, *v) {
    - order.lt() =>
      member(cmp, x, t1)
    - order.eq() =>
      bool.true()
    - order.gt() =>
      member(cmp, x, t2)
    }
  }
}

// detect and repair each red-red violation
define balance<a>(c: color(), t1: tree(a), v: a, t2: tree(a)): tree(a) {
  match c, t1, t2 {
  - black(), node(red(), node(red(), l11, v11, r11), x1, t12), t2 =>
    node(red(), node(black(), l11, v11, r11), x1, node(black(), t12, v, t2))
  - black(), node(red(), t11, x1, node(red(), l12, v12, r12)), t2 =>
    node(red(), node(black(), t11, x1, l12), v12, node(black(), r12, v, t2))
  - black(), t1, node(red(), node(red(), l21, v21, r21), x2, t22) =>
    node(red(), node(black(), t1, v, l21), v21, node(black(), r21, x2, t22))
  - black(), t1, node(red(), t21, x2, node(red(), l22, v22, r22)) =>
    node(red(), node(black(), t1, v, t21), x2, node(black(), l22, v22, r22))
  - c, t1, t2 =>
    node(c, t1, v, t2)
  }
}

define insert<a>(cmp: Cmp(a), x: a, t: tree(a)): tree(a) {
  let helper =
    define self(t: tree(a)): tree(a) {
      match t {
      - leaf() =>
        node(color.red(), leaf(), x, leaf())
      - node(c, left, y, right) =>
        match cmp(x, y) {
        - order.lt() =>
          balance(c, self(left), y, right)
        - order.eq() =>
          node(c, left, y, right)
        - order.gt() =>
          balance(c, left, y, self(right))
        }
      }
    }
  match helper(t) {
  - leaf() =>
    leaf() // shouldn't occur
  - node(c, left, v, right) =>
    node(color.black(), left, v, right)
  }
}

define compare-int(x: 'i64, y: 'i64): order() {
  if lt-i64(x(), y()) {
    order.lt()
  } else-if gt-i64(x(), y()) {
    order.gt()
  } else {
    order.eq()
  }
}

define main(): i64 {
  let t: tree('i64) = tree.leaf()
  let t = insert(compare-int, lambda () {3}, t)
  let t = insert(compare-int, lambda () {4}, t)
  let t = insert(compare-int, lambda () {2}, t)
  let t = insert(compare-int, lambda () {9}, t)
  let t = insert(compare-int, lambda () {100}, t)
  let t = insert(compare-int, lambda () {8}, t)
  let t = insert(compare-int, lambda () {1}, t)
  let b on t = member(compare-int, lambda () {5}, t)
  if b {
    1
  } else {
    2
  }
}
