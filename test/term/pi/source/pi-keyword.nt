import {
  core.null {null},
}

define foo(
  FOO: bool,
  a: type,
  : type,
  绔广般点瀵广蹇般: int,
): type {
  let _ = 绔广般点瀵广蹇般;
  if FOO {
    (a) -> 
  } else {
    () -> type
  }
}

define bar(a: type, some-value: a): unit {
  let _ = some-value;
  Unit
}

define test-syntax(): unit {
  let _ =
    foo of {
      a := int,
      FOO := True,
       := list(null),
      绔广般点瀵广蹇般 := {
        let x = 10;
        let y = 20;
        add-int(x, y)
      },
    }
 ;
  let _ =
    foo of {
      a := int,
       := list(null),
      FOO := False,
      绔广般点瀵广蹇般 := {
        let x = 10;
        let y = 20;
        add-int(x, y)
      },
    }
 ;
  let _ =
    foo of {
       := list(null),
      a := {
        foo of {
          绔广般点瀵广蹇般 := {
            let x = 10;
            let y = 20;
            add-int(x, y)
          },
          a := int,
           := list(null),
          FOO := True,
        }
      },
      FOO := False,
      绔广般点瀵广蹇般 := {
        let x = 10;
        let y = 20;
        add-int(x, y)
      },
    }
 ;
  let _ =
    // hole-notation + keyword arguments
    bar of {
      a := _,
      some-value := type,
    }
 ;
  Unit
}

define def-func-using-of(
  arg-1: int,
  arg-2: type,
): type {
  let _ = arg-1;
  arg-2
}
