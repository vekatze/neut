;; (definition test ()
;;   "あ")

;; (os:write os:stdout (test) 3)

;; (no-implicit-core)

;; (introspect OS
;;   (linux (include library "core/constant/linux.neut"))
;;   (darwin (include library "core/constant/darwin.neut")))

;; (include library "core/notation.neut")


(include library "core/integer.neut")

(include library "core/string.neut")

(include library "core/list.neut")

(let test "あ")

;; (section os)

;; (constant file-descriptor tau)

;; (constant stdout file-descriptor)


;; (constant write
;;   (pi
;;     ((A u64)
;;      (out file-descriptor)
;;      (str (array A u8))
;;      (len u64))
;;     (product (array A u8) u64)))

;; (attribute write (implicit 0))

;; (end os)

(use os)

;; こっちだとmalloc/freeがめっちゃ発生する。
;; (begin
;;   (let len (write stdout test 3))
;;   (let len (@os:write 3 stdout test 3))
;;   (let len (write stdout test 3))
;;   len)

;; (write hole stdout &test 3)



;; こっちだと最初と最後の1回だけ。
;; ここの最初の「&test」も「test」に解決されるわけだけど、するとbeginのあとでも「test」が
;; 使用されていることから、ここでtestのコピーが走ることになる。
(with let-bind
  (let _
    (let _ (i64 100))
    (string:print &test) ;; これは「内側」のwithについてのborrowとして処理される
    (string:print &test)) ;; 末尾でのみborrowが許される（途中では別な場所でのborrowになる）（というか途中のborrowも自動で実装されてるわ、これ）
  (let _ (string:print &test))
  (let len (string:print &test)) ;; ここの "defined but not used" はfreeを具体的に行うことを要求しているとみなせる。「せっかく借用したのに」というわけ。
  (erase test)
  len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）
  ;; 末尾でのborrowをここでもし許可しようとするなら、トップレベルのborrowが必要になってくる、というわけ。


;; (begin
;;   (let len (os:write os:stdout &test 3))
;;   (let len (os:write os:stdout &test 3))
;;   (let len (os:write os:stdout &test 3))
;;   len) ;; ここでtestがfreeされる（直前のwriteでborrowされているので）

(theorem some-theorem
  (Π ((A tau))
    (hom A A))
  (assume (_)
    (assume (x) x)))

(verify ((λ ((x tau)) x) top))


(verify some-theorem)


;; (@os:write 3 os:stdout "あ" 3)
;; (@os:write 3 os:stdout "あ" 3)
;; (@os:write 3 os:stdout "あ" 3)

;; (i64:add (os:write os:stdout test 3) 10)

;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))
;; (let a (os:write os:stdout &test 3))

(with let-bind
  (let _ (string:print &test))
  (let _ (string:print &test))
  (i64 10)
  (let _ (string:print &test))
  (let len (string:print &test))
  (erase test)
  len)


;; (let _ (string:print &test))
;; (let hoge (string:print &test))
;; (i64 10)
;; (let _ (string:print &test))
;; (let len (string:print &test))

(string:print test)

(let _ (i64 10))

(string:print test)


;; (print-character 45)
;; (string:print test)

(i64:print -1234321)

(definition fact ((n i64))
  (witness i64
    (if (i64:le n 0)
      1
      (with let-bind
        (string:print "looping with (もちろん日本語も出力できるよ): ")
        (i64:print ?n)
        (let _ (i64:add 10 10))
        (let hogehoge (i64 10))
        (let _ (i64:add hogehoge 1))
        (string:print "\n")
        (?i64:mul n (fact (?i64:sub n 1)))))))


(let xs (list i64)
  (list:new 1 2 3 4 5))

(inductive equal ((A tau) (x A) (y A))
  (refl ((z A)) (equal A z z)))

(attribute equal
  (implicit 0))

?equal:induction

?@@@equal:refl

?equal:refl



@?equal:refl

(definition my-id ((a tau) (_ tau) (_ tau) (x a)) x)

;; (definition my-id ((?a tau) (x a)) x)

;; #my-id
?my-id


(attribute my-id (implicit 0 1 2))

?my-id

(attribute my-id (implicit 1))

?@my-id



(attribute my-id (implicit 2))

?my-id


(let p (equal:refl (i64 3)))

?p

(inductive choice ()
  (item-1 () (choice))
  (item-2 () (choice)))


?choice:induction
;; (choice:induction (choice:item-1) (lambda () i64) ?admit ?admit)

(definition flip ((c (choice)))
  (witness (choice)
    (case c
      ((choice:item-1)
        (choice:item-2))
      ((choice:item-2)
        (choice:item-1)))))

?flip

(theorem double-flip-is-identity
  (pi ((c (choice)))
    (equal
      c
      (flip (flip c))))
  (assume ((c (choice)))
    (case c
      ((choice:item-1)
        admit) ;; (F @ c) {c := (choice:item-1)}
      ((choice:item-2)
        ?admit) ;; (F @ c) {c := (choice:item-2)}
        ))) ;; F @ c

?double-flip-is-identity

;; (verify double-flip-is-identity)

(string:print "\n")

;; (i64:print (fact 10))

(i64:print (fact (unsafe:cast u64 i64 (list:length xs))))

(definition unused-function ((_ tau)) tau)


(attribute unused-function
  (implicit 0))

;; (provide unused-function)

(?string:print "\n")


;; (let a1 (os:write os:stdout test 3))
;; (let a2 (os:write os:stdout test 3))
;; (let a3 (os:write os:stdout test 3))

;; (i64 0)
