<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Modality and Memory - Neut Programming Language</title>
    <meta name="description" content="A functional programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Modality and Memory - Neut Programming Language" />
    <meta property="og:description" content="A functional programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/modality-and-memory.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules-and-sources.html"><strong aria-hidden="true">3.1.</strong> Modules and Sources</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html" class="active"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="modality-and-memory"><a class="header" href="#modality-and-memory">Modality and Memory</a></h1>
<p>Here, we'll see how to interact with the box modality <code>meta</code>, which enables borrowing in Neut. We'll then see that both <code>on</code> and <code>*e</code> can be understood as syntactic sugar over this modality.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#layers-and-the-box-modality">Layers and the Box Modality</a></li>
<li><a href="#more-tools-for-boxes">More Tools for Boxes</a></li>
<li><a href="#desugaring-the-two-operations">Desugaring the Two Operations</a></li>
<li><a href="#additional-notes">Additional Notes</a></li>
</ul>
<h2 id="layers-and-the-box-modality"><a class="header" href="#layers-and-the-box-modality">Layers and the Box Modality</a></h2>
<p>In Neut, each type <code>a</code> has a corresponding type <code>meta a</code>. This type provides a way to work with <em>layers</em>, which are similar to lifetimes in other languages.</p>
<p>Below, we’ll first introduce the concept of layers, and then see how to use <code>meta a</code>.</p>
<h3 id="layers-and-variables"><a class="header" href="#layers-and-variables">Layers and Variables</a></h3>
<p>Every term in Neut has an integer called layer. Conceptually, a layer can be seen as the level at which a piece of data lives.</p>
<p>The body of a <code>define</code> starts at layer 0:</p>
<pre><code class="language-neut">define foo(): () -&gt; unit {
  // here is layer 0
  function () {
    // here is also layer 0
    Unit
  }
}
</code></pre>
<p>A variable defined at layer n can only be used at the same layer. For example, the following code is invalid because the variable <code>x</code> is defined at layer 0 but used at layer 3:</p>
<pre><code class="language-neut">define bar(): unit {
  // here is layer 0
  let x = Unit; // ← `x` is defined at layer 0

  ... // ← some layer operations here

  // layer 3 (for example)
  let v2 =
    x; // ← Error: `x` is used at layer 3 (≠ 0)
  ...
}

</code></pre>
<p>Only modality-related operations can change layers, as we'll see below.</p>
<h3 id="creating-boxes"><a class="header" href="#creating-boxes">Creating Boxes</a></h3>
<p>To create a term of type <code>meta a</code>, use <code>box</code>:</p>
<pre><code class="language-neut">define use-box(x: &amp;int, y: &amp;bool, z: &amp;text): meta pair(int, bool) {
  // here is layer 0
  // free variables:
  // - x: &amp;int
  // - y: &amp;bool
  // - z: &amp;text
  box x, y {
    // here is layer -1 (== layer(outer) - 1)
    // free variables:
    // - x: int
    // - y: bool
    // - (z is unavailable here because of layer mismatch)
    Pair(x, y)
  }
}
</code></pre>
<p>Some notes on <code>box</code>:</p>
<ul>
<li>The type of <code>xi</code> in <code>box x1, ..., xn {e}</code> must be of the form <code>&amp;ai</code>.</li>
<li>Given <code>xi: &amp;ai</code>, the type of <code>xi</code> in the body of <code>box</code> is <code>ai</code>.</li>
</ul>
<p><code>box</code> behaves as follows:</p>
<pre><code class="language-neut">box x1, ..., xn { e }

↓ // (compile)

let x1 = COPY(a1, x1);
...
let xn = COPY(an, xn);
e
</code></pre>
<p>You can omit the sequence <code>x1, ..., xn</code> entirely if no variables need to be copied.</p>
<h3 id="using-boxes"><a class="header" href="#using-boxes">Using Boxes</a></h3>
<p>To use a term of type <code>meta a</code>, use <code>letbox</code>:</p>
<pre><code class="language-neut">define use-letbox(x: int, y: bool, z: text): int {
  // here is layer 0
  // free variables:
  // - x: int
  // - y: bool
  // - z: text
  letbox extracted-value = {
    // here is layer 1 (== layer(outer) + 1)
    // (x, y, and z are unavailable here because of layer mismatch)
    box {
      // here is layer 0
      // free variables:
      // - x: int
      // - y: bool
      // - z: text
      x
    }
  };
  // here is layer 0
  // free variables:
  // - x: int
  // - y: bool
  // - z: text
  extracted-value // == x
}

</code></pre>
<p>Operationally, <code>letbox</code> is the same as <code>let</code>:</p>
<pre><code class="language-neut">letbox v = e1;
e2

↓ // (compile)

let v  = e1;
e2
</code></pre>
<h2 id="more-tools-for-boxes"><a class="header" href="#more-tools-for-boxes">More Tools for Boxes</a></h2>
<h3 id="using-boxes-without-changing-the-current-layer"><a class="header" href="#using-boxes-without-changing-the-current-layer">Using Boxes Without Changing the Current Layer</a></h3>
<p>Sometimes you want to use a term of type <code>meta a</code> without shifting your current layer. For this, Neut provides <code>letbox-T</code>, which keeps you in the same layer:</p>
<pre><code class="language-neut">define use-letbox-T(x: int, y: bool): int {
  // here is layer 0
  letbox-T value on x, y = {
    // here is layer 0 (== layer(outer))
    box {42}
  };
  // here is layer 0
  value // == 42
}
</code></pre>
<p><code>letbox-T</code> can be used for example to write functions of type <code>(meta a) -&gt; a</code> as follows:</p>
<pre><code class="language-neut">define axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T tmp = x;
  tmp
}
</code></pre>
<p>If you tried to use <code>letbox</code> instead, you’d get an error because it would result in layer mismatch.</p>
<h3 id="a-shortcut-for-creating-boxes"><a class="header" href="#a-shortcut-for-creating-boxes">A Shortcut for Creating Boxes</a></h3>
<p>We can, for example, construct a <code>meta bool</code> from a <code>bool</code> as follows:</p>
<pre><code class="language-neut">define box-bool(b: bool): meta bool {
  match b {
  | True  =&gt; box {True}
  | False =&gt; box {False}
  }
}
</code></pre>
<p>To streamline this kind of mechanical step, Neut provides <code>quote</code>:</p>
<pre><code class="language-neut">define box-bool(b: bool): meta bool {
  quote {b} // `quote` casts `bool` into `meta bool`
}
</code></pre>
<p>Not all types can be cast using <code>quote</code>. Specifically, it can't be used on any type that contains:</p>
<ul>
<li>a type of the form <code>&amp;a</code></li>
<li>a type of the form <code>(a1, ..., an) -&gt; b</code></li>
<li>a type variable</li>
</ul>
<p>If you can get <code>meta t</code> by quoting <code>e: t</code>, you can get the same type using <code>box</code> instead. In this sense, <code>quote</code> is a shortcut for creating boxes.</p>
<h2 id="desugaring-the-two-operations"><a class="header" href="#desugaring-the-two-operations">Desugaring the Two Operations</a></h2>
<p>We've seen the two constructs <code>let-on</code> and <code>*e</code>. Though they might have initially appeared a bit artificial, they are in fact straightforward applications of the box modality.</p>
<h3 id="desugar-borrowing"><a class="header" href="#desugar-borrowing">Desugar: Borrowing</a></h3>
<p>We can now desugar <code>let-on</code> as follows:</p>
<pre><code class="language-neut">let x on y, z = e1;
e2

↓ // desugar

letbox-T x on y, z = quote {e1};
e2
</code></pre>
<p>This explains why the result type of a <code>let-on</code> had to be restricted to some extent: the restriction is from <code>quote</code>.</p>
<h3 id="desugar-embodying"><a class="header" href="#desugar-embodying">Desugar: Embodying</a></h3>
<p>Using the <code>axiom-T</code> we defined above, we can also desugar <code>*e</code> as follows:</p>
<pre><code class="language-neut">*e

↓ // desugar

let x = e;
axiom-T(box x {x})
</code></pre>
<h2 id="additional-notes"><a class="header" href="#additional-notes">Additional Notes</a></h2>
<h3 id="layers-and-free-variables"><a class="header" href="#layers-and-free-variables">Layers and Free Variables</a></h3>
<p>There's one last rule that must be satisfied for memory safety. That is, if a function is defined at layer <code>n</code>, then any free variable <code>x</code> in the function must satisfy <code>layer(x) &lt;= n</code>.</p>
<p>Without this rule, you could do something like the following:</p>
<pre><code class="language-neut">define joker(): () -&gt; unit {
  // layer 0
  let xs: list(int) = List[1, 2, 3];
  letbox-T f on xs = {
    // layer 0
    box {
      // layer -1
      function () { // ★
        letbox k = {
          // layer 0
          let len = length(xs);
          box {Unit}
        };
        Unit
      }
    }
  };
  f // function with xs: &amp;list(int) as a free variable
  // FREE(xs)
}

define main(): unit {
  let f = joker();
  f(); // xs used after freed here
}
</code></pre>
<p>This example would wrongly allow a function at layer 0 (<code>★</code>) to keep a reference to data (<code>xs</code>) that, after the outer <code>letbox</code> completes, could be deallocated, leading to a use-after-free scenario in the body of the main function. Hence, Neut’s layer rules prohibit capturing a higher-layer variable in a lower-layer function.</p>
<h3 id="using-meta"><a class="header" href="#using-meta">Using <code>meta</code></a></h3>
<p>The following function parses data and stores backups of said data.</p>
<pre><code class="language-neut">define backup-parse&lt;a&gt;(transformer: (binary) -&gt; a): a {
  let !input: binary = get-next-input();
  write-to-file(input-backup, bin-to-hex(!input)); // !input copied
  transformer(!input)
}
</code></pre>
<p>This function might get slow if huge chunks of data are processed due to the copy. Rewriting it to use noetic values could look like the following:</p>
<pre><code class="language-neut">define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input)); // bin-to-hex takes a &amp;binary now, avoiding the copy
    transformer(binary)
  };
  result
}
</code></pre>
<p>This won't compile because <code>transformer</code> contains a free variable <code>a</code>. This works as a safety guard, it compiled the following scenario would be possible:</p>
<pre><code class="language-neut">define id-bin(arg: &amp;binary): &amp;binary {
  arg
}

define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}

define zen(): unit {
  let joker = backup-parse(id-bin);
  write-to-file(somefile, bin-to-hex(joker));
  Unit
}
</code></pre>
<p>The following happens inside <code>zen</code>:</p>
<ol>
<li><code>backup-parse(id-bin)</code> evaluates to a reference to (the freed) <code>input</code></li>
<li><code>joker</code> holds the (dangling) reference</li>
<li><code>bin-to-hex</code> takes <code>joker</code> as an argument, causing an use-after-free</li>
</ol>
<p>To fancy the requirements of the type system <code>meta</code> must be used as follows.</p>
<pre><code class="language-neut">define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; meta a): a {
  let input: binary = get-next-input();
  letbox-T result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}
</code></pre>
<p>The <code>meta</code> specifier asserts that the value a call to <code>transformer</code> evaluates will be valid on the outer layer (in this case the layer of <code>zen</code>, since it's where <code>backup-parse</code> has been called). The requirements of the operators that lift values into <code>meta</code> guarantee that this is the case. In order to make the previous example work, <code>id-bin</code> could look like the following:</p>
<pre><code class="language-neut">define id-bin(arg: &amp;binary): meta binary {
  box arg { // *arg copied
    arg
  }
}

define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}

define zen(): unit {
  let joker = backup-parse(id-bin);
  let _ on joker = write-to-file(somefile, bin-to-hex(joker));
  Unit
}
</code></pre>
<p>Lastly, to avoid the newly introduced copy, the following refactor is possible:</p>
<pre><code class="language-neut">define write-to-somefile(arg: &amp;binary): meta unit { // used to be id-bin
  write-to-file(somefile, bin-to-hex(arg));
  box {Unit}
}

define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}

define zen(): unit {
  backup-parse(write-to-somefile)
}
</code></pre>

            <footer id="footer-paginator">
              <a rel="prev" href="static-memory-management.html" class="nav previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                ← Previous Page
              </a>

              <div id="footer-spacer"></div>

              <a rel="next" href="language-reference.html" class="nav next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                Next Page →
              </a>
            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules-and-sources.html"><strong aria-hidden="true">3.1.</strong> Modules and Sources</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html" class="active"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
