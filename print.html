<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Neut Programming Language</title>
    <meta name="description" content="A functional programming language with static memory management." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="css/general.css" />
    <link rel="stylesheet" href="highlight.css" />
    <meta property="og:title" content="Neut Programming Language" />
    <meta property="og:description" content="A functional programming language with static memory management." />
    <meta property="og:url" content="https://vekatze.github.io/neut/print.md" />
    <meta property="og:type" content="article" />
  </head>
  <body>
    <div id="body-container">
      <header id="menu-bar">
        <h1 class="menu-title">
          <a href="overview.html">
            Neut Programming Language
          </a>
        </h1>

        <div class="right-buttons">
            <a href="https://github.com/vekatze/neut" class="menubar-item">
              <span>GitHub</span>
            </a>
        </div>
      </header>
      <div id="content-box">
        <aside id="sidebar">
          <nav class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules-and-sources.html"><strong aria-hidden="true">3.1.</strong> Modules and Sources</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
          </nav>
        </aside>

        <main id="content" tabindex="0">
          <article id="content-inner">
            <h1 id="neut-programming-language"><a class="header" href="#neut-programming-language">Neut Programming Language</a></h1>
<p>Neut is a functional programming language with static memory management.</p>
<p>Its key features include:</p>
<ul class="star-list">
  <li>Full λ-calculus support</li>
  <li>Predictable automatic memory management</li>
  <li>The ability to achieve both of the above without additional type annotations</li>
</ul>
<p>Neut doesn't use a GC. Instead, it takes a <em>type-directed approach</em> for memory management.</p>
<h2 id="what-does-it-look-like"><a class="header" href="#what-does-it-look-like">What Does it Look Like?</a></h2>
<p>Like the following:</p>
<pre><code class="language-neut">// the obligatory hello world
define hello(): unit {
  print(&quot;Hello, world!\n&quot;)
}

// an algebraic data type
data my-list(a) {
| Nil
| Cons(a, my-list(a))
}

// a recursive function with pattern matching
define noisy-length&lt;a&gt;(xs: my-list(a)): int {
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    let my-message = &quot;hey\n&quot;;
    print(my-message);
    add-int(1, noisy-length(ys))
  }
}
</code></pre>
<h2 id="static-memory-management--but-how"><a class="header" href="#static-memory-management--but-how">Static Memory Management — But How?</a></h2>
<p><em>Neut translates a type into a function</em> that can discard/copy the values of the type. By using those functions, the compiler translates programs so that every variable is used exactly once.</p>
<p>For example, if a variable is used twice, a translation like the following happens:</p>
<pre><code class="language-neut">// (before)
let xs: list(a) = List[value-1, value-2];
some-func(xs, xs) // `xs` is used twice

// ↓

// (after)
let xs: list(a) = List[value-1, value-2];
let (xs1, xs2) = copy-list-a(xs);  // `xs` is used once
some-func(xs1, xs2)
</code></pre>
<p>If you need more information, see <a href="./how-to-execute-types.html">How to Execute Types</a>.</p>
<p>You might wonder: <em>&quot;So do I have to, for example, copy an entire list just to get its length? Isn't that a tragedy?&quot;</em>. This topic is covered in <a href="./static-memory-management.html">Static Memory Management</a> and <a href="./modality-and-memory.html">Modality and Memory</a>. As written there, Neut avoids such copy operations by using the <em>box modality</em>, achieving something like borrowing in Rust.</p>
<h2 id="quick-list-of-other-features"><a class="header" href="#quick-list-of-other-features">Quick List of Other Features</a></h2>
<ul>
<li>Call by value</li>
<li>Impure</li>
<li>Compiles to <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a> and binary</li>
<li>The type system ≒ <a href="https://en.wikipedia.org/wiki/Calculus_of_constructions">CoC</a> + <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">ADT</a> + (recursion) + (T-necessity) - (universe hierarchy)
<ul>
<li>That is, the usual one in functional programming, but a bit generalized</li>
</ul>
</li>
<li>Built-in <a href="./lovely-lsp-showcase.html">LSP support</a></li>
<li>Built-in <a href="./rapid-prototyping.html">rapid prototyping experience</a> like scripting languages</li>
<li>Built-in formatter like Go</li>
</ul>
<hr />
<p>You can press the &quot;→&quot; key to go to the next page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>To install the toolchain, execute <a href="https://raw.githubusercontent.com/vekatze/neut/main/install.sh">the installation script</a>:</p>
<pre><code class="language-sh">curl -sSL https://raw.githubusercontent.com/vekatze/neut/main/install.sh | bash
</code></pre>
<p>Then please follow the instructions.</p>
<p>You might also want to <a href="./editor-setup.html">configure your editor</a>.</p>
<p>If you prefer manual installation, see <a href="./manual-installation.html">here</a>.</p>
<h2 id="uninstallation"><a class="header" href="#uninstallation">Uninstallation</a></h2>
<p>To uninstall,</p>
<ol>
<li>remove the binary <code>~/.local/bin/neut</code>,</li>
<li>remove <code>NEUT_CORE_MODULE_URL</code> and <code>NEUT_CORE_MODULE_DIGEST</code> in your shell config, and</li>
<li>remove cache directories in your projects (if desired).</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>Neut is a <em>module-based</em> <em>functional</em> programming language with <em>static</em> memory management via <em>modality</em>. This chapter is a quick introduction to this language.</p>
<p><a href="./modules-and-sources.html">Modules and Sources</a> covers the <em>&quot;module-based&quot;</em> part. We'll see how to use modules in Neut.</p>
<p><a href="./programming-in-neut.html">Programming in Neut</a> covers the <em>&quot;functional&quot;</em> part. We'll see how to write code in Neut.</p>
<p><a href="./static-memory-management.html">Static Memory Management</a> covers the <em>&quot;static&quot;</em> part. We'll see how memory is managed in Neut. We'll also see Neut's technique to optimize memory allocation.</p>
<p><a href="./modality-and-memory.html">Modality and Memory</a> covers the <em>&quot;modality&quot;</em> part. We'll see how memory operations introduced in the previous section can be understood via modality.</p>
<p>This chapter assumes you are familiar with languages like Haskell, OCaml, or F#.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-and-sources"><a class="header" href="#modules-and-sources">Modules and Sources</a></h1>
<p>In this section, we'll see how to use modules in Neut.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="modules-and-sources.html#basics-of-modules">Basics of Modules</a></li>
<li><a href="modules-and-sources.html#basics-of-source-files">Basics of Source Files</a></li>
<li><a href="modules-and-sources.html#publishing-modules">Publishing Modules</a></li>
<li><a href="modules-and-sources.html#adding-dependency-modules">Adding Dependency Modules</a></li>
<li><a href="modules-and-sources.html#importing-files">Importing Files</a></li>
</ul>
<h2 id="basics-of-modules"><a class="header" href="#basics-of-modules">Basics of Modules</a></h2>
<h3 id="creating-building-and-executing-a-module"><a class="header" href="#creating-building-and-executing-a-module">Creating, Building, and Executing a Module</a></h3>
<p>Let's create a module by running the following command:</p>
<pre><code class="language-sh">neut create sample
</code></pre>
<p>This command creates a template module <code>./sample/</code> that performs &quot;hello world&quot;.</p>
<p>You can build and execute this module as follows:</p>
<pre><code class="language-sh">cd ./sample
neut build sample --execute # =&gt; &quot;Hello, world!&quot;
</code></pre>
<p>You can also retrieve the resulting binary:</p>
<pre><code class="language-sh">neut build sample --install ./bin # creates a directory `bin` if necessary
./bin/sample # =&gt; &quot;Hello, world!&quot;
</code></pre>
<h3 id="structure-of-a-module"><a class="header" href="#structure-of-a-module">Structure of a Module</a></h3>
<p>The structure of a module is as follows:</p>
<pre><code class="language-text">sample/
├── cache/
│  └── ...
├── source/
│  └── sample.nt
└── module.ens
</code></pre>
<p>The directory <code>cache</code> is where object files (binary files) and dependencies are put. You don't normally have to go into the directory.</p>
<p>The directory <code>source</code> is where source files are put.</p>
<p>The file <code>module.ens</code> contains meta information about this module, such as dependencies.</p>
<div class="info-block">
<p>You can change the locations of special directories such as <code>cache</code> using <code>module.ens</code>. See <a href="./modules.html">Modules</a> for more information.</p>
</div>
<h3 id="moduleens"><a class="header" href="#moduleens">module.ens</a></h3>
<p>The content of <code>module.ens</code> is something like the following:</p>
<pre><code class="language-ens">{
  target {
    sample {
      main &quot;sample.nt&quot;,
    },
  },
  dependency {
    core {
      digest &quot;(base64url-encoded checksum)&quot;,
      mirror [
        &quot;https://github.com/.../X-Y-Z.tar.zst&quot;,
      ],
      enable-preset true,
    },
  },
}
</code></pre>
<p><code>target</code> specifies the targets of a module. In the example above, the command <code>neut build sample</code> builds the module using the file <code>source/sample.nt</code> as its entry point.</p>
<p><code>dependency</code> specifies the dependencies of a module. Since our running example doesn't do much, the only dependency is <code>core</code>, which is the same as &quot;prelude&quot; in other languages.</p>
<p><code>digest</code> is the base64url-encoded checksum of a dependency.</p>
<p><code>mirror</code> is a list of URLs of a dependency.</p>
<p><code>enable-preset</code> makes the dependency behave similarly to the Prelude in Haskell. That is, when <code>enable-preset</code> is set to <code>true</code>, the names specified in the dependency are automatically imported into every file in our module. This field should be set to <code>true</code> only for the <code>core</code> library.</p>
<h2 id="basics-of-source-files"><a class="header" href="#basics-of-source-files">Basics of Source Files</a></h2>
<h3 id="editing-source-files"><a class="header" href="#editing-source-files">Editing Source Files</a></h3>
<p>Let's see the content of <code>source/sample.nt</code>:</p>
<pre><code class="language-neut">// sample.nt

define main(): unit {
  print(&quot;Hello, world!\n&quot;); // `print` is defined in `core`
}
</code></pre>
<p>The above code defines a function <code>main</code> that returns a value of type <code>unit</code>. This function prints <code>&quot;Hello, world!\n&quot;</code>.</p>
<p>Let's try editing the code as follows:</p>
<pre><code class="language-neut">define main(): unit {
  print(&quot;Yo\n&quot;);
}
</code></pre>
<p>Then, build and execute the project:</p>
<pre><code class="language-sh">neut build sample --execute # =&gt; Yo
</code></pre>
<p>You should be able to see that the result changes accordingly.</p>
<h3 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h3>
<p>You can also define your own functions:</p>
<pre><code class="language-neut">// sample.nt

import {
  core.int.io {print-int},
}

define get-int(): int {
  42
}

define main(): unit {
  print-int(get-int()); // =&gt; 42
}
</code></pre>
<p>Functions can also take arguments. Let's rewrite <code>sample.nt</code> as follows:</p>
<pre><code class="language-neut">// sample.nt

import {
  core.int.io {print-int},
}

define increment(x: int): int {
  add-int(x, 1)
}

define my-add(x: int, y: int): int {
  add-int(x, y)
}

define main(): unit {
  print-int(my-add(10, increment(10))); // =&gt; 21
}
</code></pre>
<p>Top-level items like <code>define</code> are called statements. You’ll learn more about them in the next section.</p>
<div class="info-block">
<p>As in F#, statements in Neut are order-sensitive. Therefore, if you define <code>main</code> before <code>my-add</code>, the code won't compile. For forward references, you have to explicitly declare names beforehand using a statement called <code>nominal</code>, which we'll see in the next section.</p>
</div>
<h2 id="publishing-modules"><a class="header" href="#publishing-modules">Publishing Modules</a></h2>
<p>Let's publish our module so others can use <code>increment</code> and <code>my-add</code>.</p>
<p>You can create a tarball snapshot of your module using <code>neut archive</code>:</p>
<pre><code class="language-sh">neut archive 0-1
ls ./archive # =&gt; 0-1.tar.zst
</code></pre>
<p>The argument of <code>neut archive</code> must be something like <code>0-1-0</code>, <code>2-3-1</code>, or <code>1-2-3-4-5-6</code>. The compiler interprets these names as semantic versions.</p>
<p>You can then upload these tarballs by pushing them to GitHub, for example.</p>
<h2 id="adding-dependency-modules"><a class="header" href="#adding-dependency-modules">Adding Dependency Modules</a></h2>
<p><code>neut get</code> can be used to add dependencies:</p>
<pre><code class="language-sh"># creates a new module
neut create new-item
cd new-item

# adds a sample module that contains `my-add` and `increment` to your module
neut get some-name https://github.com/vekatze/neut-sample/raw/main/archive/0-1-0.tar.zst
</code></pre>
<p>The command <code>neut get</code> fetches the tarball from the specified URL and adds it to the current module. The module can then be used as <code>some-name</code> in your module.</p>
<p>The information of the newly-added module is saved to <code>module.ens</code>:</p>
<pre><code class="language-ens">{
  target {
    new-item {
      main &quot;new-item.nt&quot;,
    },
  },
  dependency {
    core { .. },
    // ↓ HERE
    some-name {
      digest &quot;..&quot;,
      mirror [
        &quot;https://github.com/YOUR_NAME/YOUR_REPO_NAME/raw/main/archive/0-1-0.tar.zst&quot;,
      ],
    },
  },
}
</code></pre>
<div class="info-block">
<p>The &quot;real&quot; name of a dependency is the digest of the tarball. Names such as <code>some-name</code> are just aliases.</p>
</div>
<h2 id="importing-files"><a class="header" href="#importing-files">Importing Files</a></h2>
<h3 id="importing-files-in-dependencies"><a class="header" href="#importing-files-in-dependencies">Importing Files in Dependencies</a></h3>
<p>Dependencies can be used in your code, of course:</p>
<pre><code class="language-neut">// new-item.nt

import {
  core.int.io {print-int},
  some-name.sample {my-add}, // imports `my-add` in `source/sample.nt`
}

define main(): unit {
  print-int(my-add(10, 11)); // ← using `my-add`
}
</code></pre>
<p>Let's focus on <code>import</code>. <code>import</code> consists of lines like the one below:</p>
<pre><code class="language-neut">some-name.sample {my-add}
</code></pre>
<p>The first component of such a line (<code>some-name</code>) is our alias of the dependency.</p>
<p>What follows (<code>sample</code>) is the relative path to the file from the source directory of the dependency module. Here, you don't have to write the file extension <code>.nt</code>.</p>
<p>Like <code>{my-add}</code> in the example above, every item of an <code>import</code> can optionally have a list of names. Names in these lists are made available after <code>import</code>.</p>
<p>You can also use the fully-qualified form of <code>my-add</code>:</p>
<pre><code class="language-neut">// new-item.nt

import {
  core.int.io {print-int},
  some-name.sample, // removed `{my-add}`
}

define main(): unit {
  // ↓ using the fully-qualified form of `my-add`
  print-int(some-name.sample.my-add(10, 11));
}
</code></pre>
<p>Also, files like <code>source/foo/item.nt</code> in <code>some-name</code> can be imported as follows:</p>
<pre><code class="language-neut">import {
  some-name.foo.item,
}
</code></pre>
<h3 id="importing-files-in-the-current-module"><a class="header" href="#importing-files-in-the-current-module">Importing Files in the Current Module</a></h3>
<p>Let's try creating a new file <code>new-item/source/foo/greet.nt</code> with the following content:</p>
<pre><code class="language-neut">// foo/greet.nt

define yo(): unit {
  print(&quot;Yo&quot;);
}
</code></pre>
<p>This file can then be used from <code>new-item/source/new-item.nt</code> as follows:</p>
<pre><code class="language-neut">// new-item.nt

import {
  this.foo.greet {yo},
}

define main(): unit {
  yo();
}
</code></pre>
<p>That is, the name of the current module is always <code>this</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-in-neut"><a class="header" href="#programming-in-neut">Programming in Neut</a></h1>
<p>Here, we'll see how to write programs in Neut.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ul>
<li><a href="programming-in-neut.html#variables">Variables</a></li>
<li><a href="programming-in-neut.html#functions">Functions</a></li>
<li><a href="programming-in-neut.html#algebraic-data-types">Algebraic Data Types</a></li>
<li><a href="programming-in-neut.html#parallel-computation">Parallel Computation</a></li>
<li><a href="programming-in-neut.html#misc">Misc</a></li>
</ul>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>You can use <code>let</code> to define variables:</p>
<pre><code class="language-neut">define hey(): unit {
  let x = &quot;hello&quot;;
  let y: int = 100;
  let z: float = 3.8;
  print(&quot;hey&quot;);
}
</code></pre>
<p>The compiler warns about unused variables (<code>x</code>, <code>y</code>, and <code>z</code> in the example above). You can use the special name <code>_</code> to suppress those warnings:</p>
<pre><code class="language-neut">define hey(): unit {
  let _ = &quot;hello&quot;;
  let _: int = 100;
  let _: float = 3.8;
  print(&quot;hey&quot;);
}
</code></pre>
<p><code>let</code>s can be nested using <code>{..}</code>:</p>
<pre><code class="language-neut">define hey(): unit {
  let x = {
    let y: int = 100;
    let z: float = 3.8;
    &quot;hello&quot;
  };
  print(x); // =&gt; hello
}
</code></pre>
<p>You can use <code>e1; e2</code> as syntactic sugar for <code>let _: unit = e1; e2</code>:</p>
<pre><code class="language-neut">define hey(): unit {
  print(&quot;a&quot;);
  print(&quot;b&quot;);
}

// ↓ (desugar)

define hey(): unit {
  let _ = print(&quot;a&quot;);
  print(&quot;b&quot;);
}
</code></pre>
<p>You can use <code>e;</code> as syntactic sugar for <code>let _: unit = e; Unit</code>:</p>
<pre><code class="language-neut">define hey(): unit {
  print(&quot;hey&quot;); // using a trailing semicolon
}

↓

define hey(): unit {
  let _: unit = print(&quot;hey&quot;);
  Unit
}
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="defining-functions-at-the-top-level"><a class="header" href="#defining-functions-at-the-top-level">Defining Functions at the Top Level</a></h3>
<p>You can use the statement <code>define</code> to define functions:</p>
<pre><code class="language-neut">// defining an ordinary function
define my-func1(x1: int, x2: bool): bool {
  x2
}

// defining a recursive function
define my-func2(cond: bool): int {
  if cond {
    1
  } else {
    my-func2(not(cond)) // `my-func2` is available here
  }
}

// a function that returns a function
define my-func3(): (int, bool) -&gt; bool {
  my-func1
}
</code></pre>
<p><code>define</code> can also define a function with implicit parameters (or &quot;generics&quot;):</p>
<pre><code class="language-neut">// The `a` in the angle bracket is the implicit parameter of `id`
define id&lt;a&gt;(x: a): a {
  x
}

define use-id(): int {
  let str = 10;
  id(str) // calling `id` without specifying `a` explicitly
}
</code></pre>
<p>Incidentally, you can explicitly write the type of <code>a</code>:</p>
<pre><code class="language-neut">define id&lt;a: type&gt;(x: a): a { // `type` is the type of types
  x
}
</code></pre>
<p>You can define <code>id</code> without using any implicit parameters as follows (just for comparison):</p>
<pre><code class="language-neut">define id(a: type, x: a): a {
  x
}

// using `id`
define use-id(): int {
  let str = 10;
  id(int, str) // ← the first argument `int` is now made explicit
}
</code></pre>
<h3 id="defining-functions-in-a-body-of-a-function"><a class="header" href="#defining-functions-in-a-body-of-a-function">Defining Functions in a Body of a Function</a></h3>
<p>You can use <code>function</code> to define an anonymous function:</p>
<pre><code class="language-neut">define foo() {
  let f =
    function (x: int, cond: bool) {
      if cond {
        x
      } else {
        add-int(x, 1)
      }
    };
  f(10, False) // → 11
}
</code></pre>
<p>You can also use <code>define</code> in the body of a function to define a recursive function:</p>
<pre><code class="language-neut">define foo() {
  let f =
    define print-multiple-hellos(counter: int) {
      if eq-int(counter, 0) {
        Unit
      } else {
        print(&quot;hello\n&quot;);
        print-multiple-hellos(sub-int(counter, 1))
      }
    };
  f(10) // prints &quot;hello&quot; 10 times
}
</code></pre>
<div class="info-block">
<p>The compiler reports an error if you rewrite the example above so that it uses the variable <code>f</code> more than once. This behavior prevents unexpected copying of values. You can satisfy the compiler by renaming <code>f</code> into <code>!f</code>. The next section will cover this topic.</p>
</div>
<h3 id="calling-functions"><a class="header" href="#calling-functions">Calling Functions</a></h3>
<p>You can call a function <code>f</code> with arguments <code>e1</code>, ..., <code>en</code> by writing <code>f(e1, ..., en)</code>:</p>
<pre><code class="language-neut">define my-func(x: int, y: int): int {
  add-int(x, y)
}

define use-my-func(): int {
  my-func(10, 20)
}
</code></pre>
<p>The syntactic sugar <code>of</code> can be used to rewrite the above <code>use-my-func</code> as follows:</p>
<pre><code class="language-neut">define use-my-func(): int {
  my-func of {
    x := 10,
    y := 20,
  }
}
</code></pre>
<p>A lot of primitive functions (from LLVM) are also available. Please see <a href="./primitives.html">Primitives</a> for more.</p>
<h2 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h2>
<p>You can use the statement <code>data</code> to define ADTs:</p>
<pre><code class="language-neut">data my-nat {
| My-Zero
| My-Succ(my-nat)
}
// In Haskell:
//   data my-nat
//     = My-Zero
//     | My-Succ my-nat


//------------

data my-list(a) {
| My-Nil
| My-Cons(a, my-list(a))
}
// In Haskell:
//   data my-list a
//     = My-Nil
//     | My-Cons a (my-list a)
</code></pre>
<p>Parameters in constructors can optionally have explicit names:</p>
<pre><code class="language-neut">data config {
| Config(count: int, cond: bool)
}
</code></pre>
<p>You might want to write this vertically using a trailing comma:</p>
<pre><code class="language-neut">data config {
| Config(
    count: int,
    cond: bool,
  )
}
</code></pre>
<h3 id="creating-adt-values"><a class="header" href="#creating-adt-values">Creating ADT Values</a></h3>
<p>You can use constructors just like normal functions to create ADT values:</p>
<pre><code class="language-neut">define make-my-list(): my-list(int) {
  My-Cons(1, My-Cons(2, My-Nil))
}

define make-config(): config {
  Config of {
    count := 10,
    cond := True,
  }
}
</code></pre>
<h3 id="using-adt-values"><a class="header" href="#using-adt-values">Using ADT values</a></h3>
<p>You can use <code>match</code> to destructure ADT values:</p>
<pre><code class="language-neut">define sum(xs: my-list(int)): int {
  match xs {
  | My-Nil =&gt;
    0
  | My-Cons(y, ys) =&gt;
    add-int(y, sum(ys))
  }
}
</code></pre>
<p>Nested matching is also possible:</p>
<pre><code class="language-neut">define foo(xs: my-list(int)): int {
  match xs {
  | My-Nil =&gt;
    0
  | My-Cons(y, My-Cons(z, My-Nil)) =&gt;
    1
  | My-Cons(_, _) =&gt;
    2
  }
}
</code></pre>
<p>The result of <code>match</code> can be bound to a variable:</p>
<pre><code class="language-neut">define yo(xs: my-list(int)): int {
  let val =
    match xs {
    | My-Nil =&gt;
      0
    | My-Cons(_, _) =&gt;
      1
    };
  val
}
</code></pre>
<h2 id="parallel-computation"><a class="header" href="#parallel-computation">Parallel Computation</a></h2>
<p>You can use <code>detach</code> and <code>attach</code> to perform parallel computation:</p>
<pre><code class="language-neut">define foo(): unit {
  let t1: thread(unit) =
    // creates a thread
    detach {
      let value = some-heavy-computation();
      print(value)
    };
  let t2: thread(unit) =
    // creates a thread
    detach {
      let value = other-heavy-computation();
      print(value)
    };
  // wait
  let result-1 = attach { t1 };
  // wait
  let result-2 = attach { t2 };
  Unit
}
</code></pre>
<p><code>detach</code> receives a term of type <code>t</code> and returns a term of type <code>thread(t)</code>. Internally, <code>detach</code> creates a new thread and starts computing the term in that thread.</p>
<p><code>attach</code> receives a term of type <code>thread(t)</code> and returns a term of type <code>t</code>. Internally, <code>attach</code> waits for a given thread to finish and extracts its result.</p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="nominal"><a class="header" href="#nominal"><code>nominal</code></a></h3>
<p>You can use <code>nominal</code> for forward references:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int, // ← declaration of `is-odd`
}

define is-even(x: int): bool {
  if eq-int(x, 0) {
    True
  } else {
    is-odd(sub-int(x, 1)) // ← using the nominal definition of `is-odd`
  }
}

// ↓ the real definition of `is-odd`
define is-odd(x: int): bool {
  if eq-int(x, 0) {
    False
  } else {
    is-even(sub-int(x, 1))
  }
}
</code></pre>
<h3 id="if"><a class="header" href="#if"><code>if</code></a></h3>
<p>The core library defines <code>bool</code> as follows:</p>
<pre><code class="language-neut">data bool {
| False
| True
}
</code></pre>
<p>You can use <code>if</code> when you use this <code>bool</code>:</p>
<pre><code class="language-neut">define yo(cond: bool) {
  if cond {
    print(&quot;yo!&quot;)
  } else {
    print(&quot;yo&quot;)
  }
}

// ↓ desugar

define yo(cond: bool) {
  match cond {
  | True =&gt;
    print(&quot;yo!&quot;)
  | False =&gt;
    print(&quot;yo&quot;)
  }
}
</code></pre>
<h3 id="admit"><a class="header" href="#admit"><code>admit</code></a></h3>
<p>You can use <code>admit</code> to postpone implementing a function and satisfy the type checker:</p>
<pre><code class="language-neut">define my-complex-function(x: int, y: bool): int {
  admit
}
</code></pre>
<h3 id="assert"><a class="header" href="#assert"><code>assert</code></a></h3>
<p>You can use <code>assert</code> as follows:</p>
<pre><code class="language-neut">define fact(n: int): int {
  assert &quot;n must be non-negative&quot; {
    ge-int(n, 0)
  };
  if eq-int(n, 0) {
    1
  } else {
    let next = sub-int(n, 1);
    mul-int(n, fact(next))
  }
}
</code></pre>
<p>The type of <code>assert &quot;..&quot; { .. }</code> is <code>unit</code>.</p>
<p><code>assert</code> checks if a given condition is satisfied. If the condition is <code>True</code>, it does nothing. Otherwise, it reports that the assertion has failed and exits the program with exit code <code>1</code>.</p>
<p>If you pass <code>--mode release</code> to <code>neut build</code>, <code>assert</code> does nothing.</p>
<h3 id="miscellaneous-1"><a class="header" href="#miscellaneous-1">Miscellaneous</a></h3>
<ul>
<li>Additional syntactic sugar is also available. For more, please see the <a href="./terms.html#syntactic-sugar">language reference</a>.</li>
<li>If you want to call foreign functions (FFI), please see <a href="statements.html#foreign">here</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-memory-management"><a class="header" href="#static-memory-management">Static Memory Management</a></h1>
<p>Here, we'll see how memory is managed in Neut. We'll also see two important optimizations.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ul>
<li><a href="static-memory-management.html#copying-and-discarding-values">Copying and Discarding Values</a></li>
<li><a href="static-memory-management.html#optimization-reusing-memory">Optimization: Reusing Memory</a></li>
<li><a href="static-memory-management.html#optimization-avoiding-unnecessary-copies">Optimization: Avoiding Unnecessary Copies</a></li>
</ul>
<h2 id="copying-and-discarding-values"><a class="header" href="#copying-and-discarding-values">Copying and Discarding Values</a></h2>
<h3 id="inserting-copy-and-discard"><a class="header" href="#inserting-copy-and-discard">Inserting <code>COPY</code> and <code>DISCARD</code></a></h3>
<p>In Neut, the content of a variable is copied if the variable is used more than once. For example, consider the following code:</p>
<pre><code class="language-neut">// before compilation (pseudo code)
define foo(xs: list(int)): list(int) {
  let ys = xs; // using `xs` (1)
  let zs = xs; // using `xs` (2)
  some-func(ys);
  other-func(zs);
  xs // using `xs` (3)
}
</code></pre>
<p>In the code above, <code>xs</code> is used three times. Therefore, its content is copied twice:</p>
<pre><code class="language-neut">// after compilation (pseudo-code)
define foo(xs: list(int)): list(int) {
  let xs1 = COPY(list(int), xs);
  let xs2 = COPY(list(int), xs);
  let ys = xs1;
  let zs = xs2;
  some-func(ys);
  other-func(zs);
  xs
}
</code></pre>
<p>Also, the content of a variable is discarded if the variable isn't used. For example, consider the following code:</p>
<pre><code class="language-neut">// before compilation
define bar(xs: list(int)): unit {
  Unit
}
</code></pre>
<p>In the code above, <code>xs</code> isn't used. Therefore, its content is discarded:</p>
<pre><code class="language-neut">// after compilation (pseudo-code)
define bar(xs: list(int)): unit {
  DISCARD(list(int), xs);
  Unit
}
</code></pre>
<p>Ignoring the arguments to <code>COPY</code>, this translation ensures that each variable occurs linearly (i.e., exactly once). This forms the basis of memory management in Neut.</p>
<p>If you're interested in how Neut implements this translation, see <a href="./how-to-execute-types.html">How to Execute Types</a>.</p>
<h3 id="avoiding-unintentional-copies"><a class="header" href="#avoiding-unintentional-copies">Avoiding Unintentional Copies</a></h3>
<p>To avoid unintentional copies, the compiler requires the <code>!</code> prefix on a variable name when a copy is needed. For example, consider the following code:</p>
<pre><code class="language-neut">define make-pair(t: text): pair(text, text) {
  Pair(t, t)
}
</code></pre>
<p>The compiler rejects this code because the variable <code>t</code> is used twice without the <code>!</code> prefix.</p>
<p>You can satisfy the compiler by renaming <code>t</code> to <code>!t</code>:</p>
<pre><code class="language-neut">define make-pair(!t: text): pair(text, text) {
  Pair(!t, !t)
}
</code></pre>
<p>The <code>!</code> prefix is unnecessary if the variable can be copied for free. For example, consider the following code:</p>
<pre><code class="language-neut">define make-pair(x: int): pair(int, int) {
  Pair(x, x)
}
</code></pre>
<p>The compiler accepts this code since we can &quot;copy&quot; integers for free (by reusing the same value).</p>
<h2 id="optimization-reusing-memory"><a class="header" href="#optimization-reusing-memory">Optimization: Reusing Memory</a></h2>
<p>The compiler exploits Neut's static nature to reuse memory. Consider the following code:</p>
<pre><code class="language-neut">data int-list {
| Nil
| Cons(int, int-list)
}

// [1, 5, 9] =&gt; [2, 6, 10]
define increment(xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    Nil
  | Cons(y, ys) =&gt;
    let foo = add-int(y, 1);
    let bar = increment(ys);
    Cons(foo, bar)
  }
}
</code></pre>
<p>The naive behavior of the <code>Cons</code> clause in the <code>match</code> would be something like the following:</p>
<ol>
<li>Extract <code>y</code> and <code>ys</code> from <code>Cons(y, ys)</code></li>
<li><code>free</code> the outer tuple of <code>Cons(y, ys)</code></li>
<li>Calculate <code>foo</code> and <code>bar</code></li>
<li>Allocate memory region using <code>malloc</code> to represent the tuple of <code>Cons(foo, bar)</code></li>
<li>Store the calculated values to the pointer and return it</li>
</ol>
<p>Now, note that:</p>
<ul>
<li>the outer tuple of <code>Cons(y, ys)</code> will never be used after extracting its contents, and that</li>
<li>the outer tuples of <code>Cons(y, ys)</code> and <code>Cons(foo, bar)</code> have the same size.</li>
</ul>
<p>Using this knowledge, the compiler translates given code so that it reuses the memory region of <code>Cons(y, ys)</code>. More specifically, this <code>Cons</code> clause behaves as follows:</p>
<ol>
<li>Obtain <code>y</code> and <code>ys</code> from <code>Cons(y, ys)</code></li>
<li>Calculate <code>foo</code> and <code>bar</code></li>
<li>Store the calculated values to <code>Cons(y, ys)</code></li>
</ol>
<p>In other words, when a <code>free</code> is required, the compiler looks for a <code>malloc</code> in the continuation that is the same size and optimizes away such a pair if one exists. The resulting assembly code thus performs in-place updates.</p>
<h2 id="optimization-avoiding-unnecessary-copies"><a class="header" href="#optimization-avoiding-unnecessary-copies">Optimization: Avoiding Unnecessary Copies</a></h2>
<h3 id="observing-excessive-copies"><a class="header" href="#observing-excessive-copies">Observing Excessive Copies</a></h3>
<p>Suppose we've defined a function <code>length</code> as follows:</p>
<pre><code class="language-neut">define length(xs: list(int)): int {
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}
</code></pre>
<p>Now, consider the following code:</p>
<pre><code class="language-neut">define use-length(!xs: list(int)): unit {
  let len = length(!xs);
  some-function(len, !xs)
}
</code></pre>
<p>Note that the variable <code>!xs</code> is used twice. This means that the content of <code>!xs</code> is copied just to calculate its length. This is of course unfortunate. Worse, this kind of procedure isn't rare. We need some kind of loophole.</p>
<p>Luckily, Neut has a remedy for this kind of situation, as we'll see below.</p>
<h3 id="introducing-noema-types"><a class="header" href="#introducing-noema-types">Introducing Noema Types</a></h3>
<p>For any type <code>t</code>, Neut has a type <code>&amp;t</code>. We'll call this type the noema type of <code>t</code>. We'll call a term <code>e</code> a noema if the type of <code>e</code> is a noema type.</p>
<p>Unlike ordinary terms, a noema isn't discarded or copied even when used non-linearly. Also, Neut has primitives to read contents from noemata without consuming them. By utilizing these facts, we can avoid the disaster we have just seen.</p>
<p>Let's see how we can use noemata, rewriting <code>use-length</code> and <code>length</code>.</p>
<h3 id="creating-a-noema"><a class="header" href="#creating-a-noema">Creating a Noema</a></h3>
<p>We can create a noema using <code>on</code>:</p>
<pre><code class="language-neut">define use-length(xs: list(int)): unit {
  // xs: list(int)
  let len on xs =
    // xs: &amp;list(int)
    length(xs);
  // xs: list(int)
  some-function(len, xs)
}
</code></pre>
<p><code>on</code> takes a comma-separated list of variables. The variables in the list (<code>xs</code> in this example) are cast to noema types in the body of the <code>let</code>, and cast back to the original types in the continuation.</p>
<p>Conceptually, <code>on</code> can be seen as the following syntactic sugar:</p>
<pre><code class="language-neut">let v on x = e;
cont

// ↓ desugar

let x = unsafe-cast(a, &amp;a, x); // cast: `a` ~&gt; `&amp;a`
let v = e;                     // (use `&amp;a` in `e`)
let x = unsafe-cast(&amp;a, a, x); // uncast: `&amp;a` ~&gt; `a`
cont
</code></pre>
<p><code>on</code> has to satisfy certain condition. Consider the following code:</p>
<pre><code class="language-neut">// xs: list(int)
// ...
let ys on xs = xs;
let _ = xs; // (*)
cont
</code></pre>
<p>Since <code>xs</code> is discarded at <code>(*)</code>, using <code>ys</code> in <code>cont</code> should result in use-after-free. To prevent this kind of behavior, the compiler rejects code that might contain any noema in the result of <code>on</code>. In this case, since the type of <code>ys</code> is <code>&amp;list(int)</code>, the compiler rejects this code.</p>
<div class="info-block">
<p>This condition might initially appear a bit artificial. In the next section, however, we'll see that it can in fact be understood via modal logic.</p>
</div>
<h3 id="using-a-noema-pattern-matching"><a class="header" href="#using-a-noema-pattern-matching">Using a Noema: Pattern Matching</a></h3>
<p>If <code>t</code> is an ADT, you can view the content of a value <code>e: &amp;t</code> using <code>case</code>:</p>
<pre><code class="language-neut">define length(xs: &amp;list(int)): int {
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}
</code></pre>
<p><code>case</code> is similar to <code>match</code>. The difference is that, unlike <code>match</code>, <code>case</code> doesn't perform <code>free</code> on its arguments. You can think of <code>case</code> as a read-only version of <code>match</code>.</p>
<p>Also, note that the newly-bound variables in <code>case</code> are wrapped in <code>&amp;(_)</code>. In the code above, for example, the type of <code>ys</code> is not <code>list(int)</code>, but <code>&amp;list(int)</code>.</p>
<p>Now, we have new implementations of <code>length</code> and <code>use-length</code>:</p>
<pre><code class="language-neut">define length(xs: &amp;list(int)): int {
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}

define use-length(xs: list(int)): unit {
  let len on xs = length(xs);
  some-function(len, xs)
}
</code></pre>
<p>The code doesn't copy <code>xs</code> anymore, as you can see from the fact that it no longer contains <code>!</code>.</p>
<h3 id="using-a-noema-embodying"><a class="header" href="#using-a-noema-embodying">Using a Noema: Embodying</a></h3>
<p>Incidentally, you can create a value of type <code>a</code> from a value of type <code>&amp;a</code>, as follows:</p>
<pre><code class="language-neut">define make-pair&lt;a&gt;(x: &amp;a): pair(a, a) {
  Pair(*x, *x)
}
</code></pre>
<p>By writing <code>*e</code>, you can copy the content of the noema <code>e</code>, keeping the content intact.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modality-and-memory"><a class="header" href="#modality-and-memory">Modality and Memory</a></h1>
<p>Here, we'll see how to interact with the box modality <code>meta</code>, which enables borrowing in Neut. We'll then see that both <code>on</code> and <code>*e</code> can be understood as syntactic sugar over this modality.</p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ul>
<li><a href="modality-and-memory.html#layers-and-the-box-modality">Layers and the Box Modality</a></li>
<li><a href="modality-and-memory.html#more-tools-for-boxes">More Tools for Boxes</a></li>
<li><a href="modality-and-memory.html#desugaring-the-two-operations">Desugaring the Two Operations</a></li>
<li><a href="modality-and-memory.html#additional-notes">Additional Notes</a></li>
</ul>
<h2 id="layers-and-the-box-modality"><a class="header" href="#layers-and-the-box-modality">Layers and the Box Modality</a></h2>
<p>In Neut, each type <code>a</code> has a corresponding type <code>meta a</code>. This type provides a way to work with <em>layers</em>, which are similar to lifetimes in other languages.</p>
<p>Below, we’ll first introduce the concept of layers, and then see how to use <code>meta a</code>.</p>
<h3 id="layers-and-variables"><a class="header" href="#layers-and-variables">Layers and Variables</a></h3>
<p>Every term in Neut has an integer called layer. Conceptually, a layer can be seen as the level at which a piece of data lives.</p>
<p>The body of a <code>define</code> starts at layer 0:</p>
<pre><code class="language-neut">define foo(): () -&gt; unit {
  // here is layer 0
  function () {
    // here is also layer 0
    Unit
  }
}
</code></pre>
<p>A variable defined at layer n can only be used at the same layer. For example, the following code is invalid because the variable <code>x</code> is defined at layer 0 but used at layer 3:</p>
<pre><code class="language-neut">define bar(): unit {
  // here is layer 0
  let x = Unit; // ← `x` is defined at layer 0

  ... // ← some layer operations here

  // layer 3 (for example)
  let v2 =
    x; // ← Error: `x` is used at layer 3 (≠ 0)
  ...
}

</code></pre>
<p>Only modality-related operations can change layers, as we'll see below.</p>
<h3 id="creating-boxes"><a class="header" href="#creating-boxes">Creating Boxes</a></h3>
<p>To create a term of type <code>meta a</code>, use <code>box</code>:</p>
<pre><code class="language-neut">define use-box(x: &amp;int, y: &amp;bool, z: &amp;text): meta pair(int, bool) {
  // here is layer 0
  // free variables:
  // - x: &amp;int
  // - y: &amp;bool
  // - z: &amp;text
  box x, y {
    // here is layer -1 (== layer(outer) - 1)
    // free variables:
    // - x: int
    // - y: bool
    // - (z is unavailable here because of layer mismatch)
    Pair(x, y)
  }
}
</code></pre>
<p>Some notes on <code>box</code>:</p>
<ul>
<li>The type of <code>xi</code> in <code>box x1, ..., xn {e}</code> must be of the form <code>&amp;ai</code>.</li>
<li>Given <code>xi: &amp;ai</code>, the type of <code>xi</code> in the body of <code>box</code> is <code>ai</code>.</li>
</ul>
<p><code>box</code> behaves as follows:</p>
<pre><code class="language-neut">box x1, ..., xn { e }

↓ // (compile)

let x1 = COPY(a1, x1);
...
let xn = COPY(an, xn);
e
</code></pre>
<p>You can omit the sequence <code>x1, ..., xn</code> entirely if no variables need to be copied.</p>
<h3 id="using-boxes"><a class="header" href="#using-boxes">Using Boxes</a></h3>
<p>To use a term of type <code>meta a</code>, use <code>letbox</code>:</p>
<pre><code class="language-neut">define use-letbox(x: int, y: bool, z: text): int {
  // here is layer 0
  // free variables:
  // - x: int
  // - y: bool
  // - z: text
  letbox extracted-value = {
    // here is layer 1 (== layer(outer) + 1)
    // (x, y, and z are unavailable here because of layer mismatch)
    box {
      // here is layer 0
      // free variables:
      // - x: int
      // - y: bool
      // - z: text
      x
    }
  };
  // here is layer 0
  // free variables:
  // - x: int
  // - y: bool
  // - z: text
  extracted-value // == x
}

</code></pre>
<p>Operationally, <code>letbox</code> is the same as <code>let</code>:</p>
<pre><code class="language-neut">letbox v = e1;
e2

↓ // (compile)

let v  = e1;
e2
</code></pre>
<h2 id="more-tools-for-boxes"><a class="header" href="#more-tools-for-boxes">More Tools for Boxes</a></h2>
<h3 id="using-boxes-without-changing-the-current-layer"><a class="header" href="#using-boxes-without-changing-the-current-layer">Using Boxes Without Changing the Current Layer</a></h3>
<p>Sometimes you want to use a term of type <code>meta a</code> without shifting your current layer. For this, Neut provides <code>letbox-T</code>, which keeps you in the same layer:</p>
<pre><code class="language-neut">define use-letbox-T(x: int, y: bool): int {
  // here is layer 0
  letbox-T value on x, y = {
    // here is layer 0 (== layer(outer))
    box {42}
  };
  // here is layer 0
  value // == 42
}
</code></pre>
<p><code>letbox-T</code> can be used for example to write functions of type <code>(meta a) -&gt; a</code> as follows:</p>
<pre><code class="language-neut">define axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T tmp = x;
  tmp
}
</code></pre>
<p>If you tried to use <code>letbox</code> instead, you’d get an error because it would result in layer mismatch.</p>
<h3 id="a-shortcut-for-creating-boxes"><a class="header" href="#a-shortcut-for-creating-boxes">A Shortcut for Creating Boxes</a></h3>
<p>We can, for example, construct a <code>meta bool</code> from a <code>bool</code> as follows:</p>
<pre><code class="language-neut">define box-bool(b: bool): meta bool {
  match b {
  | True  =&gt; box {True}
  | False =&gt; box {False}
  }
}
</code></pre>
<p>To streamline this kind of mechanical step, Neut provides <code>quote</code>:</p>
<pre><code class="language-neut">define box-bool(b: bool): meta bool {
  quote {b} // `quote` casts `bool` into `meta bool`
}
</code></pre>
<p>Not all types can be cast using <code>quote</code>. Specifically, it can't be used on any type that contains:</p>
<ul>
<li>a type of the form <code>&amp;a</code></li>
<li>a type of the form <code>(a1, ..., an) -&gt; b</code></li>
<li>a type variable</li>
</ul>
<p>If you can get <code>meta t</code> by quoting <code>e: t</code>, you can get the same type using <code>box</code> instead. In this sense, <code>quote</code> is a shortcut for creating boxes.</p>
<h2 id="desugaring-the-two-operations"><a class="header" href="#desugaring-the-two-operations">Desugaring the Two Operations</a></h2>
<p>We've seen the two constructs <code>let-on</code> and <code>*e</code>. Though they might have initially appeared a bit artificial, they are in fact straightforward applications of the box modality.</p>
<h3 id="desugar-borrowing"><a class="header" href="#desugar-borrowing">Desugar: Borrowing</a></h3>
<p>We can now desugar <code>let-on</code> as follows:</p>
<pre><code class="language-neut">let x on y, z = e1;
e2

↓ // desugar

letbox-T x on y, z = quote {e1};
e2
</code></pre>
<p>This explains why the result type of a <code>let-on</code> had to be restricted to some extent: the restriction is from <code>quote</code>.</p>
<h3 id="desugar-embodying"><a class="header" href="#desugar-embodying">Desugar: Embodying</a></h3>
<p>Using the <code>axiom-T</code> we defined above, we can also desugar <code>*e</code> as follows:</p>
<pre><code class="language-neut">*e

↓ // desugar

let x = e;
axiom-T(box x {x})
</code></pre>
<h2 id="additional-notes"><a class="header" href="#additional-notes">Additional Notes</a></h2>
<h3 id="layers-and-free-variables"><a class="header" href="#layers-and-free-variables">Layers and Free Variables</a></h3>
<p>There's one last rule that must be satisfied for memory safety. That is, if a function is defined at layer <code>n</code>, then any free variable <code>x</code> in the function must satisfy <code>layer(x) &lt;= n</code>.</p>
<p>Without this rule, you could do something like the following:</p>
<pre><code class="language-neut">define joker(): () -&gt; unit {
  // layer 0
  let xs: list(int) = List[1, 2, 3];
  letbox-T f on xs = {
    // layer 0
    box {
      // layer -1
      function () { // ★
        letbox k = {
          // layer 0
          let len = length(xs);
          box {Unit}
        };
        Unit
      }
    }
  };
  f // function with xs: &amp;list(int) as a free variable
  // FREE(xs)
}

define main(): unit {
  let f = joker();
  f(); // xs used after freed here
}
</code></pre>
<p>This example would wrongly allow a function at layer 0 (<code>★</code>) to keep a reference to data (<code>xs</code>) that, after the outer <code>letbox</code> completes, could be deallocated, leading to a use-after-free scenario in the body of the main function. Hence, Neut’s layer rules prohibit capturing a higher-layer variable in a lower-layer function.</p>
<h3 id="using-meta"><a class="header" href="#using-meta">Using <code>meta</code></a></h3>
<p>The following function parses data and stores backups of said data.</p>
<pre><code class="language-neut">define backup-parse&lt;a&gt;(transformer: (binary) -&gt; a): a {
  let !input: binary = get-next-input();
  write-to-file(input-backup, bin-to-hex(!input)); // !input copied
  transformer(!input)
}
</code></pre>
<p>This function might get slow if huge chunks of data are processed due to the copy. Rewriting it to use noetic values could look like the following:</p>
<pre><code class="language-neut">define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input)); // bin-to-hex takes a &amp;binary now, avoiding the copy
    transformer(binary)
  };
  result
}
</code></pre>
<p>This won't compile because <code>transformer</code> contains a free variable <code>a</code>. This works as a safety guard, it compiled the following scenario would be possible:</p>
<pre><code class="language-neut">define id-bin(arg: &amp;binary): &amp;binary {
  arg
}

define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}

define zen(): unit {
  let joker = backup-parse(id-bin);
  write-to-file(somefile, bin-to-hex(joker));
  Unit
}
</code></pre>
<p>The following happens inside <code>zen</code>:</p>
<ol>
<li><code>backup-parse(id-bin)</code> evaluates to a reference to (the freed) <code>input</code></li>
<li><code>joker</code> holds the (dangling) reference</li>
<li><code>bin-to-hex</code> takes <code>joker</code> as an argument, causing an use-after-free</li>
</ol>
<p>To fancy the requirements of the type system <code>meta</code> must be used as follows.</p>
<pre><code class="language-neut">define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; meta a): a {
  let input: binary = get-next-input();
  letbox-T result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}
</code></pre>
<p>The <code>meta</code> specifier asserts that the value a call to <code>transformer</code> evaluates will be valid on the outer layer (in this case the layer of <code>zen</code>, since it's where <code>backup-parse</code> has been called). The requirements of the operators that lift values into <code>meta</code> guarantee that this is the case. In order to make the previous example work, <code>id-bin</code> could look like the following:</p>
<pre><code class="language-neut">define id-bin(arg: &amp;binary): meta binary {
  box arg { // *arg copied
    arg
  }
}

define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}

define zen(): unit {
  let joker = backup-parse(id-bin);
  let _ on joker = write-to-file(somefile, bin-to-hex(joker));
  Unit
}
</code></pre>
<p>Lastly, to avoid the newly introduced copy, the following refactor is possible:</p>
<pre><code class="language-neut">define write-to-somefile(arg: &amp;binary): meta unit { // used to be id-bin
  write-to-file(somefile, bin-to-hex(arg));
  box {Unit}
}

define backup-parse&lt;a&gt;(transformer: (&amp;binary) -&gt; a): a {
  let input: binary = get-next-input();
  let result on binary = {
    write-to-file(input-backup, bin-to-hex(input));
    transformer(binary)
  };
  result
  // FREE(input)
}

define zen(): unit {
  backup-parse(write-to-somefile)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-reference"><a class="header" href="#language-reference">Language Reference</a></h1>
<p>In this chapter, you should be able to find all the details of Neut.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The command <code>neut</code> has subcommands like <code>neut build</code>, <code>neut get</code>, etc. This section describes those subcommands.</p>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="commands.html#common-notes">Common Notes</a></li>
<li><a href="commands.html#neut-build">neut build</a></li>
<li><a href="commands.html#neut-check">neut check</a></li>
<li><a href="commands.html#neut-clean">neut clean</a></li>
<li><a href="commands.html#neut-archive">neut archive</a></li>
<li><a href="commands.html#neut-create">neut create</a></li>
<li><a href="commands.html#neut-get">neut get</a></li>
<li><a href="commands.html#neut-format-source">neut format-source</a></li>
<li><a href="commands.html#neut-format-ens">neut format-ens</a></li>
<li><a href="commands.html#neut-zen">neut zen</a></li>
<li><a href="commands.html#neut-lsp">neut lsp</a></li>
<li><a href="commands.html#neut-version">neut version</a></li>
</ul>
<h2 id="common-notes"><a class="header" href="#common-notes">Common Notes</a></h2>
<h3 id="subcommands-and-modules"><a class="header" href="#subcommands-and-modules">Subcommands and Modules</a></h3>
<p>Most of the subcommands of <code>neut</code> must be executed inside a module. If you execute such a subcommand outside a module, the command will emit an error like the one below:</p>
<pre><code class="language-sh">neut build foo
#=&gt; Error: Couldn't find a module file (Context: /Users/foo/Desktop)
</code></pre>
<p>Only the following subcommands can be used outside a module:</p>
<ul>
<li><code>neut create</code></li>
<li><code>neut version</code></li>
</ul>
<h3 id="shared-command-line-options"><a class="header" href="#shared-command-line-options">Shared command line options:</a></h3>
<p>Some subcommands share command line options. The list of them is as follows:</p>
<ul>
<li><code>--no-color</code> can be used to turn off ANSI colors</li>
</ul>
<h2 id="neut-build"><a class="header" href="#neut-build"><code>neut build</code></a></h2>
<p><code>neut build</code> builds the current module and creates executables. It also creates cache files of the source files for faster compilation.</p>
<p><code>neut build TARGET</code> builds the target <code>TARGET</code> defined in <code>module.ens</code>. For example, suppose that the <code>module.ens</code> of a module contains the following section:</p>
<pre><code class="language-ens">{
  // ..
  target {
    foo {
      main &quot;foo.nt&quot;,
    },
    bar {
      main &quot;item/bar.nt&quot;,
    },
  },
  // ..
}
</code></pre>
<p>In this case, running <code>neut build foo</code> creates the executable <code>foo</code> by building the current module, using the <code>main</code> in <code>foo.nt</code> as the entry point.</p>
<p>The resulting binaries are put inside the module's build directory. You might want to use the option <code>--install</code> to copy those binaries.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-sh"># creates a sample project
neut create hello
cd hello

# build and run
neut build hello --execute # =&gt; &quot;Hello, world!&quot;

# build the module, copy the resulting binary, and execute the binary
neut build hello --install ./bin
./bin/hello #=&gt; &quot;Hello, world!&quot;
</code></pre>
<h3 id="--execute"><a class="header" href="#--execute"><code>--execute</code></a></h3>
<p>If you pass <code>--execute</code> to <code>neut build</code>, the resulting binaries are executed after the build.</p>
<h3 id="--install-dir"><a class="header" href="#--install-dir"><code>--install DIR</code></a></h3>
<p>If you pass <code>--install DIR</code> to <code>neut build</code>, the resulting binaries are copied to the specified directory.</p>
<h3 id="--skip-link"><a class="header" href="#--skip-link"><code>--skip-link</code></a></h3>
<p>By default, <code>neut build</code> builds all the source files into object files and then links them all to create an executable. You can pass <code>--skip-link</code> to <code>neut build</code> to skip the last linking phase.</p>
<h3 id="--emit"><a class="header" href="#--emit"><code>--emit</code></a></h3>
<p>You can emit LLVM IR by passing <code>--emit llvm</code> to <code>neut build</code>. In this case, you must also pass <code>--skip-link</code>.</p>
<h3 id="--mode"><a class="header" href="#--mode"><code>--mode</code></a></h3>
<p>You can pass <code>--mode {develop,release}</code> like the below:</p>
<pre><code class="language-sh">neut build my-app --mode release
</code></pre>
<p>If you don't specify <code>--mode</code>, the mode defaults to <code>develop</code>.</p>
<p>The value passed here can be obtained from source files by using <code>introspect</code>:</p>
<pre><code class="language-neut">define foo(): unit {
  introspect build-mode {
  | release =&gt;
    // ..
  | develop =&gt;
    // ..
  }
}
</code></pre>
<h2 id="neut-check"><a class="header" href="#neut-check"><code>neut check</code></a></h2>
<p><code>neut check</code> type-checks all the files in the current module. It also creates cache files of the source files for faster compilation.</p>
<h2 id="neut-clean"><a class="header" href="#neut-clean"><code>neut clean</code></a></h2>
<p><code>neut clean</code> removes the cache files in the current module's <code>cache</code> directory.</p>
<p>More specifically, this command removes the following directory in the current module:</p>
<pre><code class="language-text">(cache-directory)/build/(platform)/(compiler-version)/
</code></pre>
<p>An example of a removed directory:</p>
<pre><code class="language-text">cache/build/arm64-darwin/compiler-0.8.0/
</code></pre>
<h2 id="neut-archive"><a class="header" href="#neut-archive"><code>neut archive</code></a></h2>
<p><code>neut archive VERSION</code> creates a module tarball that can be used by <code>neut get</code>.</p>
<h3 id="notes-on-versions"><a class="header" href="#notes-on-versions">Notes on Versions</a></h3>
<p><code>VERSION</code> must be <code>X1-X2-..-Xn</code>, where all the integers are non-negative. For example, the following are valid versions:</p>
<ul>
<li><code>1-0</code></li>
<li><code>0-1-0</code></li>
<li><code>2-1-3</code></li>
<li><code>0-0-0-3</code></li>
</ul>
<p>When running <code>neut archive VERSION</code>, this command searches the archive directory to get all the compatible older versions. For example, suppose the archive directory contains the following files:</p>
<ul>
<li><code>1-0.tar.zst</code></li>
<li><code>1-1.tar.zst</code></li>
<li><code>2-0.tar.zst</code></li>
<li><code>2-1.tar.zst</code></li>
</ul>
<p>In this case, the command <code>neut archive 2-2</code> searches the <code>archive</code> directory and gets <code>2-0</code> and <code>2-1</code> as the older compatible versions of <code>2-2</code>. Here, these &quot;older&quot; versions are determined according to <a href="https://semver.org/">Semantic Versioning</a>.</p>
<p>This command then does the following:</p>
<ol>
<li>Computes all the digests of these older compatible tarballs</li>
<li>Creates a new <code>module.ens</code> that contains the list of the older digests</li>
<li>Packs the ens file and the other required files to create a tarball <code>2-2.tar.zst</code></li>
</ol>
<p>This digest information inside <code>module.ens</code> of <code>2-2.tar.zst</code> should appear like the below:</p>
<pre><code class="language-ens">{
  target {..},
  dependency {..},
  antecedent [
    &quot;Bp8RulJ-XGTL9Eovre0yQupJpeS3lGNk8Q6QQYua7ag&quot;, // ← digest of 2-0.tar.zst
    &quot;zptXghmyD5druBl8kx2Qrei6O6fDsKCA7z2KoHp1aqA&quot;, // ← digest of 2-1.tar.zst
  ],
}
</code></pre>
<p>This information is then used when resolving dependencies.</p>
<p>You can extract a resulting tarball to see that <code>antecedent</code> information is indeed there.</p>
<div class="info-block">
<p>The <code>module.ens</code> in your module isn't modified by <code>archive</code>. This subcommand creates a new <code>module.ens</code> and puts it into the tarball.</p>
</div>
<h3 id="using-the-newest-compatible-version"><a class="header" href="#using-the-newest-compatible-version">Using the Newest Compatible Version</a></h3>
<p>Consider the following dependency relation:</p>
<ul>
<li>Module <code>A</code> depends on <code>B</code> and <code>C</code>.</li>
<li>Module <code>B</code> depends on <code>D (version 1.1)</code>.</li>
<li>Module <code>C</code> depends on <code>D (version 1.2)</code>.</li>
</ul>
<pre><code class="language-text">A ──&gt; B ──&gt; D (1.1)
│
└───&gt; C ──&gt; D (1.2)
</code></pre>
<p>Thanks to the <code>antecedent</code> information inside <code>D (1.2)</code>, the compiler can detect that <code>D (1.2)</code> is a newer compatible module of <code>D (1.1)</code>. The compiler utilizes this knowledge to rewrite the above relation into:</p>
<pre><code class="language-text">A ──&gt; B ──┐
│         │
└───&gt; C ──┴──&gt; D (1.2)
</code></pre>
<p>The compiler always uses the newest compatible modules in the dependency relation by this procedure.</p>
<div class="info-block">
<p>This rewriting won't work if the minor &quot;compatible&quot; version <code>D (1.2)</code> isn't compatible with <code>D (1.1)</code>. This incompatibility is a bug of the library <code>D (1.2)</code> and should be fixed by the module author.</p>
</div>
<h3 id="utilizing-the-compatibility-relation"><a class="header" href="#utilizing-the-compatibility-relation">Utilizing the Compatibility Relation</a></h3>
<p>As an exercise, suppose the following:</p>
<ol>
<li>Serious bugs were discovered in <code>D (1.1)</code> and <code>D (1.2)</code></li>
<li>The grave-look author of <code>D</code> released a bug-fix release <code>D (1.3)</code> in a hurry</li>
<li>The happy authors of <code>B</code> and <code>C</code> are on a honeymoon vacation in Hawaii</li>
</ol>
<p>In this case, we don't have to wait for the authors of <code>B</code> and <code>C</code> to update their dependencies. Instead, we can just add <code>D (1.3)</code> to our module's dependency:</p>
<pre><code class="language-text">A ──&gt; B ──┐
│         │
├───&gt; C ──┴──&gt; D (1.2)
│
└────────────&gt; D (1.3)
</code></pre>
<p>Then, the compiler automatically rewrites the above relation into:</p>
<pre><code class="language-text">A ──&gt; B ───┐
│          │
├───&gt; C ───┤
│          │
└──────────┴──&gt; D (1.3)
</code></pre>
<p>So we don't have to rain on their happy parade in Waikiki Beach.</p>
<h2 id="neut-create"><a class="header" href="#neut-create"><code>neut create</code></a></h2>
<p><code>neut create NAME</code> creates a directory <code>./NAME/</code> and adds files there to start a new project.</p>
<h2 id="neut-get"><a class="header" href="#neut-get"><code>neut get</code></a></h2>
<p><code>neut get ALIAS URL</code> fetches and builds external modules specified by <code>URL</code> and adds it to the current module as a dependency under the name <code>ALIAS</code>.</p>
<pre><code class="language-sh">neut get some-name https://github.com/USER_NAME/REPO_NAME/raw/main/archive/0-1.tar.zst
</code></pre>
<p>Here, the <code>URL</code> must be the URL of an archive that was created by <code>neut archive</code>.</p>
<p>After executing <code>neut get</code>, the information of the new module is saved to <code>module.ens</code>:</p>
<pre><code class="language-ens">{
  target {
    // ..
  },
  dependency {
    // ..
    // 🌟 (something like this is added automatically)
    some-name {
      digest &quot;xNmQu6It81lGBy1sKvk5_jE4Qt8w8KgkVgGj0RBbbrk&quot;,
      mirror [
        &quot;https://github.com/USER_NAME/REPO_NAME/raw/main/archive/0-1.tar.zst&quot;,
      ],
    },
    // ..
  },
}
</code></pre>
<p>The <code>digest</code> is the base64url-encoded checksum of the tarball.</p>
<p>The <code>mirror</code> is a list of URLs that can be used to obtain the tarball.</p>
<div class="info-block">
<p>Modules in Neut are distinguished by their digests (checksums).</p>
</div>
<p><code>neut get</code> can be used to &quot;update&quot; dependencies. Suppose you specify an existing <code>ALIAS</code> when running <code>neut get ALIAS URL</code>. In this case, if the digest of the new tarball isn't the same as the existing one, the existing dependency in the ens file is replaced by the newer one. If the digest is the same as the existing one, the <code>URL</code> is added to the list <code>mirror</code>.</p>
<p>You can remove a dependency in the ens file to &quot;remove&quot; the module from your module.</p>
<p>You can import dependencies from source files. See the notes on <code>import</code> in <a href="./statements.html#import">Statements</a> for information on how to use definitions in external dependencies.</p>
<h2 id="neut-format-source"><a class="header" href="#neut-format-source"><code>neut format-source</code></a></h2>
<p><code>neut format-source path/to/source/file.nt</code> formats the specified source file and outputs the result to stdout.</p>
<h3 id="--in-place"><a class="header" href="#--in-place"><code>--in-place</code></a></h3>
<p>When the option <code>--in-place</code> is set, <code>format-source</code> performs in-place update.</p>
<h3 id="--minimize-imports"><a class="header" href="#--minimize-imports"><code>--minimize-imports</code></a></h3>
<p>When the option <code>--minimize-imports</code> is set, <code>format-source</code> removes all the unused items in <code>import {..}</code>.</p>
<h2 id="neut-format-ens"><a class="header" href="#neut-format-ens"><code>neut format-ens</code></a></h2>
<p><code>neut format-ens path/to/source/file.ens</code> formats the specified ens file and outputs the result to stdout.</p>
<h3 id="--in-place-1"><a class="header" href="#--in-place-1"><code>--in-place</code></a></h3>
<p>When the option <code>--in-place</code> is set, <code>format-ens</code> performs in-place update.</p>
<h2 id="neut-zen"><a class="header" href="#neut-zen"><code>neut zen</code></a></h2>
<p><code>neut zen path/to/source/file.nt</code> builds and executes specified file as if it were an entry point.</p>
<p>The subcommand <code>zen</code> treats the function <code>zen</code> inside the given file as its entry point (that is, <code>main</code>).</p>
<p>Thus, the type of the function <code>zen</code> must be <code>() -&gt; unit</code>:</p>
<pre><code class="language-neut">define zen(): unit {
  print(&quot;hello, world!\n&quot;);
}
</code></pre>
<p>This command is intended to be used for rapid prototyping.</p>
<p>Please see <a href="./rapid-prototyping.html">Rapid Prototyping</a> to see <code>neut zen</code> in action.</p>
<h3 id="zen-experience"><a class="header" href="#zen-experience">Zen Experience</a></h3>
<p>Suppose that you created a new function deep inside your module.</p>
<p>You can technically create a test function for the function and check its behavior. Or modify the main function to call the new function just to see its behavior.</p>
<p>It might be, however, a bit cumbersome. We'd love to achieve rapid try-and-error cycles in certain circumstances.</p>
<p>You can use the command <code>zen</code> here. Suppose that a file <code>some-file.nt</code> contains a function <code>foo</code> that is defined as in the below:</p>
<pre><code class="language-neut">define foo(x: int): int {
  do-complex-calculation(x)
}
</code></pre>
<p>The behavior of <code>foo</code> can be inspected rapidly by defining a function named <code>zen</code> in the file:</p>
<pre><code class="language-neut">define zen(): unit {
  print-int(foo(10));
}
</code></pre>
<p>Then, execute the following command:</p>
<pre><code class="language-sh">neut zen path/to/some-file.nt # =&gt; (the result of `foo(10)` is printed)
</code></pre>
<p>This can be done even if <code>some-file.nt</code> isn't an entrypoint of the module. You can think of functions named <code>zen</code> as alternative <code>main</code>s.</p>
<h2 id="neut-lsp"><a class="header" href="#neut-lsp"><code>neut lsp</code></a></h2>
<p><code>neut lsp</code> starts the LSP server. The LSP server has features like linting, jump to definition, etc. More specifically, the LSP server supports the following LSP capabilities:</p>
<ul>
<li><code>textDocument/didOpen</code> (lint on open)</li>
<li><code>textDocument/didSave</code> (lint on save)</li>
<li><code>textDocument/completion</code> (complete)</li>
<li><code>textDocument/definition</code> (jump to definition)</li>
<li><code>textDocument/documentHighlight</code> (highlight symbols)</li>
<li><code>textDocument/references</code> (find references)</li>
<li><code>textDocument/formatting</code> (format)</li>
<li><code>textDocument/hover</code> (show the type of a symbol)</li>
</ul>
<p>For more information, please see <a href="./lovely-lsp-showcase.html">Lovely LSP Showcase</a> and <a href="./editor-setup.html">Editor Setup</a>.</p>
<h2 id="neut-version"><a class="header" href="#neut-version"><code>neut version</code></a></h2>
<p><code>neut version</code> prints the version of the compiler.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-sh">neut version
#=&gt; X.Y.Z
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>A directory (including all its children) is a <em>module</em> if it contains a file named <code>module.ens</code>.</p>
<p>Below is the list of configurations of <code>module.ens</code>.</p>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ul>
<li><a href="modules.html#target">target</a></li>
<li><a href="modules.html#dependency">dependency</a></li>
<li><a href="modules.html#archive">archive</a></li>
<li><a href="modules.html#cache">cache</a></li>
<li><a href="modules.html#source">source</a></li>
<li><a href="modules.html#foreign">foreign</a></li>
<li><a href="modules.html#static">static</a></li>
<li><a href="modules.html#preset">preset</a></li>
<li><a href="modules.html#inline-limit">inline-limit</a></li>
<li><a href="modules.html#antecedent">antecedent</a></li>
</ul>
<h2 id="target"><a class="header" href="#target"><code>target</code></a></h2>
<p>The field <code>target</code> defines the entry points of a module. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  target {
    TARGET-1 {
      main &quot;path/to/source/file-1.nt&quot;
    },
    // ..
    TARGET-N {
      main &quot;path/to/source/file-n.nt&quot;
    },
  },
  // ..
}
</code></pre>
<p>Suppose that your module has the following <code>target</code> in <code>module.ens</code>:</p>
<pre><code class="language-ens">{
  // ..
  target {
    foo {
      main &quot;foo.nt&quot;,
    },
    bar {
      main &quot;item/yo.nt&quot;
    },
  },
  // ..
}
</code></pre>
<p>In this case, your module has two targets: <code>foo</code> and <code>bar</code>. The entry point of <code>foo</code> is the <code>main</code> function in <code>(source-dir)/foo.nt</code>. The entry point of <code>bar</code> is the <code>main</code> function in <code>(source-dir)/item/yo.nt</code>.</p>
<p>The names in <code>target</code> can be specified when running <code>neut build</code>. For example, given the above definition of <code>target</code>, you can run <code>neut build foo</code>.</p>
<p>The names of targets are also used as the names of executables. For example, if you run <code>neut build foo --install ./bin/</code>, an executable named <code>foo</code> will be created under the directory <code>./bin/</code>.</p>
<p>The field <code>target</code> is optional. The default value of <code>target</code> is <code>{}</code>.</p>
<h3 id="compile-option"><a class="header" href="#compile-option"><code>compile-option</code></a></h3>
<p>You can add <code>compile-option</code> to a target as follows:</p>
<pre><code class="language-ens">{
  target {
    foo {
      main &quot;foo.nt&quot;,
      // ↓ here
      compile-option [
        &quot;-g&quot;,
        &quot;-O0&quot;,
        &quot;-fsanitize=address&quot;,
        &quot;$SOME_ENV_VAR&quot;,
        &quot;$(some-command arg)&quot;,
      ],
    },
  },
}
</code></pre>
<p>The compiler passes the options specified here to <code>clang</code> when compiling LLVM IRs into object files.</p>
<p>In <code>compile-option</code>, you can use environment variables and shell interpolations.</p>
<p>The field <code>compile-option</code> is optional. The default value of <code>compile-option</code> is <code>[]</code>.</p>
<h3 id="link-option"><a class="header" href="#link-option"><code>link-option</code></a></h3>
<p>You can add <code>link-option</code> to a target as follows:</p>
<pre><code class="language-ens">{
  target {
    foo {
      main &quot;foo.nt&quot;,
      // ↓ here
      link-option [
        &quot;-g&quot;,
        &quot;-O0&quot;,
        &quot;$SOME_ENV_VAR&quot;,
        &quot;$(some-command)&quot;,
      ],
    },
  },
}
</code></pre>
<p>The compiler passes the options specified here to <code>clang</code> when linking object files.</p>
<p>In <code>link-option</code>, you can use environment variables and shell interpolations.</p>
<p>The field <code>link-option</code> is optional. The default value of <code>link-option</code> is <code>[]</code>.</p>
<h3 id="build-option"><a class="header" href="#build-option"><code>build-option</code></a></h3>
<p>You can add <code>build-option</code> to a target as follows:</p>
<pre><code class="language-ens">{
  target {
    foo {
      main &quot;foo.nt&quot;,
      // ↓ here
      build-option [
        &quot;$(pkg-config openssl --libs --cflags)&quot;,
        // ...
      ],
    },
  },
}
</code></pre>
<p>Adding an element to <code>build-option</code> is the same as adding the element to both <code>compile-option</code> and <code>link-option</code>.</p>
<p>In <code>build-option</code>, you can use environment variables and shell interpolations.</p>
<p>The field <code>build-option</code> is optional. The default value of <code>build-option</code> is <code>[]</code>.</p>
<h2 id="dependency"><a class="header" href="#dependency"><code>dependency</code></a></h2>
<p>The field <code>dependency</code> defines the dependencies of a module. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  dependency {
    foo {
      digest &quot;(base64url-encoded sha256 checksum)&quot;,
      mirror [
        &quot;URL-1&quot;,
        // ..
        &quot;URL-N&quot;,
      ],
      enable-preset &lt;true | false&gt;, // ← optional field
    },
    // ..
    bar { .. },
  },
  // ..
}
</code></pre>
<p>An example of <code>dependency</code>:</p>
<pre><code class="language-ens">{
  // ..
  dependency {
    core {
      digest &quot;ub3MUXVac9F1rebIhl_Crm2_GJ7PzCAekgp8aYH3-mo&quot;,
      mirror [
        &quot;https://github.com/vekatze/neut-core/raw/main/archive/0-38.tar.zst&quot;,
      ],
      enable-preset true,
    },
    some-package {
      digest &quot;F_ST8PtL9dLCDWVZ4GpuS7sviUU0_-TUz2s6iw-86KU&quot;,
      mirror [
        &quot;https://example.com/foobarbuz/packages/22-3.tar.zst&quot;,
      ],
    },
  },
    // ..
}
</code></pre>
<p>The field <code>digest</code> specifies the checksum of the tarball of the dependency. The digest is a Base64URL-encoded SHA256 checksum of the tarball. This digest is the &quot;real&quot; name of this dependency, and used as an identifier.</p>
<p>The field <code>mirror</code> specifies a list of URLs from which the compiler can fetch the tarball. When running <code>neut get</code>, the compiler will try to get the tarball if necessary, using this list from the beginning to the end.</p>
<p>The optional field <code>enable-preset</code> specifies whether to import <code>preset</code>s automatically, as in &quot;prelude&quot; in other languages. This field should only be used (and set to be true) with the core library. For more information, see the explanation of <code>preset</code> in this section.</p>
<p>The field <code>dependency</code> is optional. The default value of <code>dependency</code> is <code>{}</code>.</p>
<h2 id="archive"><a class="header" href="#archive"><code>archive</code></a></h2>
<p>The field <code>archive</code> defines the path of the directory into which the subcommand <code>neut archive</code> stores tarballs. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  archive &quot;my-archive&quot;,
  // ..
}
</code></pre>
<p>The field <code>archive</code> is optional. The default value of <code>archive</code> is <code>./archive/</code>.</p>
<h2 id="cache"><a class="header" href="#cache"><code>cache</code></a></h2>
<p>The field <code>cache</code> defines the path of the directory in which to store object files, executables, dependencies, etc. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  cache &quot;.cache&quot;,
  // ..
}
</code></pre>
<p>The field <code>cache</code> is optional. The default value of <code>cache</code> is <code>./cache/</code>.</p>
<h2 id="source"><a class="header" href="#source"><code>source</code></a></h2>
<p>The field <code>source</code> defines the path of the directory to store source files. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  source &quot;.&quot;,
  // ..
}
</code></pre>
<p>The field <code>source</code> is optional. The default value of <code>source</code> is <code>./source/</code>.</p>
<h2 id="foreign"><a class="header" href="#foreign"><code>foreign</code></a></h2>
<p>The field <code>foreign</code> defines a way to compile external source files. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  foreign {
    input [
      &quot;source/foo.c&quot;,
      &quot;source/bar.c&quot;,
    ],
    output [
      &quot;foo.o&quot;,
      &quot;bar.o&quot;
    ],
    script [
      &quot;{{clang}} -c -flto=thin -O2 source/foo.c -o {{foreign}}/foo.o&quot;,
      &quot;{{clang}} -c -flto=thin -O2 source/bar.c -o {{foreign}}/bar.o&quot;,
    ]
  }
}
</code></pre>
<h3 id="input"><a class="header" href="#input"><code>input</code></a></h3>
<p>The field <code>input</code> specifies the list of external source files. The paths are relative to the root of the module.</p>
<p>When running <code>neut archive</code>, the compiler adds all the <code>input</code> files to the resulting tarballs.</p>
<h3 id="output"><a class="header" href="#output"><code>output</code></a></h3>
<p>The field <code>output</code> specifies the resulting files of foreign source files. The paths are relative to a directory named <em>foreign directory</em>. You can find a foreign directory in the build directory.</p>
<p>When running <code>neut build</code>, the compiler links all the <code>output</code> files in the foreign directory (in addition to Neut's &quot;domestic&quot; object files).</p>
<h3 id="script"><a class="header" href="#script"><code>script</code></a></h3>
<p>The field <code>script</code> specifies how to compile external source files. When running <code>neut build</code>, the compiler executes the specified commands immediately after resolving all the <code>import</code>s.</p>
<p>In the field <code>script</code>, you can use the following placeholders:</p>
<ul>
<li><code>{{clang}}</code>: The <code>clang</code> used by the compiler</li>
<li><code>{{foreign}}</code>: The foreign directory</li>
</ul>
<p>The compiler skips running the <code>script</code> if all the files in <code>output</code> are newer than <code>input</code>.</p>
<p>When running the <code>script</code>, the compiler sets the current working directory to the module's root directory.</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<p>The field <code>foreign</code> is optional. The default value of <code>foreign</code> is:</p>
<pre><code class="language-ens">{
  input [],
  output [],
  script [],
}
</code></pre>
<p>An example of <code>foreign</code> can be found in the <a href="https://github.com/vekatze/neut-core/blob/0570cd5aa17914bef7021b7e88ca1fa421af721e/module.ens#L10">core library</a>.</p>
<div class="info-block">
<p>The compiler links the resulting foreign object files without any name mangling. You're strongly encouraged to prefix names in your foreign sources with your module name and the major version to avoid name collision. You can find an example of prefixed names <a href="https://github.com/vekatze/neut-core/blob/0570cd5aa17914bef7021b7e88ca1fa421af721e/source/foreign.c">here</a>.</p>
</div>
<h2 id="static"><a class="header" href="#static"><code>static</code></a></h2>
<p>The field <code>static</code> defines the list of static files that can be embedded into source files at compile time. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  static {
    some-file &quot;relative/path/from/the/module/root/to/some-file.txt&quot;,
    other-file &quot;relative/path/from/the/module/root/to/other-file.txt&quot;,
  },
  // ..
}
</code></pre>
<p>You can use the keys defined here in source files using <code>import</code> and <code>include-text</code>:</p>
<pre><code class="language-neut">// foo.nt

import {
  // ..
  static {some-file, other-file}
  // ..
}

define use-some-file(): unit {
  let t1: &amp;text = include-text(some-file);
  let t2: &amp;text = include-text(other-file);
  print(t1);
  print(t2)
}
</code></pre>
<p>After specifying a key of a static source file in <code>import</code>, you can use it in <code>include-text</code> to embed the file's content to the source file at compile time. Here, <code>include-text</code> assumes that the encoding of the static file is UTF-8.</p>
<p>The compiler triggers recompilation when necessary by comparing the modification times of static resources and source files. In the code above, for example, the compiler recompiles <code>foo.nt</code> if you modify the content of <code>some-file.txt</code>.</p>
<p>The field <code>static</code> is optional. The default value of <code>static</code> is <code>{}</code>.</p>
<h2 id="preset"><a class="header" href="#preset"><code>preset</code></a></h2>
<p>The field <code>preset</code> defines the list of names that must be imported implicitly when the module is used as a dependency. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  preset {
    foo [&quot;my-func&quot;, &quot;other-func&quot;],
    item.bar [&quot;hoge&quot;, &quot;pohe&quot;],
  },
  // ..
}
</code></pre>
<p>In the example above, the current module is expected to have the following files:</p>
<ul>
<li><code>(source-dir)/foo.nt</code> that contains the definitions of <code>my-func</code> and <code>other-func</code></li>
<li><code>(source-dir)/item/bar.nt</code> that contains the definitions of <code>hoge</code> and <code>pohe</code></li>
</ul>
<p>The field <code>preset</code> is used in combination with <code>enable-preset</code> in <code>dependency</code>.</p>
<p>Suppose we released a module that contains the definition of <code>preset</code> as in the above. Also, suppose someone is developing a module <code>MMM</code> and they added our module to <code>MMM</code>'s dependency:</p>
<pre><code class="language-ens">// module.ens in MMM

{
  // ..
  dependency {
    sample {
      digest &quot;BASE64_URL_ENCODED_SHA256_CHECKSUM&quot;,
      mirror [&quot;SOME_URL&quot;],
      enable-preset true,
    },
    // ..
  },
  // ..
}
</code></pre>
<p>In this case, source files in <code>MMM</code> imports our preset names automatically since <code>enable-preset</code> is <code>true</code>.</p>
<p>As an example, suppose a file in <code>MMM</code> contains an <code>import</code> like the following:</p>
<pre><code class="language-neut">import {
  sample.foo {my-func},
}

define buz(): int {
  let i = my-func();
  add-int(i, 10)
}
</code></pre>
<p>This code is the same as the following since the preset is enabled:</p>
<pre><code class="language-neut">define buz(): int {
  let i = my-func();
  add-int(i, 10)
}
</code></pre>
<p>The field <code>preset</code> is expected to be used as a way to realize &quot;preludes&quot; in other languages.</p>
<p>The field <code>preset</code> is optional. The default value of <code>preset</code> is <code>{}</code>.</p>
<h2 id="inline-limit"><a class="header" href="#inline-limit"><code>inline-limit</code></a></h2>
<p>The field <code>inline-limit</code> defines the limit on recursion performed during compilation. It should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  inline-limit 100000,
  // ..
}
</code></pre>
<p>During compilation, the compiler performs possibly recursive computation when:</p>
<ul>
<li>type-checking, and</li>
<li>expanding the definitions of inline functions.</li>
</ul>
<p>The <code>inline-limit</code> specifies a limit here. If the limit is exceeded, the compiler reports an error like the following:</p>
<pre><code class="language-text">/path/to/file.nt:123:45
Error: Exceeded max recursion depth of 1000 during (..)
</code></pre>
<p>The field <code>inline-limit</code> is optional. The default value of <code>inline-limit</code> is <code>1000000</code>.</p>
<h2 id="antecedent"><a class="header" href="#antecedent"><code>antecedent</code></a></h2>
<p>The <em>internal</em> field <code>antecedent</code> defines the list of older compatible versions. This field should look like the following:</p>
<pre><code class="language-ens">{
  // ..
  antecedent [
    &quot;Bp8RulJ-XGTL9Eovre0yQupJpeS3lGNk8Q6QQYua7ag&quot;,
    // ..
    &quot;zptXghmyD5druBl8kx2Qrei6O6fDsKCA7z2KoHp1aqA&quot;,
  ],
  // ..
}
</code></pre>
<p>This information is used to select the newest compatible version of the module. For more information, see the explanation on <code>neut archive</code> in <a href="./commands.html">Commands</a>.</p>
<p>The field <code>antecedent</code> is optional. The default value of <code>antecedent</code> is <code>[]</code>.</p>
<p>This field must be modified <em>only by the compiler</em>. If you modify this field manually, the behavior of the compiler is undefined.</p>
<div class="info-block">
<p>Internally, the compiler treats a module as a library if and only if the module's <code>module.ens</code> contains the key <code>antecedent</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ul>
<li><a href="statements.html#import">import</a></li>
<li><a href="statements.html#define">define</a></li>
<li><a href="statements.html#inline">inline</a></li>
<li><a href="statements.html#data">data</a></li>
<li><a href="statements.html#resource">resource</a></li>
<li><a href="statements.html#rule-right">rule-right</a></li>
<li><a href="statements.html#rule-left">rule-left</a></li>
<li><a href="statements.html#nominal">nominal</a></li>
<li><a href="statements.html#foreign">foreign</a></li>
</ul>
<h2 id="import"><a class="header" href="#import"><code>import</code></a></h2>
<p><code>import</code> imports names from other files. It should look like the following:</p>
<pre><code class="language-neut">import {
  Qux,
  ZZ,
  sample.buz,
  this.foo,
  this.foo.bar {some-func, other-func},
}
</code></pre>
<p><code>import</code> can only be at the top of a file.</p>
<p>Every item in <code>import</code> is something like the following:</p>
<ul>
<li><code>this.foo</code></li>
<li><code>this.foo.bar {some-func, other-func}</code></li>
<li><code>sample.buz</code></li>
</ul>
<p>An import item starts from the alias of the module (<code>this</code>, <code>sample</code>). The alias of the module is specified in <code>dependency</code> in <code>module.ens</code>. If the file we want to import is inside the current module, we'll write <code>this</code>.</p>
<p>The remaining part of the item is the relative path from the source directory. For example, if we want to import <code>(source-dir)/foo/bar</code>, we'll have to write <code>foo.bar</code> after the alias of the module.</p>
<p>An import item can be constructed by concatenating the alias and the path with <code>.</code>. In the case of <code>this.foo.bar</code>, the alias part is <code>this</code>, and the path part is <code>foo.bar</code>.</p>
<p>You can specify names in <code>{}</code>. The names specified here can be used without qualifiers:</p>
<pre><code class="language-neut">import {
  this.foo.bar {some-func},
}

define yo(): unit {
  some-func(arg-1, arg-2)
}
</code></pre>
<p>Unlisted names must be qualified:</p>
<pre><code class="language-neut">import {
  this.foo.bar,
}

define yo(): unit {
  this.foo.bar.some-func(arg-1, arg-2)
}
</code></pre>
<p>You can also list static files in <code>import</code>:</p>
<pre><code class="language-neut">import {
  static {some-file, other-file}
}
</code></pre>
<p>For more on static files, please see <a href="modules.html#static">the section in Modules</a>.</p>
<h2 id="define"><a class="header" href="#define"><code>define</code></a></h2>
<p><code>define</code> defines a function. It should look like the following:</p>
<pre><code class="language-neut">define foo(x: int, y: int): int {
  add-int(x, y)
}

define identity-1(a: type, x: a): a {
  x
}

// a function with an implicit parameter
define identity-2&lt;a&gt;(x: a): a {
  x
}
</code></pre>
<p>Defined functions can then be used:</p>
<pre><code class="language-neut">define use-foo(): int {
  foo(1, 2)
}
</code></pre>
<p><code>define</code> can optionally have implicit parameters, as in <code>identity-2</code> in the above example. The compiler inserts these implicit parameters at compile time, so you don't have to write them explicitly:</p>
<pre><code class="language-neut">define use-func-with-implicit-arg(): int {
  let x = 10;
  let y = identity-1(int, x); // ← explicit version
  let z = identity-2(x);      // ← implicit version
  z
}
</code></pre>
<p>You can also use <code>define</code> without any explicit parameters:</p>
<pre><code class="language-neut">define foo: int {
  10
}

define empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo;
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">define foo(): int {
  10
}

define empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo();
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of a <code>define</code> into a value at compile time if the <code>define</code> doesn't have any explicit parameters. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">define bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<p>A function with the same name can't be defined in the same file.</p>
<p>All the tail-recursions in Neut are optimized into loops (thanks to geniuses in the LLVM team).</p>
<p>Note that statements are order-sensitive as in F#. Thus, the following code results in an error:</p>
<pre><code class="language-neut">define bar(): int {
  foo() // `foo` is undefined here
}

define foo(): int {
  10
}
</code></pre>
<p>You have to use the statement <code>nominal</code> explicitly for forward references.</p>
<h2 id="inline"><a class="header" href="#inline"><code>inline</code></a></h2>
<p><code>inline</code> defines an inline function. It should look like the following:</p>
<pre><code class="language-neut">inline foo(x: int, y: int): int {
  print(&quot;foo&quot;);
  add-int(x, y)
}
</code></pre>
<p><code>inline</code> is the same as <code>define</code> except that the definition is always expanded at compile-time. For example, if you write</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val = foo(10, 20);
  val
}
</code></pre>
<p>The compiler will translate the above code into the following:</p>
<pre><code class="language-neut">define use-inline-foo(): int {
  let val = {
    let x = 10;
    let y = 20;
    print(&quot;foo&quot;);
    add-int(x, y)
  };
  val
}
</code></pre>
<p>You can also use <code>inline</code> without any explicit parameters:</p>
<pre><code class="language-neut">inline foo: int {
  10
}

inline empty-list&lt;a&gt;: list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo;
  empty-list
}
</code></pre>
<p>The above code is translated into the following during compile time:</p>
<pre><code class="language-neut">inline foo(): int {
  10
}

inline empty-list&lt;a&gt;(): list(a) {
  Nil
}

define use-constants(): list(int) {
  let x = foo();
  empty-list()
}
</code></pre>
<p>The compiler tries to reduce the body of an <code>inline</code> into a value at compile time if the <code>inline</code> doesn't have any explicit parameters. The compiler reports an error if it can't get a value. For example, the following should result in an error:</p>
<pre><code class="language-neut">inline bar: int {
  print(&quot;hello&quot;);
  123
}
</code></pre>
<h2 id="data"><a class="header" href="#data"><code>data</code></a></h2>
<p><code>data</code> defines an algebraic data type (ADT). It should look like the following:</p>
<pre><code class="language-neut">data nat {
| Zero
| Succ(nat)
}

data list(a) {
| Nil
| Cons(a, list(a))
}

data config {
| Config(
    count: int,
    foo-path: &amp;text,
    colorize: bool,
  )
}
</code></pre>
<p>You can use the content of an ADT value by using <code>match</code> or <code>case</code>:</p>
<pre><code class="language-neut">define length&lt;a&gt;(xs: list(a)): int {
  // destruct ADT values using `match`
  match xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length(ys))
  }
}

define length-noetic&lt;a&gt;(xs: &amp;list(a)): int {
  // read noetic ADT values using `case`
  case xs {
  | Nil =&gt;
    0
  | Cons(_, ys) =&gt;
    add-int(1, length-noetic(ys))
  }
}

define use-config(c: config) {
  // pattern-matching in `let` is also possible
  let Config of {count, some-path} = c;
  print(count)
}
</code></pre>
<h2 id="resource"><a class="header" href="#resource"><code>resource</code></a></h2>
<p><code>resource</code> defines a new type by specifying how to discard/copy the values of the type. It should look like the following:</p>
<pre><code class="language-neut">resource my-type {
  function (value: pointer) {
    // .. discard the value ..
  },
  function (value: pointer) {
    // .. create a new clone of the value and return it as int ..
  },
  tag, // integer value
}
</code></pre>
<p><code>resource</code> takes three terms. The first term (&quot;discarder&quot;) receives a value of the type and discards it. The second term (&quot;copier&quot;) receives a value of the type and returns a clone of the value (keeping the original value intact). The third term is a tag that is returned when calling <code>magic call-type(my-type, 2, (..))</code>.</p>
<p>The type of a discarder is <code>(a) -&gt; unit</code> for some <code>a</code>. You might want to call functions like <code>free</code> in this term.</p>
<p>The type of a copier is <code>(a) -&gt; a</code> for some <code>a</code>. This <code>a</code> must be the same as the <code>a</code> used in the discarder. You might want to call functions like <code>malloc</code> in this term.</p>
<p>The type of a tag is <code>int</code>. See also: <a href="./terms.html#semantics-call-type">Semantics (call-type)</a></p>
<p>For example, the following is a definition of a &quot;boxed&quot; integer type with some noisy messages:</p>
<pre><code class="language-neut">resource boxed-int {
  // discarder: (pointer) -&gt; unit
  function (v: pointer) {
    print(&quot;discarded!\n&quot;);
    free(v)
  },
  // copier: (pointer) -&gt; pointer
  function (v: pointer) {
    let orig-value = load-int(v);
    let new-ptr = malloc(1);
    magic store(int, orig-value, new-ptr);
    new-ptr
  },
  // You should use `type-tag-to-int(Opaque)` as long as the structure of your
  // resource type isn't the same as one of the `type-tag` values defined in `core.type-tag`.
  // If your resource type has the same structure as one of the `type-tag` values, you can
  // use something like `type-tag-to-int(Int32)` so it can be, for example,
  // printed using `core.debug.vet: (&amp;a) -&gt; unit`.
  type-tag-to-int(Opaque),
}

// provide a way to introduce new boxed integer
define create-new-boxed-int(x: int): boxed-int {
  let new-ptr = malloc(8);
  store-int(x, new-ptr);
  magic cast(int, boxed-int, new-ptr)
}
</code></pre>
<p>A value of type <code>boxed-int</code> prints <code>&quot;discarded!\n&quot;</code> when the value is discarded.</p>
<p><code>resource</code> can be used to define low-level types like arrays.</p>
<p>You can find an example usage of <code>resource</code> in the <code>binary.nt</code> in the <a href="https://github.com/vekatze/neut-core/blob/main/source/binary.nt">core library</a>.</p>
<h2 id="rule-right"><a class="header" href="#rule-right"><code>rule-right</code></a></h2>
<p><code>rule-right</code> defines a macro-like construct that expands bracketed expressions in a fold-right manner. It should look like the following:</p>
<pre><code class="language-neut">rule-right name {
  leaf,
  node,
  root,
}
</code></pre>
<p>Once defined, <code>name</code> can be used with square brackets to accept variable-length arguments:</p>
<pre><code class="language-neut">name[x, y, z, w]
</code></pre>
<p>This expands in a fold-right manner to:</p>
<pre><code class="language-neut">root(node(x, node(y, node(z, node(w, leaf(4))))))
</code></pre>
<p>where the <code>4</code> is the length of <code>[x, y, z, w]</code>.</p>
<h3 id="example-list-construction"><a class="header" href="#example-list-construction">Example: List Construction</a></h3>
<p>The <code>List</code> construct available in the core library is defined using <code>rule-right</code>:</p>
<pre><code class="language-neut">rule-right List {
  function leaf&lt;a&gt;(_: int): list(a) {
    Nil
  },
  function node&lt;a&gt;(x: a, acc: list(a)): list(a) {
    Cons(x, acc)
  },
  function root&lt;a&gt;(x: a): a {
    x
  },
}
</code></pre>
<p>With this definition, <code>List[x, y, z]</code> simplifies as follows:</p>
<pre><code class="language-neut">List[x, y, z]

↓

root(node(x, node(y, node(z, leaf(3)))))

↓

Cons(1, Cons(2, Cons(3, Nil)))
</code></pre>
<h2 id="rule-left"><a class="header" href="#rule-left"><code>rule-left</code></a></h2>
<p><code>rule-left</code> defines a macro-like construct that expands bracketed expressions in a fold-left manner. It should look like the following:</p>
<pre><code class="language-neut">rule-left name {
  leaf,
  node,
  root,
}
</code></pre>
<p>Once defined, <code>name</code> can be used with square brackets to accept variable-length arguments:</p>
<pre><code class="language-neut">name[x, y, z, w]
</code></pre>
<p>This expands in a fold-left manner to:</p>
<pre><code class="language-neut">root(node(node(node(node(leaf(4), x), y), z), w))
</code></pre>
<p>where the <code>4</code> is the length of <code>[x, y, z, w]</code>.</p>
<h3 id="example-vector-construction"><a class="header" href="#example-vector-construction">Example: Vector Construction</a></h3>
<p>The <code>Vector</code> construct available in the core library is defined using <code>rule-left</code>:</p>
<pre><code class="language-neut">rule-left Vector {
  function leaf&lt;a&gt;(size: int): vector(a) {
    make(size)
  },
  function node&lt;a&gt;(acc: vector(a), x: a): vector(a) {
    push-back(acc, x)
  },
  function root&lt;a&gt;(x: a): a {
    x
  },
}
</code></pre>
<p>With this definition, <code>Vector[a, b, c]</code> simplifies as follows:</p>
<pre><code class="language-neut">Vector[a, b, c]

↓

root(node(node(node(leaf(3), a), b), c),)

↓

push-back(push-back(push-back(make(3), a), b), c)
</code></pre>
<h2 id="nominal-1"><a class="header" href="#nominal-1"><code>nominal</code></a></h2>
<p><code>nominal</code> declares functions for forward references. It should look like the following:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int,
}
</code></pre>
<p>An entry of <code>nominal</code> is the same form as found in <code>define</code>. Nominal definitions can be used to achieve mutual recursions:</p>
<pre><code class="language-neut">nominal {
  is-odd(x: int): int, // nominal definition of `is-odd`
}

// given a non-negative integer `x`, returns true if `x` is even.
define is-even(x: int): bool {
  if eq-int(x, 0) {
    True
  } else {
    is-odd(sub-int(x, 1)) // ← using nominal definition
  }
}

// given a non-negative integer `x`, returns true if `x` is odd.
// (&quot;real&quot; definition of `is-odd`)
define is-odd(x: int): bool {
  if eq-int(x, 0) {
    False
  } else {
    is-even(sub-int(x, 1))
  }
}
</code></pre>
<p>If a nominal definition isn't followed by a real definition, the compiler reports an error.</p>
<h2 id="foreign-1"><a class="header" href="#foreign-1"><code>foreign</code></a></h2>
<p><code>foreign</code> declares functions that are defined in linked objects. It should look like the following:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}
</code></pre>
<p>Foreign functions declared here can be called by using <code>magic external(..)</code>.</p>
<p>Suppose that you have a C source file with the following definition:</p>
<pre><code class="language-c">// add_const.c

int64_t neut_myapp_v1_add_const(int64_t value) {
  return value + 100;
}
</code></pre>
<p>You can add the field <code>foreign</code> to your <code>module.ens</code> to compile and link this C source file, as written <a href="modules.html#foreign">here</a>. Under this setting, the following code can utilize <code>neut_myapp_v1_add_const</code>:</p>
<pre><code class="language-neut">foreign {
  neut_myapp_v1_add_const(int): int,
}

define my-func(): int {
  let x: int = 10;
  magic external neut_myapp_v1_add_const(x)
}
</code></pre>
<p>An example project that uses <code>foreign</code> can be found <a href="https://github.com/vekatze/neut/tree/main/test/misc/foreign">here</a>.</p>
<p>You can also use LLVM intrinsics. For example, the LLVM langref states that <code>llvm.sin.*</code> intrinsic is <a href="https://llvm.org/docs/LangRef.html#llvm-sin-intrinsic">available</a>:</p>
<pre><code class="language-llvm">declare float     @llvm.sin.f32(float  %Val)
declare double    @llvm.sin.f64(double %Val)
declare x86_fp80  @llvm.sin.f80(x86_fp80  %Val)
declare fp128     @llvm.sin.f128(fp128 %Val)
declare ppc_fp128 @llvm.sin.ppcf128(ppc_fp128  %Val)
</code></pre>
<p>Thus, the next is a valid use of <code>foreign</code>:</p>
<pre><code class="language-neut">foreign {
  llvm.sin.f64(float): float,
}

define sin(x: float): float {
  magic external llvm.sin.f64(x)
}
</code></pre>
<p>Syscall wrapper functions and library functions are also available:</p>
<pre><code class="language-neut">foreign {
  exit(c-int): void,
  sleep(c-int): c-int,
}
</code></pre>
<p>Here, the definition of <code>c-int</code> is as follows:</p>
<pre><code class="language-neut">inline _c-int: type {
  introspect architecture {
  | amd64 =&gt;
    int32
  | arm64 =&gt;
    int32
  }
}

data c-int {
| C-Int(_c-int)
}
</code></pre>
<p>The type of each parameter in every foreign entry must be a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation. For example, the <code>c-int</code> in <code>exit(c-int): void</code> is valid because it compiles to <code>int32</code> (thanks to an optimization like Haskell's <code>newtype</code>).</p>
<p>The resulting type of every foreign entry must be <code>void</code> or a term that compiles to one of <code>int{N}</code>, <code>float{N}</code>, or <code>pointer</code> during compilation.</p>
<p>When declaring a variadic function, declare only the non-variadic part:</p>
<pre><code class="language-neut">foreign {
  printf(pointer): void,
}
</code></pre>
<p>Then, specify the types of variadic arguments when using <code>magic external</code>:</p>
<pre><code class="language-neut">define print(t: &amp;text): unit {
  // ..
  magic external printf(fmt)(len: int, val: pointer)
  //                         ^^^^^^^^^^^^^^^^^^^^^^
  //                         passing variadic arguments with types
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terms"><a class="header" href="#terms">Terms</a></h1>
<h2 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h2>
<h3 id="basics"><a class="header" href="#basics">Basics</a></h3>
<ul>
<li><a href="terms.html#type">type</a></li>
<li><a href="terms.html#local-variables">Local Variables</a></li>
<li><a href="terms.html#top-level-variables">Top-Level Variables</a></li>
<li><a href="terms.html#let">let</a></li>
</ul>
<h3 id="primitive-value"><a class="header" href="#primitive-value">Primitive Value</a></h3>
<ul>
<li><a href="terms.html#integers">Integers</a></li>
<li><a href="terms.html#floats">Floats</a></li>
<li><a href="terms.html#texts">Texts</a></li>
<li><a href="terms.html#runes">Runes</a></li>
</ul>
<h3 id="function"><a class="header" href="#function">Function</a></h3>
<ul>
<li><a href="terms.html#x1-a1--xn-an---b">(x1: a1, ..., xn: an) -&gt; b</a></li>
<li><a href="terms.html#function-x1-a1--xn-an--e-">function (x1: a1, ..., xn: an) { e }</a></li>
<li><a href="terms.html#define-fx1-a1--xn-an-c--e-">define f(x1: a1, ..., xn: an): c { e }</a></li>
<li><a href="terms.html#ee1--en">e(e1, ..., en)</a></li>
<li><a href="terms.html#e-of-x1--e1--xn--en">e of {x1 := e1, ..., xn := en}</a></li>
<li><a href="terms.html#exact-e">exact e</a></li>
</ul>
<h3 id="adt"><a class="header" href="#adt">ADT</a></h3>
<ul>
<li><a href="terms.html#adt-formation">ADT Formation</a></li>
<li><a href="terms.html#constructors-adt-introduction">Constructors</a></li>
<li><a href="terms.html#match">match</a></li>
</ul>
<h3 id="necessity-and-noema"><a class="header" href="#necessity-and-noema">Necessity and Noema</a></h3>
<ul>
<li><a href="terms.html#meta">meta</a></li>
<li><a href="terms.html#a">&amp;a</a></li>
<li><a href="terms.html#box">box</a></li>
<li><a href="terms.html#letbox">letbox</a></li>
<li><a href="terms.html#letbox-t">letbox-T</a></li>
<li><a href="terms.html#case">case</a></li>
</ul>
<h3 id="thread"><a class="header" href="#thread">Thread</a></h3>
<ul>
<li><a href="terms.html#thread">thread</a></li>
<li><a href="terms.html#detach">detach</a></li>
<li><a href="terms.html#attach">attach</a></li>
</ul>
<h3 id="miscellaneous-2"><a class="header" href="#miscellaneous-2">Miscellaneous</a></h3>
<ul>
<li><a href="terms.html#quote">quote</a></li>
<li><a href="terms.html#magic">magic</a></li>
<li><a href="terms.html#introspect">introspect</a></li>
<li><a href="terms.html#include-text">include-text</a></li>
<li><a href="terms.html#admit">admit</a></li>
<li><a href="terms.html#assert">assert</a></li>
<li><a href="terms.html#_">_</a></li>
</ul>
<h3 id="syntactic-sugar"><a class="header" href="#syntactic-sugar">Syntactic Sugar</a></h3>
<ul>
<li><a href="terms.html#on">let x on y1, ..., yn = e1; e2</a></li>
<li><a href="terms.html#e">*e</a></li>
<li><a href="terms.html#if">if</a></li>
<li><a href="terms.html#when-cond--e-">when cond { e }</a></li>
<li><a href="terms.html#e1-e2">e1; e2</a></li>
<li><a href="terms.html#try-x--e1-e2">try x = e1; e2</a></li>
<li><a href="terms.html#tie-x--e1-e2">tie x = e1; e2</a></li>
<li><a href="terms.html#pin-x--e1-e2">pin x = e1; e2</a></li>
<li><a href="terms.html#t">?t</a></li>
</ul>
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p><code>type</code> is the type of types.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  // `type` used as a term
  let foo = type;
  Unit
}

// `type` used as a type
define identity(a: type, x: a): a {
  x
}
</code></pre>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<pre><code class="language-neut">type
</code></pre>
<h3 id="semantics"><a class="header" href="#semantics">Semantics</a></h3>
<p><code>type</code> is compiled into a pointer to <code>base.#.imm</code>.</p>
<h3 id="type-1"><a class="header" href="#type-1">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)
----------------
  Γ ⊢ type: type
</code></pre>
<h2 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h2>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-neut">define sample(): unit {
  // defining/using various local variables
  let x = Unit;
  let foo = x;
  let 'bar = foo;
  let buz' = 'bar;
  let _h-e-l-l-o = buz';
  let αβγ = _h-e-l-l-o;
  let theSpreadingWideMyNarrowHandsToGatherParadise = αβγ;
  let 冥きより冥き道にぞ入りぬべきはるかに照らせ山の端の月 = Unit;
  let _ = Unit;

  // shadowing (not reassignment)
  let x = Unit;
  let x = type;
  let x =
    function (x: bool) {
      x // x: bool
    };
  Unit
}
</code></pre>
<h3 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h3>
<p>The name of a local variable must satisfy the following conditions:</p>
<ul>
<li>It doesn't contain any of <code>=() `\&quot;\n\t:;,&lt;&gt;[]{}/*|&amp;?</code></li>
<li>It doesn't start with <code>A, B, .., Z</code> (the upper case alphabets)</li>
</ul>
<h3 id="semantics-1"><a class="header" href="#semantics-1">Semantics</a></h3>
<p>If the content of a variable <code>x</code> is an immediate value, <code>x</code> is compiled into the name of a register that stores the immediate. Otherwise, <code>x</code> is compiled into the name of a register that stores a pointer to the content.</p>
<h3 id="type-2"><a class="header" href="#type-2">Type</a></h3>
<pre><code class="language-neut">  Γ ⊢ a: type
----------------
Γ, x: a ⊢ x: a
</code></pre>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<ul>
<li>The compiler reports unused variables. You can use the name <code>_</code> to suppress those.</li>
<li>Variables in Neut are immutable. You'll need <code>core.cell</code> to achieve mutability.</li>
</ul>
<h2 id="top-level-variables"><a class="header" href="#top-level-variables">Top-Level Variables</a></h2>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-neut">import {
  core.bool {bool},
}

define sample(): unit {
  // using top-level variables
  let _ = bool; // using an imported top-level name
  let _ = core.bool.bool; // using the definite description of `core.bool.bool`
  Unit
}
</code></pre>
<h3 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h3>
<p>The name of a top-level variable is a (possibly) dot-separated symbols, where each symbol must satisfy the following conditions:</p>
<ul>
<li>It doesn't contain any of <code>=() `\&quot;\n\t:;,&lt;&gt;[]{}/*|&amp;?</code></li>
</ul>
<h3 id="semantics-2"><a class="header" href="#semantics-2">Semantics</a></h3>
<p>A top-level variable <code>f</code> is compiled into the following 3-word tuple:</p>
<pre><code>(base.#.imm, 0, POINTER_TO_FUNCTION(f))
</code></pre>
<p>See the Note below for a more detailed explanation.</p>
<h3 id="type-3"><a class="header" href="#type-3">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)     (c: a is defined at the top-level)
-------------------------------------------------------
                  Γ ⊢ c: a
</code></pre>
<h3 id="note"><a class="header" href="#note">Note</a></h3>
<p>Let's see how top-level variables are compiled. Consider the following top-level functions:</p>
<pre><code class="language-neut">// (source-dir)/sample.nt

// defining a top-level variable `increment`
define increment(x: int): int {
  add-int(x, 1)
}

define get-increment(): (int) -&gt; int {
  increment // using a top-level variable `increment`
}
</code></pre>
<p>This <code>increment</code> and <code>get-increment</code> are compiled into LLVM functions like the below:</p>
<pre><code class="language-llvm">; (build-dir)/path/to/sample.ll

define fastcc ptr @&quot;this.sample.increment&quot;(ptr %_1) {
  %_2 = ptrtoint ptr %_1 to i64
  %_3 = add i64 %_2, 1
  %_4 = inttoptr i64 %_3 to ptr
  ret ptr %_4
}

define fastcc ptr @&quot;this.sample.get-increment&quot;() {
  ; `increment` in `get-increment` is lowered to the following code:

  ; calculate the size of 3-word tuples
  %_1 = getelementptr ptr, ptr null, i32 3
  %_2 = ptrtoint ptr %_1 to i64
  ; allocate memory
  %_3 = call fastcc ptr @malloc(i64 %_2)
  ; store contents
  %_4 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 0
  %_5 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 1
  %_6 = getelementptr [3 x ptr], ptr %_3, i32 0, i32 2
  store ptr @&quot;base.#.imm&quot;, ptr %_4            ; tuple[0] = `base.#.imm`
  store ptr null, ptr %_5                     ; tuple[1] = null
  store ptr @&quot;this.sample.increment&quot;, ptr %_6 ; tuple[2] = (function pointer)
  ; return the pointer to the tuple
  ret ptr %_3
}
</code></pre>
<p>Incidentally, these 3-word tuples are optimized away as long as top-level variables (functions) are called directly with arguments.</p>
<h2 id="let"><a class="header" href="#let"><code>let</code></a></h2>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-neut">define use-let(): unit {
  // `let`
  let t = &quot;test&quot;;
  print(t)
}

define use-let(): unit {
  let bar = {
    // nested `let`
    let foo = some-func();
    other-func(foo)
  };
  do-something(bar)
}

define use-let(): unit {
  // `let` with a type annotation
  let t: &amp;text = &quot;test&quot;;
  print(t)
}

</code></pre>
<p><code>let</code> can be used to destructure an ADT value:</p>
<pre><code class="language-neut">data item {
| Item(i: int, b: bool)
}

define use-item(x: item): int {
  // use `let` with a pattern
  let Item(i, _) = x; // ← here
  i
}

define use-item-2(x: item): int {
  // use `let` with an of-pattern
  let Item of {i} = x;
  i
}
</code></pre>
<h3 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h3>
<pre><code class="language-neut">let x = e1; e2

let x: t = e1; e2
</code></pre>
<h3 id="semantics-3"><a class="header" href="#semantics-3">Semantics</a></h3>
<p><code>let x = e1; e2</code> binds the result of <code>e1</code> to the variable <code>x</code>. This <code>x</code> can then be used in <code>e2</code>.</p>
<h3 id="type-4"><a class="header" href="#type-4">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a     Γ, x: a ⊢ e2: b
-----------------------------
   Γ ⊢ let x = e1; e2: b
</code></pre>
<h3 id="note-1"><a class="header" href="#note-1">Note</a></h3>
<p>(1) <code>let x = e1; e2</code> isn't exactly the same as <code>{function (x) {e2}}(e1)</code>. The difference lies in the fact that the type of <code>e2</code> can't depend on <code>x</code> in <code>let x = e1; e2</code>.</p>
<p>(2) When a pattern is passed, <code>let</code> is the following syntactic sugar:</p>
<pre><code class="language-neut">let pat = x;
cont

↓

match x {
| pat =&gt;
  cont
}
</code></pre>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: int = 100;
  //           ^^^
  let _: int16 = 100;
  //             ^^^
  Unit
}

</code></pre>
<h3 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h3>
<p><code>3</code>, <code>-16</code>, <code>424242</code>, etc.</p>
<h3 id="semantics-4"><a class="header" href="#semantics-4">Semantics</a></h3>
<p>The same as LLVM integers.</p>
<h3 id="type-5"><a class="header" href="#type-5">Type</a></h3>
<p>The type of an integer is unknown in itself. It must be inferred to be one of the following types:</p>
<ul>
<li><code>int1</code></li>
<li><code>int2</code></li>
<li>...</li>
<li><code>int64</code></li>
</ul>
<h3 id="note-2"><a class="header" href="#note-2">Note</a></h3>
<ul>
<li>The type <code>int</code> is also available. For more, see <a href="./primitives.html#primitive-types">Primitives</a>.</li>
</ul>
<h2 id="floats"><a class="header" href="#floats">Floats</a></h2>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: float = 3.8;
  //             ^^^
  let _: float32 = 3.8;
  //               ^^^
  Unit
}

</code></pre>
<h3 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h3>
<p><code>3.8</code>, <code>-0.2329</code>, etc.</p>
<h3 id="semantics-5"><a class="header" href="#semantics-5">Semantics</a></h3>
<p>The same as LLVM floats.</p>
<h3 id="type-6"><a class="header" href="#type-6">Type</a></h3>
<p>The type of a float is unknown in itself. It must be inferred to be one of the following types:</p>
<ul>
<li><code>float16</code></li>
<li><code>float32</code></li>
<li><code>float64</code></li>
</ul>
<h3 id="note-3"><a class="header" href="#note-3">Note</a></h3>
<ul>
<li>The type <code>float</code> is also available. For more, see <a href="./primitives.html#primitive-types">Primitives</a>.</li>
</ul>
<h2 id="runes"><a class="header" href="#runes">Runes</a></h2>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: rune = `A`;
  //            ^^^
  let _: rune = `\n`;
  //            ^^^
  let _: rune = `\n`;
  //            ^^^
  Unit
}

</code></pre>
<h3 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h3>
<p><code>`A`</code>, <code>`\n`</code>, <code>`\u{123}`</code>, etc.</p>
<p>The available escape sequences in rune literals are the same as those of <a href="./terms.html#texts">text literals</a>.</p>
<h3 id="semantics-6"><a class="header" href="#semantics-6">Semantics</a></h3>
<p>The value of a rune literal is a Unicode codepoint encoded in UTF-8.</p>
<p>The underlying representation of a rune is an int32.</p>
<h3 id="type-7"><a class="header" href="#type-7">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)  (c is a rune literal)
---------------------------------------
         Γ ⊢ c: rune
</code></pre>
<h3 id="note-4"><a class="header" href="#note-4">Note</a></h3>
<p>(1) You can write <code>`\1234`</code>, for example, to represent U+1234 (<code>`ሴ`</code>).</p>
<p>(2) We have the following equalities, for example:</p>
<pre><code class="language-neut">`A` == magic cast(int32, rune, 0x41)
`Γ` == magic cast(int32, rune, 0xCE93)
`あ` == magic cast(int32, rune, 0xE38182)
`⭐` == magic cast(int32, rune, 0xE2AD90)
</code></pre>
<p>You can see this by calling the following function:</p>
<pre><code class="language-neut">define print-star(): unit {
  // prints &quot;⭐&quot;
  pin t = core.text.singleton(magic cast(int32, rune, 0xe2ad90));
  print-line(t)
}
</code></pre>
<h2 id="texts"><a class="header" href="#texts">Texts</a></h2>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  let _: &amp;text = &quot;test&quot;;
  //             ^^^^^^
  Unit
}

</code></pre>
<h3 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h3>
<p><code>&quot;hello&quot;</code>, <code>&quot;Hello, world!\n&quot;</code>, <code>&quot;\u{1f338} ← Cherry Blossom&quot;</code>, etc.</p>
<p>Below is the list of all the escape sequences in Neut:</p>
<div class="table-wrapper"><table><thead><tr><th>Escape Sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\0</code></td><td>U+0000 (null character)</td></tr>
<tr><td><code>\t</code></td><td>U+0009 (horizontal tab)</td></tr>
<tr><td><code>\n</code></td><td>U+000A (line feed)</td></tr>
<tr><td><code>\r</code></td><td>U+000D (carriage return)</td></tr>
<tr><td><code>\&quot;</code></td><td>U+0022 (double quotation mark)</td></tr>
<tr><td><code>\\</code></td><td>U+005C (backslash)</td></tr>
<tr><td><code>\`</code></td><td>U+0060 (backtick)</td></tr>
<tr><td><code>\u{n}</code></td><td>U+n</td></tr>
</tbody></table>
</div>
<p>The <code>n</code> in <code>\u{n}</code> must be a lowercase hexadecimal number.</p>
<h3 id="semantics-7"><a class="header" href="#semantics-7">Semantics</a></h3>
<p>A text literal is compiled into a pointer to a tuple like the following:</p>
<pre><code class="language-text">(0, length-of-string, array-of-characters)
</code></pre>
<p>This tuple is static. More specifically, a global constant like the following is inserted into the resulting IR.</p>
<pre><code class="language-llvm">@&quot;text-hello&quot; = private unnamed_addr constant {i64, i64, [5 x i8]} {i64 0, i64 5, [5 x i8] c&quot;hello&quot;}
</code></pre>
<p>And a text like <code>&quot;hello&quot;: &amp;text</code> is compiled into <code>ptr @&quot;text-hello&quot;</code>.</p>
<h3 id="type-8"><a class="header" href="#type-8">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)  (t is a text literal)
---------------------------------------
         Γ ⊢ t: &amp;text
</code></pre>
<h3 id="note-5"><a class="header" href="#note-5">Note</a></h3>
<ul>
<li>In the current implementation, the set of recognized escape sequences like <code>\n</code> or <code>\t</code> are the same as that of Haskell.</li>
</ul>
<h2 id="x1-a1--xn-an---b"><a class="header" href="#x1-a1--xn-an---b"><code>(x1: a1, ..., xn: an) -&gt; b</code></a></h2>
<p><code>(x1: a1, ..., xn: an) -&gt; b</code> is the type of functions.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><code class="language-neut">// a function that accepts ints and returns bools
(value: int) -&gt; bool

// this is equivalent to `(_: int) -&gt; bool`:
(int) -&gt; bool

// use a type variable
(a: type, x: a) -&gt; a

// make the first argument implicit
&lt;a: type&gt;(x: a) -&gt; a

// this is equivalent to `&lt;a: _&gt;(x: a) -&gt; a`
&lt;a&gt;(x: a) -&gt; a
</code></pre>
<h3 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h3>
<pre><code class="language-neut">&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<p>The following abbreviations are available:</p>
<pre><code class="language-neut">(y1: b1, ..., ym: bm) -&gt; c

// ↓
// &lt;&gt;(y1: b1, ..., ym: bm) -&gt; c


(b1, ..., bm) -&gt; c

// ↓
// (_: b1, ..., _: bm) -&gt; c


&lt;a1, ..., an&gt;(y1: b1, ..., ym: bm) -&gt; c

// ↓
// &lt;a1: _, ..., an: _&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<h3 id="semantics-8"><a class="header" href="#semantics-8">Semantics</a></h3>
<p>A function type is compiled into a pointer to <code>base.#.cls</code>. For more, please see <a href="./how-to-execute-types.html">How to Execute Types</a></p>
<h3 id="type-9"><a class="header" href="#type-9">Type</a></h3>
<pre><code class="language-neut">  Γ, x1: a1, ..., xn: an, y1: b1, ..., ym: bm ⊢ c: type
--------------------------------------------------------
Γ ⊢ &lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c: type
</code></pre>
<h2 id="function-x1-a1--xn-an--e-"><a class="header" href="#function-x1-a1--xn-an--e-"><code>function (x1: a1, ..., xn: an) { e }</code></a></h2>
<p><code>function</code> can be used to create a lambda abstraction (an anonymous function).</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><code class="language-neut">define use-function(): int {
  let f =
    function (x: int, y: int) {
      let z = add-int(x, y);
      mul-int(z, z)
    };
  f(10, 20)
}
</code></pre>
<h3 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h3>
<pre><code class="language-neut">function (x1: a1, ..., xn: an) {
  e
}
</code></pre>
<p>All the free variables of a <code>function</code> must be at the same layer of the function. For example, the following is not a valid term in Neut:</p>
<pre><code class="language-neut">define return-int(x: meta int): meta () -&gt; int {
  // here is layer 0
  box {
    // here is layer -1
    function () {
      letbox result =
        // here is layer 0
        x; // ← error
      result
    }
  }
}
</code></pre>
<p>because the free variable <code>x</code> in the <code>function</code> is at layer 0, whereas the <code>function</code> is at layer -1.</p>
<p>For more on layers, please see the section on <a href="terms.html#box">box</a>, <a href="terms.html#letbox">letbox</a>, and <a href="terms.html#letbox-t">letbox-T</a>.</p>
<h3 id="semantics-9"><a class="header" href="#semantics-9">Semantics</a></h3>
<p>A <code>function</code> is compiled into a three-word closure. For more, please see <a href="./how-to-execute-types.html#advanced-function-types">How to Execute Types</a>.</p>
<h3 id="type-10"><a class="header" href="#type-10">Type</a></h3>
<pre><code class="language-neut">    Γ, x1: a1, ..., xn: an ⊢ e: t
-----------------------------------------
Γ ⊢ function (x1: a1, ..., xn: an) {e}: t

</code></pre>
<h3 id="note-6"><a class="header" href="#note-6">Note</a></h3>
<ul>
<li>Lambda abstractions defined by <code>function</code> are reduced at compile-time when possible. If you would like to avoid this behavior, consider using <code>define</code>.</li>
</ul>
<h2 id="define-fx1-a1--xn-an-c--e-"><a class="header" href="#define-fx1-a1--xn-an-c--e-"><code>define f(x1: a1, ..., xn: an): c { e }</code></a></h2>
<p><code>define</code> (at the term-level) can be used to create a function with possible recursion.</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><code class="language-neut">define use-define(): int {
  let c = 10;
  let f =
    // term-level `define` with a free variable `c`
    define some-recursive-func(x: int): int {
      if eq-int(x, 0) {
        0
      } else {
        add-int(c, some-recursive-func(sub-int(x, 1)))
      }
    };
  f(100)
}
</code></pre>
<h3 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h3>
<pre><code class="language-neut">define name&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm): c {
  e
}
</code></pre>
<p>The following abbreviations are available:</p>
<pre><code class="language-neut">define name(y1: b1, ..., ym: bm): c {e}

// ↓
// define name&lt;&gt;(y1: b1, ..., ym: bm): c {e}


define name&lt;a1, ..., an&gt;(y1: b1, ..., ym: bm): c {e}

// ↓
// define name&lt;a1: _, ..., an: _&gt;(y1: b1, ..., ym: bm) -&gt; c
</code></pre>
<p>As in <code>function</code>, all the free variables of a <code>define</code> must be at the same layer of the <code>define</code>.</p>
<h3 id="semantics-10"><a class="header" href="#semantics-10">Semantics</a></h3>
<p>A term-level <code>define</code> is lifted to a top-level definition using lambda lifting. For example, consider the following example:</p>
<pre><code class="language-neut">define use-define(): int {
  let c = 10;
  let f =
    // term-level `define` with a free variable `c`
    define some-recursive-func(x: int): int {
      if eq-int(x, 0) {
        0
      } else {
        add-int(c, some-recursive-func(sub-int(x, 1)))
      }
    };
  f(100)
}
</code></pre>
<p>The code above is compiled into something like the below:</p>
<pre><code class="language-neut">// the free variable `c` is now a parameter
define some-recursive-func(c: int, x: int): int {
  if eq-int(x, 0) {
    0
  } else {
    let f =
      function (x: int) {
        some-recursive-func(c, x)
      };
    add-int(c, f(sub-int(x, 1)))
  }
}

define use-define(): int {
  let c = 10;
  let f =
    function (x: int) {
      some-recursive-func(c, x)
    };
  f(100)
}
</code></pre>
<h3 id="type-11"><a class="header" href="#type-11">Type</a></h3>
<pre><code class="language-neut">Γ, x1: a1, ..., xn: an, f: (x1: a1, ..., xn: an) -&gt; t ⊢ e: t
------------------------------------------------------------
     Γ ⊢ (define f(x1: a1, ..., xn: an):t {e}): t
</code></pre>
<h3 id="note-7"><a class="header" href="#note-7">Note</a></h3>
<ul>
<li>Functions defined by term-level <code>define</code> aren't inlined at compile-time, even if it doesn't contain any recursions.</li>
</ul>
<h2 id="ee1--en"><a class="header" href="#ee1--en"><code>e(e1, ..., en)</code></a></h2>
<p>Given a function <code>e</code> and arguments <code>e1, ..., en</code>, we can write <code>e(e1, ..., en)</code> to write a function application.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-neut">define use-function(): unit {
  let _ = foo();
  //      ^^^^^
  let _ = bar(1);
  //      ^^^^^^
  let _ = buz(&quot;hello&quot;, True);
  //      ^^^^^^^^^^^^^^^^^^
  Unit
}
</code></pre>
<h3 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h3>
<pre><code class="language-neut">e(e1, ..., en)
</code></pre>
<h3 id="semantics-11"><a class="header" href="#semantics-11">Semantics</a></h3>
<p>Given a function application <code>e(e1, ..., en)</code> the system does the following:</p>
<ol>
<li>Computes <code>e</code>, <code>e1</code>, ..., <code>en</code> into values <code>v</code>, <code>v1</code>, ..., <code>vn</code></li>
<li>Extracts the contents from the closure <code>v</code>, obtaining the tuple of its free variables and a function label</li>
<li>Deallocates the tuple of the closure <code>v</code></li>
<li>Calls the function label with the tuple and <code>v1, ..., vn</code> as arguments</li>
</ol>
<h3 id="type-12"><a class="header" href="#type-12">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: &lt;x1: a1, .., xn: an&gt;(y1: b1, .., ym: bm) -&gt; c    Γ ⊢ e1: b1  ..   Γ ⊢ em: bm
---------------------------------------------------------------------------------------
    Γ ⊢ e(e1, .., em): c[x1 := ?M1, .., xn := ?Mn, y1 := e1, .., ym := em]
</code></pre>
<p>The <code>?Mi</code>s in the above rule are metavariables that must be inferred by the compiler.</p>
<h3 id="note-8"><a class="header" href="#note-8">Note</a></h3>
<p>If the function <code>e</code> contains implicit parameters, holes are inserted automatically.</p>
<p>For example, consider the following code:</p>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id(): unit {
  id(Unit)
}
</code></pre>
<p>The <code>id(Unit)</code> in the example above is (conceptually) compiled into the below:</p>
<pre><code class="language-neut">define _id(a: type, x: a): a {
  x
}

define use-id(): unit {
  _id(_, Unit) // ← a hole `_` is inserted here
}
</code></pre>
<h2 id="e-of-x1--e1--xn--en"><a class="header" href="#e-of-x1--e1--xn--en"><code>e of {x1 := e1, ..., xn := en}</code></a></h2>
<p><code>e of {x1 := e1, ..., xn := en}</code> is an alternative notation of function application.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><code class="language-neut">define foo(x: int, y: bool, some-path: &amp;text): unit {
  // ...
}

define use-foo(): unit {
  foo of {
    x := 10,
    y := True,
    some-path := &quot;/path/to/file&quot;,
  }
}
</code></pre>
<h3 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h3>
<pre><code class="language-neut">e of {x1 := e1, ..., xn := en}
</code></pre>
<h3 id="semantics-12"><a class="header" href="#semantics-12">Semantics</a></h3>
<p>The same as <code>e(e1, ..., en)</code>.</p>
<h3 id="type-13"><a class="header" href="#type-13">Type</a></h3>
<p>The same as <code>e(e1, ..., en)</code>.</p>
<h3 id="note-9"><a class="header" href="#note-9">Note</a></h3>
<p>This notation might be useful when used in combination with ADTs:</p>
<pre><code class="language-neut">data config {
| Config(
    count: int,
    path: &amp;text,
    colorize: bool,
  )
}

inline some-config {
  Config of {
    count := 10,
    colorize := True,
    path := &quot;/path/to/file&quot;, // you can reorder arguments
  }
}
</code></pre>
<p>If the argument is a variable that has the same name as the parameter, you can use a shorthand notation:</p>
<pre><code class="language-neut">define use-foo(): unit {
  let x = 10;
  let y = True;
  let some-path = &quot;/path/to/file&quot;;
  foo of {x, y, some-path} // == foo of {x := x, y := y, some-path := some-path}
}
</code></pre>
<h2 id="exact-e"><a class="header" href="#exact-e"><code>exact e</code></a></h2>
<p>Given a function <code>e</code>, <code>exact e</code> supplies all the implicit parameters of <code>e</code> by inserting holes.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id() {
  let g: (x: int) -&gt; int = exact id;
  Unit
}
</code></pre>
<p>Note that the following won't type-check:</p>
<pre><code class="language-neut">define id&lt;a&gt;(x: a): a {
  x
}

define use-id() {
  let g: (x: int) -&gt; int = id;
  Unit
}
</code></pre>
<p>This is because the type of <code>id</code> is <code>&lt;a&gt;(x: a) -&gt; a</code>, not <code>(x: ?M) -&gt; ?M</code>.</p>
<h3 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h3>
<pre><code class="language-neut">exact e
</code></pre>
<h3 id="semantics-13"><a class="header" href="#semantics-13">Semantics</a></h3>
<p>Given a term <code>e</code> of type <code>&lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c</code>,</p>
<pre><code class="language-neut">exact e
</code></pre>
<p>is translated into the following:</p>
<pre><code class="language-neut">function (y1: b1, ..., ym: bm) {
  e(_, ..., _, y1, ..., ym)
}
</code></pre>
<h3 id="type-14"><a class="header" href="#type-14">Type</a></h3>
<pre><code class="language-neut">       Γ ⊢ e: &lt;x1: a1, ..., xn: an&gt;(y1: b1, ..., ym: bm) -&gt; c
--------------------------------------------------------------------
Γ ⊢ exact e: ((y1: b1, ..., ym: bm) -&gt; c)[x1 := ?M1, ..., xn := ?Mn]
</code></pre>
<p>Here, <code>?Mi</code>s are metavariables that must be inferred by the type checker.</p>
<h3 id="note-10"><a class="header" href="#note-10">Note</a></h3>
<p>As you can see from its semantics, an <code>exact</code> is just a shorthand of a &quot;hole-application&quot; that fills in implicit parameters.</p>
<h2 id="adt-formation"><a class="header" href="#adt-formation">ADT Formation</a></h2>
<p>After defining an ADT using the statement <code>data</code>, you can use the ADT.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define use-nat-type(): type {
  // 🌟
  my-nat
}
</code></pre>
<h3 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="semantics-14"><a class="header" href="#semantics-14">Semantics</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="type-15"><a class="header" href="#type-15">Type</a></h3>
<p>If an ADT <code>some-adt</code> is nullary, the type of <code>some-adt</code> is <code>type</code>.</p>
<p>Otherwise, suppose that an ADT <code>some-adt</code> is defined as follows:</p>
<pre><code class="language-neut">data some-adt(x1: a1, ..., xn: an) {..}
</code></pre>
<p>In this case, the type of <code>some-adt</code> is <code>(x1: a1, ..., xn: an) -&gt; type</code>.</p>
<h2 id="constructors-adt-introduction"><a class="header" href="#constructors-adt-introduction">Constructors (ADT Introduction)</a></h2>
<p>After defining an ADT using the statement <code>data</code>, you can use the constructors to construct values of the ADT.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define create-nat(): my-nat {
  // 🌟 (`Succ` and `Zero` are constructors)
  Succ(Succ(Zero))
}
</code></pre>
<h3 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h3>
<p>The same as that of top-level variables, except that constructors must be capitalized.</p>
<h3 id="semantics-15"><a class="header" href="#semantics-15">Semantics</a></h3>
<p>The same as that of top-level variables.</p>
<h3 id="type-16"><a class="header" href="#type-16">Type</a></h3>
<p>If a constructor <code>c</code> is nullary, the type of <code>c</code> is the ADT type. For example, consider the following code:</p>
<pre><code class="language-neut">data some-adt {
| c1
}

data other-adt(a: type) {
| c2
}
</code></pre>
<p>In this case,</p>
<ul>
<li>the type of <code>c1</code> is <code>some-adt</code>, and</li>
<li>the type of <code>c2</code> is <code>other-adt(?M)</code>, where the <code>?M</code> must be inferred by the compiler.</li>
</ul>
<p>If a constructor <code>c</code> isn't nullary, the type of <code>c</code> is the function type that takes specified arguments and turns them into the ADT type. For example, consider the following code:</p>
<pre><code class="language-neut">data some-adt {
| c1(foo: int)
}

data other-adt(a: type) {
| c2(bar: bool, buz: other-adt(a))
}
</code></pre>
<p>In this case,</p>
<ul>
<li>the type of <code>c1</code> is <code>(foo: int) -&gt; some-adt</code>, and</li>
<li>the type of <code>c2</code> is <code>&lt;a: type&gt;(bar: bool, buz: other-adt(a)) -&gt; other-adt(a)</code>.</li>
</ul>
<h2 id="match"><a class="header" href="#match"><code>match</code></a></h2>
<p>You can use <code>match</code> to destructure ADT values or integers.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define foo(n: my-nat): int {
  // 🌟
  match n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo(m)
  }
}

define bar(n: my-nat): int {
  // 🌟 (You can use nested patterns)
  match n {
  | Zero =&gt;
    100
  | Succ(Succ(m)) =&gt; // ← a nested pattern
    200
  | Succ(m) =&gt;
    foo(m)
  }
}

define eq-nat(n1: my-nat, n2: my-nat): bool {
  // 🌟 (`match` can handle multiple values)
  match n1, n2 {
  | Zero, Zero =&gt;
    True
  | Succ(m1), Succ(m2) =&gt;
    eq-nat(m1, m2)
  | _, _ =&gt;
    False
  }
}

define literal-match(x: int): int {
  // 🌟 (You can use `match` against integers)
  match x {
  | 3 =&gt;
    30
  | 5 =&gt;
    50
  | _ =&gt;
    add-int(x, 10)
  }
}
</code></pre>
<h3 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h3>
<pre><code class="language-neut">match e1, ..., en {
| pattern-1 =&gt;
  body-1
  ...
| pattern-m =&gt;
  body-m
}
</code></pre>
<h3 id="semantics-16"><a class="header" href="#semantics-16">Semantics</a></h3>
<p>The semantics of <code>match</code> is the same as the semantics of ordinary pattern matching, except that ADT values are <em>consumed</em> after branching.</p>
<p>For example, let's see how <code>my-nat</code> in the following code is used in <code>match</code>:</p>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}
</code></pre>
<p>The internal representation of <code>n: my-nat</code> is something like the below:</p>
<pre><code class="language-neut">Zero:
  (0) // 1-word tuple
Succ:
  (1, pointer-to-m) // 2-word tuple
</code></pre>
<p>When evaluating <code>match</code>, the computer inspects the first element of the &quot;tuple&quot; <code>n</code>.</p>
<pre><code class="language-neut">define foo(n: my-nat): int {
  // 🌟 (inspects the first element of `n` here)
  match n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo(m)
  }
}
</code></pre>
<p>If the first element is <code>0</code>, which means that we found an ADT value of <code>Zero</code>, the computer <em>frees</em> the outer tuple of <code>(0)</code>, and then evaluates <code>100</code>.</p>
<p>If the first element is <code>1</code>, which means that we found an ADT value of <code>Succ</code>, the computer gets the pointer to the second element of <code>n</code>, binds it to <code>m</code>, <em>frees</em> the outer tuple of <code>(1, pointer-to-m)</code>, and then evaluates <code>foo(m)</code>.</p>
<h3 id="type-17"><a class="header" href="#type-17">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a1
...
Γ ⊢ en: an

Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ pat-1: a1
Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ body-1: b

...

Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ pat-m: an
Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ body-m: b

(for all i = 1, ..., m, pat-i is a pattern for e1, ..., en)
(the sequence pat-1, ..., pat-m is a exhaustinve matching against e1, ..., en)
------------------------------------------------------------------------------
Γ ⊢ match e1, ..., en {
    | pat-1 =&gt; body-1
    ...
    | pat-m =&gt; body-m
    }: b
</code></pre>
<p>The above might be a bit overwhelming. Please see the following Note for an example.</p>
<h3 id="note-11"><a class="header" href="#note-11">Note</a></h3>
<p>An example of the application of the typing rule of <code>match</code>:</p>
<pre><code class="language-neut">Γ ⊢ n: my-nat

Γ ⊢ Zero: my-nat // pat-1
Γ ⊢ 100: int // body-1

Γ, m: my-nat ⊢ Succ(m): my-nat // pat-2
Γ, m: my-nat ⊢ foo(m): int // body-2

(Zero and Succ(m) are patterns for n)
(the sequence Zero, Succ(m) is a exhaustinve matching against n)
------------------------------------------------------------------------------
Γ ⊢ match n {
    | Zero =&gt; 100
    | Succ(m) =&gt; foo(m)
    }: int
</code></pre>
<h2 id="meta"><a class="header" href="#meta"><code>meta</code></a></h2>
<p>Given a type <code>a: type</code>, <code>meta a</code> is the type of <code>a</code> in the &quot;outer&quot; layer.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><code class="language-neut">define axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T result = x;
  result
}
</code></pre>
<h3 id="syntax-17"><a class="header" href="#syntax-17">Syntax</a></h3>
<pre><code class="language-neut">meta a
</code></pre>
<h3 id="semantics-17"><a class="header" href="#semantics-17">Semantics</a></h3>
<p>For every type <code>a</code>, <code>meta a</code> is compiled into the same term as <code>a</code>.</p>
<h3 id="type-18"><a class="header" href="#type-18">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
----------------
Γ ⊢ meta t: type
</code></pre>
<h3 id="note-12"><a class="header" href="#note-12">Note</a></h3>
<p><code>meta</code> is the T-necessity operator in that we can construct terms of the following types:</p>
<ul>
<li><code>(meta (a) -&gt; b, meta a) -&gt; meta b</code> (Axiom K)</li>
<li><code>(meta a) -&gt; a</code> (Axiom T)</li>
</ul>
<p>Note that <code>meta (a) -&gt; b</code> means <code>meta {(a) -&gt; b}</code> and not <code>(meta a) -&gt; b</code>.</p>
<h2 id="a"><a class="header" href="#a"><code>&amp;a</code></a></h2>
<p>Given a type <code>a: type</code>, the <code>&amp;a</code> is the type of noemata over <code>a</code>.</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

                     // 🌟
define foo-noetic(n: &amp;my-nat): int {
  case n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    foo-noetic(m)
  }
}
</code></pre>
<h3 id="syntax-18"><a class="header" href="#syntax-18">Syntax</a></h3>
<pre><code class="language-neut">&amp;t
</code></pre>
<h3 id="semantics-18"><a class="header" href="#semantics-18">Semantics</a></h3>
<p>For every type <code>a</code>, <code>&amp;a</code> is compiled into <code>base.#.imm</code>.</p>
<h3 id="type-19"><a class="header" href="#type-19">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
-----------
Γ ⊢ &amp;t: type
</code></pre>
<h3 id="note-13"><a class="header" href="#note-13">Note</a></h3>
<ul>
<li>Values of type <code>&amp;a</code> can be created using <code>on</code>.</li>
<li>Values of type <code>&amp;a</code> are expected to be used in combination with <code>case</code> or <code>*e</code>.</li>
<li>Since <code>&amp;a</code> is compiled into <code>base.#.imm</code>, values of type <code>&amp;a</code> aren't discarded or copied even when used non-linearly.</li>
<li>See the Note of <a href="terms.html#box">box</a> to see the relation between <code>&amp;a</code> and <code>meta a</code></li>
</ul>
<h2 id="box"><a class="header" href="#box"><code>box</code></a></h2>
<p><code>box e</code> can be used to &quot;lift&quot; the layer of <code>e</code>.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><code class="language-neut">define use-noema&lt;a&gt;(x: &amp;a, y: &amp;a): meta b {
  // layer 0
  // - x: &amp;a at layer 0
  // - y: a  at layer 0
  box x {
    // layer -1
    // x:  a at layer -1
    // y: &amp;a at layer 0 (cannot be used here; causes a layer error)
    x
  }
}
</code></pre>
<h3 id="syntax-19"><a class="header" href="#syntax-19">Syntax</a></h3>
<pre><code class="language-neut">box x1, ..., xn { e } // n &gt;= 0
</code></pre>
<p>We say that this <code>box</code> captures the variables <code>x1, ..., xn</code>.</p>
<h3 id="semantics-19"><a class="header" href="#semantics-19">Semantics</a></h3>
<p>Given noetic variables <code>x1: &amp;a1, ..., xn: &amp;an</code>, the term <code>box x1, ..., xn { e }</code> copies all the <code>xi</code>s and execute <code>e</code>:</p>
<pre><code class="language-neut">box x1, ..., xn { e }

↓

let x1 = copy-noema(x1);
...
let xn = copy-noema(xn);
e
</code></pre>
<h3 id="type-20"><a class="header" href="#type-20">Type</a></h3>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e1: a
------------------------------------- (□-intro)
Γ1; ...; Γn, &amp;Δ ⊢ box Δ {e1}: meta a
</code></pre>
<p>where <code>Γ1; ...; Γn</code> is a sequence of contexts.</p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>The body of <code>define</code> is defined to be at layer 0:</p>
<pre><code class="language-neut">define some-function(x: int): int {
  // here is layer 0
  // `x: int` is a variable at layer 0
  add-int(x, 1)
}
</code></pre>
<p>Since <code>box e</code> lifts the layer of <code>e</code>, if we use <code>box</code> at layer 0, the layer of <code>e</code> will become -1:</p>
<pre><code class="language-neut">define use-box(x: int): meta int {
  // here is layer 0
  box {
    // here is layer -1
    10
  }
}
</code></pre>
<p><em>In layer n, we can only use variables at the layer</em>. Thus, the following is not a valid term:</p>
<pre><code class="language-neut">define use-box-error(x: int): meta int {
  // here is layer 0
  box {
    // here is layer -1
    add-int(x, 1) // error: use of a variable at layer 0 (≠ -1)
  }
}
</code></pre>
<p>We can incorporate variables outside <code>box</code> by capturing them:</p>
<pre><code class="language-neut">define use-box-with-noema(x: &amp;int): meta int {
  // here is layer 0
  // x: &amp;int at layer 0
  box x {
    // here is layer -1
    // x: int at layer -1
    add-int(x, 1) // ok
  }
}
</code></pre>
<p>The body of this term is typed as follows:</p>
<pre><code class="language-neut">--------------
x: int ⊢ x: int // layer -1
---------------------------
x: int ⊢ add-int(x, 1): int // layer -1
-------------------------------------------- (□-intro with Δ = (x: int))
· ; x: &amp;int ⊢ box x {add-int(x, 1)}: meta int  // layer 0
</code></pre>
<p>Here, <code>·</code> is the empty context.</p>
<hr />
<p>Incidentally, the rule &quot;The body of <code>define</code> is at layer 0&quot; is not really necessary. We can simply replace the 0 with any integer.</p>
<h3 id="note-14"><a class="header" href="#note-14">Note</a></h3>
<p>Firstly, observe that the following derivation is admissible in Neut:</p>
<pre><code class="language-neut">Γ1; ...; Γn; x: a, Δ ⊢ e: b
-------------------------------- (slide)
Γ1; ...; Γn, x: meta a; Δ ⊢ e: b
</code></pre>
<p>Also, by setting <code>Δ = ·</code> in the typing rule of <code>box</code>, we obtain the following:</p>
<pre><code class="language-neut">Γ1; ...; Γn; · ⊢ e: a
-------------------------------- (□-intro')
Γ1; ...; Γn ⊢ box Δ {e}: meta a
</code></pre>
<p>Thus, we can perform the following derivation:</p>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e: a
----------------------------- (slide)
...
----------------------------- (slide)
Γ1; ...; Γn, meta Δ; · ⊢ e: a
-------------------------------------  (□-intro')
Γ1; ...; Γn, meta Δ ⊢ box {e}: meta a
</code></pre>
<p>That is to say, the following rule is admissible without using <code>&amp;</code>:</p>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e: a
------------------------------------- (□-intro-slide)
Γ1; ...; Γn, meta Δ ⊢ box {e}: meta a
</code></pre>
<p>Now, compare the above with the rule of <code>box</code>:</p>
<pre><code class="language-neut">Γ1; ...; Γn; Δ ⊢ e: a
------------------------------------- (□-intro)
Γ1; ...; Γn, &amp;Δ ⊢ box Δ {e}: meta a
</code></pre>
<p>As you can see, we can obtain <code>(□-intro)</code> from <code>(□-intro-slide)</code> by replacing <code>meta Δ</code> with <code>&amp;Δ</code>. That is to say, <code>&amp;a</code> is the &quot;structurally-defined&quot; variant of <code>meta a</code>.</p>
<p>If we write <code>meta Δ</code> instead of <code>&amp;Δ</code> in <code>(□-intro)</code>, the rule is equivalent to <code>(□-intro')</code>. By giving the &quot;structural&quot; part a name different from <code>meta</code>, the rule <code>(□-intro)</code> restricts the way how variables in <code>&amp;Δ</code> (which could have been the same as <code>meta Δ</code>) are used.</p>
<p>In this sense, <code>&amp;a</code> is the T-necessity modality defined through structural rules.</p>
<h2 id="letbox"><a class="header" href="#letbox"><code>letbox</code></a></h2>
<p>You can use <code>letbox</code> to &quot;unlift&quot; terms.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><code class="language-neut">define roundtrip(x: meta a): meta a {
  // here is layer 0
  box {
    // here is layer -1
    letbox tmp =
      // here is layer 0
      x;
    tmp
  }
}

define try-borrowing(x: int): unit {
  // here is layer 0
  // x: int (at layer 0)
  letbox tmp =
    // here is layer 1
    // (thus `x` is not available here)
    some-func(x);
  // here is layer 0
  // x: int (at layer 0)
  Unit
}
</code></pre>
<h3 id="syntax-20"><a class="header" href="#syntax-20">Syntax</a></h3>
<pre><code class="language-neut">letbox result = e1;
e2
</code></pre>
<h3 id="semantics-20"><a class="header" href="#semantics-20">Semantics</a></h3>
<pre><code class="language-neut">letbox result = e1;
e2

↓

let result = e1;
cont
</code></pre>
<h3 id="type-21"><a class="header" href="#type-21">Type</a></h3>
<pre><code class="language-neut">Γ1; ...; Γn ⊢ e1: meta a
Γ1; ...; Γn; Δ, x: a ⊢ e2: b
------------------------------------------------ (□-elim-K)
Γ1; ...; Γn; Δ ⊢ letbox x = e1; e2: b
</code></pre>
<h3 id="note-15"><a class="header" href="#note-15">Note</a></h3>
<p>Given a term <code>e1</code> at layer n + 1, <code>letbox x = e1; e2</code> is at layer n:</p>
<pre><code class="language-neut">define roundtrip(x: meta a): meta a {
  box {
    // here is layer -1 (= n)
    letbox tmp =
      // here is layer 0 (= n + 1)
      x;
    // here is layer -1 (= n)
    tmp
  }
}
</code></pre>
<p><em>In layer n, we can only use variables at the layer</em>. Thus, the following is not a valid term:</p>
<pre><code class="language-neut">define use-letbox-error(x: meta int): int {
  // here is layer 0
  // x: meta int (at layer 0)
  letbox tmp =
    // here is layer 1
    x; // error: use of a variable at layer 0 (≠ 1)
  // here is layer 0
  tmp
}
</code></pre>
<h2 id="letbox-t"><a class="header" href="#letbox-t"><code>letbox-T</code></a></h2>
<p>You can use <code>letbox-T</code> to get values from terms of type <code>meta a</code> without changing layers.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><code class="language-neut">define extract-value-from-meta(x: meta int): int {
  // here is layer 0
  // x: meta int (at layer 0)
  letbox-T tmp =
    // here is layer 0
    x; // ok
  // here is layer 0
  tmp
}
</code></pre>
<h3 id="syntax-21"><a class="header" href="#syntax-21">Syntax</a></h3>
<pre><code class="language-neut">letbox-T result = e1;
e2

letbox-T result on x1, ..., xn = e1;
e2
</code></pre>
<h3 id="semantics-21"><a class="header" href="#semantics-21">Semantics</a></h3>
<pre><code class="language-neut">letbox-T result on x1, ..., xn = e1;
e2

↓

let x1 = unsafe-cast(a1, &amp;a1, x);
...
let xn = unsafe-cast(an, &amp;an, xn);
let result = e1;
let x1 = unsafe-cast(&amp;a1, a1, x);
...
let xn = unsafe-cast(&amp;an, an, xn);
cont
</code></pre>
<h3 id="type-22"><a class="header" href="#type-22">Type</a></h3>
<pre><code class="language-neut">Γ1; ...; Γn, &amp;Δ ⊢ e1: meta a
Γ1; ...; Γn, Δ, Δ', x: a ⊢ e2: b
-------------------------------------------------- (□-elim-T)
Γ1; ...; Γn, Δ, Δ' ⊢ letbox-T x on Δ = e1; e2: b
</code></pre>
<p>Note that the layer of <code>e1</code>, <code>e2</code>, <code>letbox-T (..)</code> are the same.</p>
<h3 id="note-16"><a class="header" href="#note-16">Note</a></h3>
<p><code>letbox-T</code> doesn't alter layers:</p>
<pre><code class="language-neut">define extract-value-from-meta(x: meta int): int {
  // here is layer 0
  letbox-T tmp =
    // here is layer 0
    x;
  // here is layer 0
  tmp
}
</code></pre>
<p><code>on</code> doesn't alter the layers of variables, too:</p>
<pre><code class="language-neut">define extract-value-from-meta(x: int): int {
  // here is layer 0
  // x: int (at layer 0)
  letbox-T tmp on x =
    // here is layer 0
    // x: &amp;int (at layer 0)
    x;
  // here is layer 0
  // x: int (at layer 0)
  tmp
}
</code></pre>
<h2 id="case"><a class="header" href="#case"><code>case</code></a></h2>
<p>You can use <code>case</code> to inspect noetic ADT values or integers.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><code class="language-neut">data my-nat {
| Zero
| Succ(my-nat)
}

define foo-noetic(n: &amp;my-nat): int {
  case n {
  | Zero =&gt;
    100
  | Succ(m) =&gt;
    // the type of foo-noetic is `(&amp;my-nat) -&gt; int`
    foo-noetic(m)
  }
}
</code></pre>
<h3 id="syntax-22"><a class="header" href="#syntax-22">Syntax</a></h3>
<pre><code class="language-neut">case e1, ..., en {
| pattern-1 =&gt;
  body-1
  ...
| pattern-m =&gt;
  body-m
}
</code></pre>
<h3 id="semantics-22"><a class="header" href="#semantics-22">Semantics</a></h3>
<p>The semantics of <code>case</code> is the same as <code>match</code>, except that <code>case</code> doesn't consume ADT values.</p>
<h3 id="type-23"><a class="header" href="#type-23">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e1: a1
...
Γ ⊢ en: an

Γ, arg_{1,1}: t_{1,1}, ..., arg_{1, k_{1}}: t{1, k_{1}} ⊢ pat-1: a1
Γ, arg_{1,1}: &amp;t_{1,1}, ..., arg_{1, k_{1}}: &amp;t{1, k_{1}} ⊢ body-1: b

...

Γ, arg_{m,1}: t_{m,1}, ..., arg_{m, k_{m}}: t{m, k_{m}} ⊢ pat-m: an
Γ, arg_{m,1}: &amp;t_{m,1}, ..., arg_{m, k_{m}}: &amp;t{m, k_{m}} ⊢ body-m: b

(for all i = 1, ..., m, pat-i is a pattern for e1, ..., en)
(the sequence pat-1, ..., pat-m is a exhaustinve matching against e1, ..., en)
------------------------------------------------------------------------------
Γ ⊢ case e1, ..., en {
    | pat-1 =&gt; body-1
    ...
    | pat-m =&gt; body-m
    }: b
</code></pre>
<h3 id="note-17"><a class="header" href="#note-17">Note</a></h3>
<p>An example of the application of the typing rule of <code>case</code>:</p>
<pre><code class="language-neut">Γ ⊢ n: &amp;my-nat

Γ ⊢ Zero: my-nat // pat-1
Γ ⊢ 100: int // body-1

Γ, m: my-nat ⊢ Succ(m): my-nat // pat-2
Γ, m: &amp;my-nat ⊢ foo-noetic(m): int // body-2

(Zero and Succ(m) are patterns for n)
(the sequence Zero, Succ(m) is a exhaustinve matching against n)
------------------------------------------------------------------------------
Γ ⊢ case n {
    | Zero =&gt; 100
    | Succ(m) =&gt; foo-noetic(m)
    }: int
</code></pre>
<h2 id="thread-1"><a class="header" href="#thread-1"><code>thread</code></a></h2>
<p>A <code>thread</code> in Neut is the type of a thread (much like promises in other languages).</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-neut">thread(int) // the type of a thread that returns int

thread((int) -&gt; bool) // the type of a thread that returns (int) -&gt; bool
</code></pre>
<h3 id="syntax-23"><a class="header" href="#syntax-23">Syntax</a></h3>
<pre><code class="language-neut">thread(t)
</code></pre>
<h3 id="semantics-23"><a class="header" href="#semantics-23">Semantics</a></h3>
<p>For any type <code>t</code>, the type <code>thread(t)</code> is compiled into a pointer to a closed function that discards and copies the values of the type in the following manner:</p>
<ul>
<li>Discard <code>e: thread(t)</code>: Waits the thread <code>e</code> to finish and discard the result along the type <code>t</code>, and then returns 0</li>
<li>Copy <code>e: thread(t)</code>: Waits the thread <code>e</code> to finish, copies the result along the type <code>t</code>, creates an already-finished thread, and returns it as a clone.</li>
</ul>
<p>The type <code>t</code> is inside the internal representation of a term <code>e: thread(t)</code>. Because of that, for any <code>t</code>, <code>thread(t)</code> is compiled to the same closed function. For more, see the following Note.</p>
<h3 id="type-24"><a class="header" href="#type-24">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
----------------
Γ ⊢ thread(t): type
</code></pre>
<h3 id="note-18"><a class="header" href="#note-18">Note</a></h3>
<p>(1) The internal representation of <code>e: thread(t)</code> is a &quot;3-word + 1-byte&quot; tuple like the below:</p>
<pre><code class="language-neut">   (thread-id, t, result-value-or-none, finished)
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^
//  3-word                              1-byte
</code></pre>
<p>When a thread is created,</p>
<ul>
<li>the value of <code>result-value-or-none</code> is initialized to 0, and</li>
<li>the value of <code>finished</code> is also initialized to 0.</li>
</ul>
<p>When a thread is completed,</p>
<ul>
<li>the value <code>result-value-or-none</code> is updated to the result of the thread, and</li>
<li>the value <code>finished</code> is updated to 1.</li>
</ul>
<p>(2) As you can see from the semantics, you must use threads linearly to perform parallel computation.</p>
<p>(3) A thread in Neut is a thin layer over pthread.</p>
<h2 id="detach"><a class="header" href="#detach"><code>detach</code></a></h2>
<p>You can use <code>detach</code> to create a new thread.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><code class="language-neut">define foo(): thread(int) {
  detach {
    print(&quot;fA&quot;);
    1
  }
}

define bar(): thread(int) {
  let f =
    detach {
      print(&quot;fA&quot;);
      1
    };
  f
}
</code></pre>
<h3 id="syntax-24"><a class="header" href="#syntax-24">Syntax</a></h3>
<pre><code class="language-neut">detach {
  e
}
</code></pre>
<h3 id="semantics-24"><a class="header" href="#semantics-24">Semantics</a></h3>
<p><code>detach { e }</code> creates a new thread and starts computation of <code>e</code> in that thread.</p>
<h3 id="type-25"><a class="header" href="#type-25">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
-------------------------
Γ ⊢ detach { e }: thread(a)
</code></pre>
<h3 id="note-19"><a class="header" href="#note-19">Note</a></h3>
<ul>
<li><code>detach</code> internally uses pthread.</li>
</ul>
<h2 id="attach"><a class="header" href="#attach"><code>attach</code></a></h2>
<p>You can use <code>detach</code> to wait for a thread and get its result.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><code class="language-neut">define foo(f: thread(int)): int {
  attach { f }
}

define bar(f: thread((int) -&gt; bool)): bool {
  let k = attach { f };
  k(100)
}
</code></pre>
<h3 id="syntax-25"><a class="header" href="#syntax-25">Syntax</a></h3>
<pre><code class="language-neut">attach { e }
</code></pre>
<h3 id="semantics-25"><a class="header" href="#semantics-25">Semantics</a></h3>
<p><code>attach</code> waits given thread to finish and gets its resulting value.</p>
<p>It also <code>free</code>s the 3-word + 1-byte tuple that represents a thread after getting the result.</p>
<h3 id="type-26"><a class="header" href="#type-26">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: thread(a)
-------------------
Γ ⊢ attach { e }: a
</code></pre>
<h3 id="note-20"><a class="header" href="#note-20">Note</a></h3>
<ul>
<li><code>attach</code> internally uses pthread.</li>
</ul>
<h2 id="quote"><a class="header" href="#quote"><code>quote</code></a></h2>
<p>You can use <code>quote</code> to wrap the types of &quot;safe&quot; values by <code>meta {..}</code>.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><code class="language-neut">define quote-int(x: int): meta int {
  quote {x}
}

define quote-bool(x: bool): meta bool {
  quote {x}
}

define quote-function(f: (int) -&gt; bool): meta (int) -&gt; bool {
  quote {f} // error; won't typecheck
}
</code></pre>
<h3 id="syntax-26"><a class="header" href="#syntax-26">Syntax</a></h3>
<pre><code class="language-neut">quote {e}
</code></pre>
<h3 id="semantics-26"><a class="header" href="#semantics-26">Semantics</a></h3>
<pre><code class="language-neut">quote {e}

↓

e
</code></pre>
<h3 id="type-27"><a class="header" href="#type-27">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e: a
(a is an &quot;actual&quot; type)
-----------------------
Γ ⊢ quote {e}: meta a
</code></pre>
<p>Here, an &quot;actual&quot; type is a type that satisfies all the following conditions:</p>
<ul>
<li>It doesn't contain any free variables</li>
<li>It doesn't contain any noetic types</li>
<li>It doesn't contain any function types</li>
<li>It doesn't contain any &quot;dubious&quot; ADTs</li>
</ul>
<p>Here, a &quot;dubious&quot; ADT is something like the below:</p>
<pre><code class="language-neut">// the type `joker-x` is dubious since it contains a noetic argument
data joker-x {
| Joker-X(&amp;list(int))
}

// the type `joker-y` is dubious since it contains a functional argument
data joker-y {
| Joker-Y(int -&gt; bool)
}

// the type `joker-z` is dubious since it contains a dubious ADT argument
data joker-z {
| Joker-Z(joker-y)
}
</code></pre>
<h3 id="note-21"><a class="header" href="#note-21">Note</a></h3>
<p>(1) Unlike <code>box</code>, <code>quote</code> doesn't alter layers.</p>
<p>(2) <code>quote</code> doesn't add extra expressiveness to the type system. For example, <code>quote</code> on <code>bool</code> can be replaced with <code>box</code> as follows:</p>
<pre><code class="language-neut">define quote-bool(b: bool): meta bool {
  quote {b}
}

↓

define quote-bool(b: bool): meta bool {
  if b {
    box {True}
  } else {
    box {False}
  }
}
</code></pre>
<p><code>quote</code> on <code>either(bool, unit)</code> can also be replaced with <code>box</code> as follows:</p>
<pre><code class="language-neut">define quote-either(x: either(bool, unit)): meta either(bool, unit) {
  quote {b}
}

↓

define quote-either(x: either(bool, unit)): meta either(bool, unit) {
  match x {
  | Left(b) =&gt;
    if b {
      box {Left(True)}
    } else {
      box {Left(False)}
    }
  | Right(u) =&gt;
    box {Right(Unit)}
  }
}
</code></pre>
<p><code>quote</code> is there only for convenience.</p>
<h2 id="magic"><a class="header" href="#magic"><code>magic</code></a></h2>
<p>You can use <code>magic</code> to perform weird stuff. Using <code>magic</code> is an unsafe operation.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><code class="language-neut">// empty type
data descriptor {}

// add an element to the empty type
inline stdin: descriptor {
  magic cast(int, descriptor, 0) // 🌟 cast
}

define malloc-then-free(): unit {
  // allocates memory region (stack)
  let ptr = magic alloca(int64, 2); // allocates (64 / 8) * 2 = 16 byte

  // allocates memory region (heap)
  let size: int = 10;
  let ptr: pointer = magic external malloc(size); // 🌟 external

  // stores a value
  let value: int = 123;
  magic store(int, value, ptr); // 🌟 store

  // loads and print a value
  let value = magic load(int, ptr); // 🌟 load
  print-int(value); // =&gt; 123

  // tells the compiler to treat the content of {..} as a value
  let v =
    magic opaque-value {
      get-some-c-constant-using-FFI()
    };

  // frees the pointer and return
  magic external free(ptr); // 🌟 external

  // call types as functions
  let t: text = *&quot;hello&quot;;
  magic call-type(text, 0, t); // discard

  Unit
}

</code></pre>
<h3 id="syntax-27"><a class="header" href="#syntax-27">Syntax</a></h3>
<pre><code class="language-neut">magic cast(from-type, to-type, value)

magic store(lowtype, stored-value, address)

magic load(lowtype, address)

magic alloca(lowtype, num-of-elems)

magic opaque-value { e }

magic external func-name(e1, ..., en)

magic external func-name(e1, ..., en)(vararg-1: lowtype-1, ..., vararg-n: lowtype-n)

magic external call-type(some-type, switch, arg)
</code></pre>
<p>A &quot;lowtype&quot; is a term that reduces to one of the following:</p>
<ul>
<li><code>int1</code>, <code>int2</code>, <code>int4</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></li>
<li><code>float16</code>, <code>float32</code>, <code>float64</code></li>
<li><code>pointer</code></li>
</ul>
<p>You can also use <code>int</code> and <code>float</code> as a lowtype. These are just syntactic sugar for <code>int64</code> and <code>float64</code>, respectively.</p>
<h3 id="semantics-cast"><a class="header" href="#semantics-cast">Semantics (cast)</a></h3>
<p><code>magic cast (a, b, e)</code> casts the term <code>e</code> from the type <code>a</code> to <code>b</code>. <code>cast</code> does nothing at runtime.</p>
<h3 id="semantics-store"><a class="header" href="#semantics-store">Semantics (store)</a></h3>
<p><code>magic store(lowtype, value, address)</code> stores a value <code>value</code> to <code>address</code>. This is the same as <code>store</code> <a href="https://llvm.org/docs/LangRef.html#store-instruction">in LLVM</a>.</p>
<h3 id="semantics-load"><a class="header" href="#semantics-load">Semantics (load)</a></h3>
<p><code>magic load(lowtype, address)</code> loads a value from <code>address</code>. This is the same as <code>load</code> <a href="https://llvm.org/docs/LangRef.html#load-instruction">in LLVM</a>.</p>
<h3 id="semantics-alloca"><a class="header" href="#semantics-alloca">Semantics (alloca)</a></h3>
<p><code>magic alloca(lowtype, num-of-elems)</code> allocates a memory region on the stack frame. This is the same as <code>alloca</code> <a href="https://llvm.org/docs/LangRef.html#alloca-instruction">in LLVM</a>.</p>
<h3 id="semantics-opaque-value"><a class="header" href="#semantics-opaque-value">Semantics (opaque-value)</a></h3>
<p><code>magic opaque-value { e }</code> tells the compiler to treat the term <code>e</code> as a value. You may want to use this in combination with <code>define</code> or <code>inline</code> that don't have any explicit arguments.</p>
<h3 id="semantics-external"><a class="header" href="#semantics-external">Semantics (external)</a></h3>
<p><code>magic external func(e1, ..., en)</code> can be used to call foreign functions (or FFI). See <a href="./statements.html#foreign">foreign in Statements</a> for more information.</p>
<p><code>magic external func(e1, ..., en)(e{n+1}: lowtype1, ..., e{n+m}: lowtypem)</code> can also be used to call variadic foreign functions like printf in C. A use of such variadic <code>external</code> can be found in the core library <a href="https://github.com/vekatze/neut-core/blob/6ef2fed68a6b0b063e15350e788c82ea9371f6bb/source/text/io.nt#L43">here</a>.</p>
<h3 id="semantics-call-type"><a class="header" href="#semantics-call-type">Semantics (call-type)</a></h3>
<p>Neut compiles types into functions. The first argument of such a function is usually 0 or 1, but we can actually pass other integers using <code>call-type</code>.</p>
<p><code>magic call-type(some-type, switch, arg)</code> treats <code>some-type</code> as a function pointer and calls <code>some-type(switch, arg)</code>.</p>
<p><code>magic call-type(some-type, 0, value)</code> discards <code>value</code>.</p>
<p><code>magic call-type(some-type, 1, value)</code> copies <code>value</code> and returns a new value.</p>
<p><code>magic call-type(some-type, 2, value)</code> ignores <code>value</code> and returns an integer <code>i</code> if <code>some-type</code> is the <code>i</code>th constructor of the type <code>type-tag</code> defined <a href="https://github.com/vekatze/neut-core/blob/main/source/type-tag.nt">here</a>. For example,</p>
<ul>
<li><code>call-type(type, 2, Unit)</code> returns 1 since the tag of <code>type</code> is <code>Type</code>,</li>
<li><code>call-type(bool, 2, Unit)</code> returns 5 since the tag of <code>bool</code> is <code>Enum</code>,</li>
<li><code>call-type(list(int), 2, Unit)</code> returns 3 since the tag of <code>list(int)</code> is <code>Algebraic</code>.</li>
</ul>
<p><code>magic call-type(some-type, 3, i)</code> is defined only if <code>some-type</code> is an ADT or an enum. If <code>some-type</code> is an ADT, this term returns the number of parameters for the ADT's <code>i</code>th constructor, or <code>-1</code> if the <code>i</code>th constructor doesn't exist. If <code>some-type</code> is an enum, this term returns <code>0</code> if the <code>i</code>th constructor exists, or <code>-1</code> if not.</p>
<p><code>magic call-type(some-type, 4, value)</code> is defined only if <code>some-type</code> is an ADT or an enum. If <code>some-type</code> is an ADT, this term assumes that <code>value</code> has the following structure:</p>
<pre><code class="language-neut">(discriminant, arg-1, ..., arg-n, any, any)
</code></pre>
<p>where</p>
<pre><code class="language-neut">(discriminant, arg-1, ..., arg-n)
</code></pre>
<p>is the internal structure of terms of type <code>some-type</code>. Given that, <code>magic call-type(some-type, 4, value)</code> replaces the content of <code>value</code> as follows:</p>
<pre><code class="language-neut">(cons-name, type(arg-1), ..., type(arg-n), v1, v2)
</code></pre>
<p>where</p>
<ul>
<li><code>cons-name</code> is the constructor's name (<code>&amp;text</code>).</li>
<li><code>v1</code> is the number of data parameters.
<ul>
<li>Here, &quot;data parameters&quot; refers to the <code>a</code> in <code>data list(a) {..}</code>.</li>
</ul>
</li>
<li><code>v2</code> is 1 if and only if the constructor doesn't have parameters.
<ul>
<li>For example, <code>v2</code> for <code>Nil</code> is 1. <code>v2</code> for <code>Empty()</code> and <code>Cons(a, list(a))</code> is 0.</li>
</ul>
</li>
</ul>
<p>If <code>some-type</code> is an enum, <code>magic call-type(some-type, 4, i)</code> returns the <code>i</code>th constructor's name (<code>&amp;text</code>).</p>
<p><code>magic call-type(some-type, 4, value)</code> is intended to be used with <code>magic alloca</code>.</p>
<h3 id="type-28"><a class="header" href="#type-28">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t1: type
Γ ⊢ t2: type
Γ ⊢ e: t1
-----------------------------
Γ ⊢ magic cast(t1, t2, e): t2


(t is a lowtype)
Γ ⊢ stored-value: t
Γ ⊢ address: pointer
------------------------------------------------------
Γ ⊢ magic store(t, stored-value, address): unit


(t is a lowtype)
Γ ⊢ t: type
Γ ⊢ address: pointer
------------------------------------------------------
Γ ⊢ magic load(t, address): t

Γ ⊢ e:t
------------------------------------------------------
Γ ⊢ magic opaque-value { e }: t


Γ ⊢ e1: t1
...
Γ ⊢ en: tn
Γ ⊢ t: type
(t1 is a lowtype)
...
(tn is a lowtype)
(t is a lowtype or void)
(func is a foreign function)
--------------------------------------------------
Γ ⊢ magic external func(e1, ..., en): t


Γ ⊢ e1: t1
...
Γ ⊢ en: tn
Γ ⊢ e{n+1}: t{n+1}
...
Γ ⊢ e{n+m}: t{n+m}
Γ ⊢ t: type
(t1 is a lowtype)
...
(tm is a lowtype)
(t is a lowtype or void)
(func is a foreign function)
---------------------------------------------------------------------------------
Γ ⊢ magic external func(e1, ..., en)(e{n+1}: t{n+1}, ..., e{n+m}: t{n+m}): t


Γ ⊢ some-type: type
Γ ⊢ switch: int
------------------------------------------------------
Γ ⊢ magic call-type(some-type, switch, arg): t

</code></pre>
<h3 id="note-22"><a class="header" href="#note-22">Note</a></h3>
<p><code>call-type</code> can be used, for example, to inspect the structure of a term at runtime. The function <code>vet</code> defined <a href="https://github.com/vekatze/neut-core/blob/main/source/debug.nt">here</a>, for example, inspects its argument's structure and prints it.</p>
<h2 id="introspect"><a class="header" href="#introspect"><code>introspect</code></a></h2>
<p>You can use <code>introspect key {..}</code> to introspect the compiler's configuration.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><code class="language-neut">define arch-dependent-constant(): int {
  introspect architecture {
  | arm64 =&gt;
    1
  | amd64 =&gt;
    2
  }
}

define os-dependent-constant(): int {
  introspect operating-system {
  | linux =&gt;
    1
  | default =&gt;
    // `2` is returned if target-os != linux
    2
  }
}
</code></pre>
<h3 id="syntax-28"><a class="header" href="#syntax-28">Syntax</a></h3>
<pre><code class="language-neut">introspect key {
| value-1 =&gt;
  e1
  ...
| value-n =&gt;
  en
}
</code></pre>
<p>You can use the following configuration <code>key</code>s and configuration <code>value</code>s:</p>
<div class="table-wrapper"><table><thead><tr><th>Configuration Key</th><th>Configuration Value</th></tr></thead><tbody>
<tr><td><code>architecture</code></td><td><code>amd64</code> or <code>arm64</code></td></tr>
<tr><td><code>operating-system</code></td><td><code>linux</code> or <code>darwin</code></td></tr>
<tr><td><code>build-mode</code></td><td><code>develop</code> or <code>release</code></td></tr>
</tbody></table>
</div>
<p>You can also use <code>default</code> as a configuration value to represent a fallback case.</p>
<h3 id="semantics-27"><a class="header" href="#semantics-27">Semantics</a></h3>
<p>Firstly, <code>introspect key {v1 =&gt; e1 | ... | vn =&gt; en}</code> looks up the configuration value <code>v</code> of the compiler by <code>key</code>. Then it reads the configuration values <code>v1</code>, ..., <code>vn</code> in this order to find <code>vk</code> that is equal to the <code>v</code>. If such a <code>vk</code> is found, <code>introspect</code> executes the corresponding clause <code>ek</code>. If no such <code>vk</code> is found, <code>introspect</code> will report a compilation error.</p>
<p>The configuration value <code>default</code> is equal to any configuration values.</p>
<h3 id="type-29"><a class="header" href="#type-29">Type</a></h3>
<pre><code class="language-neut">(key is a configuration key)

(v1 is a configuration value)
Γ ⊢ e1: a

...

(vn is a configuration value)
Γ ⊢ en: a
------------------------------------------
Γ ⊢ introspect key {
    | v1 =&gt; e1
      ...
    | vn =&gt; en
    }: a
</code></pre>
<h3 id="note-23"><a class="header" href="#note-23">Note</a></h3>
<ul>
<li>The branching of an <code>introspect</code> is resolved at compile-time.</li>
</ul>
<h2 id="include-text"><a class="header" href="#include-text"><code>include-text</code></a></h2>
<p>You can use <code>include-text</code> to embed the content of a static file into a source file at compile time.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><code class="language-neut">import {
  static {some-file}
}

define use-some-file(): unit {
  let t: &amp;text = include-text(some-file);
  print(t)
}
</code></pre>
<h3 id="syntax-29"><a class="header" href="#syntax-29">Syntax</a></h3>
<pre><code class="language-neut">include-text(key)
</code></pre>
<h3 id="semantics-28"><a class="header" href="#semantics-28">Semantics</a></h3>
<p>The compiler expands <code>include-text(foo)</code> into the content of <code>foo</code> at compile time.</p>
<p>If <code>foo</code> isn't a key of a UTF-8 file, <code>include-text(foo)</code> reports a compilation error.</p>
<h3 id="type-30"><a class="header" href="#type-30">Type</a></h3>
<pre><code class="language-neut">(Γ is a context)    (k is a static file's key)
----------------------------------------------
Γ ⊢ include-text(k): &amp;text
</code></pre>
<h3 id="note-24"><a class="header" href="#note-24">Note</a></h3>
<p>You may also want to read <a href="modules.html#static">the section on static files in Modules</a>.</p>
<h2 id="admit-1"><a class="header" href="#admit-1"><code>admit</code></a></h2>
<p>You can use <code>admit</code> to suppress the type checker and sketch the structure of your program.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><code class="language-neut">define my-complex-function(): unit {
  admit
}
</code></pre>
<h3 id="syntax-30"><a class="header" href="#syntax-30">Syntax</a></h3>
<pre><code class="language-neut">admit
</code></pre>
<h3 id="semantics-29"><a class="header" href="#semantics-29">Semantics</a></h3>
<p>Evaluating <code>admit</code> will exit the program, displaying a message like the following:</p>
<pre><code class="language-text">admit: /path/to/file.nt:1:2
</code></pre>
<p>When <code>admit</code> exits a program, the exit code is 1.</p>
<h3 id="type-31"><a class="header" href="#type-31">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ t: type
------------
Γ ⊢ admit: t
</code></pre>
<h3 id="note-25"><a class="header" href="#note-25">Note</a></h3>
<ul>
<li><code>admit</code> is the <code>undefined</code> in Haskell.</li>
<li><code>admit</code> is intended to be used ephemerally during development.</li>
</ul>
<h2 id="assert-1"><a class="header" href="#assert-1"><code>assert</code></a></h2>
<p>You can use <code>assert</code> to ensure that a condition is satisfied at run-time.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><code class="language-neut">define fact(n: int): int {
  assert &quot;the input must be non-negative&quot; {
    ge-int(n, 0)
  };
  if eq-int(n, 0) {
    1
  } else {
    mul-int(n, fact(sub-int(n, 1)))
  }
}
</code></pre>
<h3 id="syntax-31"><a class="header" href="#syntax-31">Syntax</a></h3>
<pre><code class="language-neut">assert &quot;any-string&quot; {
  e
}
</code></pre>
<h3 id="semantics-30"><a class="header" href="#semantics-30">Semantics</a></h3>
<p>If the <a href="./commands.html#--mode">build mode</a> is <code>release</code>, <code>assert</code> does nothing.</p>
<p>Otherwise, <code>assert &quot;description&quot; { condition }</code> evaluates <code>condition</code> and checks if it is <code>True</code>. If it is <code>True</code>, the <code>assert</code> simply evaluates to <code>Unit</code>. Otherwise, it reports that the assertion <code>&quot;description&quot;</code> failed and exits the execution of the program with the exit code <code>1</code>.</p>
<h3 id="type-32"><a class="header" href="#type-32">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ condition: bool
--------------------------------------------
Γ ⊢ assert &quot;description&quot; { condition }: unit
</code></pre>
<h2 id="_"><a class="header" href="#_"><code>_</code></a></h2>
<p><code>_</code> is a hole that must be inferred by the type checker.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-neut">define id(a: type, x: a): a {
  x
}

define use-hole(): unit {
  id(_, Unit) // ← using a hole (inferred to be `unit`)
}
</code></pre>
<h3 id="syntax-32"><a class="header" href="#syntax-32">Syntax</a></h3>
<pre><code class="language-neut">_
</code></pre>
<h3 id="semantics-31"><a class="header" href="#semantics-31">Semantics</a></h3>
<p><code>_</code> is a hole that must be inferred by the type checker. If the type checker resolves a hole into a term <code>e</code>, this hole behaves the same as <code>e</code>. If the type checker can't resolve a hole, the type checker reports a compilation error.</p>
<h3 id="type-33"><a class="header" href="#type-33">Type</a></h3>
<pre><code class="language-neut">Γ ⊢ e[tmp := e1]: a
-------------------
Γ ⊢ e[tmp := _]: a
</code></pre>
<h3 id="note-26"><a class="header" href="#note-26">Note</a></h3>
<p>Please do not confuse a hole with the <code>_</code> in <code>let _ = e1; e2</code>.</p>
<h2 id="on"><a class="header" href="#on"><code>on</code></a></h2>
<p><code>let x on y = e1; e2</code> can be used to introduce noetic values in a specific scope.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-neut">define play-with-let-on(): int {
  let xs: list(int) = List[1, 2, 3];
  let len on xs =
    // the type of `xs` is `&amp;list(int)` here
    length(xs);
  // the type of `xs` is `list(int)` here
  add-int(len, 42)
}
</code></pre>
<h3 id="syntax-33"><a class="header" href="#syntax-33">Syntax</a></h3>
<pre><code class="language-neut">let y on x1, ..., xn = e1;
e2
</code></pre>
<h3 id="semantics-32"><a class="header" href="#semantics-32">Semantics</a></h3>
<pre><code class="language-neut">let result on x1, ..., xn = e1;
e2

// ↓ desugar

letbox-T result on x1, ..., xn = quote {e1};
e2
</code></pre>
<h3 id="type-34"><a class="header" href="#type-34">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="e"><a class="header" href="#e"><code>*e</code></a></h2>
<p>You can use <code>*e</code> to create a non-noetic value from a noetic value.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><code class="language-neut">define clone-list&lt;a&gt;(xs: &amp;list(a)): list(a) {
  case xs {
  | Nil =&gt;
    Nil
  | Cons(y, ys) =&gt;
    Cons(*y, clone-list(ys))
  }
}
</code></pre>
<h3 id="syntax-34"><a class="header" href="#syntax-34">Syntax</a></h3>
<pre><code class="language-neut">*e
</code></pre>
<h3 id="semantics-33"><a class="header" href="#semantics-33">Semantics</a></h3>
<pre><code class="language-neut">*e

↓

embody(e)
</code></pre>
<p>where the function <code>embody</code> is defined in the core library as follows:</p>
<pre><code class="language-neut">// core.box

// □A -&gt; A (Axiom T)
inline axiom-T&lt;a&gt;(x: meta a): a {
  letbox-T x' = x;
  x'
}

inline embody&lt;a&gt;(x: &amp;a): a {
  axiom-T(box x {x}) // ← this `box` copies the content of `x`
}
</code></pre>
<h3 id="type-35"><a class="header" href="#type-35">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-27"><a class="header" href="#note-27">Note</a></h3>
<p>Intuitively, given a term <code>e: &amp;a</code>, <code>*e: a</code> is a clone of the content of <code>e</code>.</p>
<p>This clone is created by copying the content along the type <code>a</code>.</p>
<p>The original content is kept intact.</p>
<h2 id="if-1"><a class="header" href="#if-1"><code>if</code></a></h2>
<p>You can use <code>if</code> as in other languages.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><code class="language-neut">define foo(b1: bool): unit {
  if b1 {
    print(&quot;hey&quot;)
  } else {
    print(&quot;yo&quot;)
  }
}

define bar(b1: bool, b2: bool): unit {
  let tmp =
    if b1 {
      &quot;hey&quot;
    } else-if b2 {
      &quot;yo&quot;
    } else {
      &quot;pohe&quot;
    };
  print(tmp)
}
</code></pre>
<h3 id="syntax-35"><a class="header" href="#syntax-35">Syntax</a></h3>
<pre><code class="language-neut">if b1 { e1 } else-if b2 { e2 }  ... else-if b_{n-1} { e_{n-1} } else { en }
</code></pre>
<h3 id="semantics-34"><a class="header" href="#semantics-34">Semantics</a></h3>
<p><code>if</code> is the following syntactic sugar:</p>
<pre><code class="language-neut">if b1 { e1 } else-if b2 { e2 }  ... else-if b_{n-1} { e_{n-1} } else { en }

↓

match b1 {
| True =&gt; e1
| False =&gt;
  match b2 {
  | True =&gt; e2
  | False =&gt;
    ...
    match b_{n-1} {
    | True =&gt; e_{n-1}
    | False =&gt; en
    }
  }
}
</code></pre>
<h3 id="type-36"><a class="header" href="#type-36">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="when-cond--e-"><a class="header" href="#when-cond--e-"><code>when cond { e }</code></a></h2>
<p>You can use <code>when cond { e }</code> to perform <code>e</code> only when <code>cond</code> is true.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><code class="language-neut">define foo(b1: bool): unit {
  when b1 {
    print(&quot;hey&quot;)
  }
}

</code></pre>
<h3 id="syntax-36"><a class="header" href="#syntax-36">Syntax</a></h3>
<pre><code class="language-neut">when cond {
  e
}
</code></pre>
<h3 id="semantics-35"><a class="header" href="#semantics-35">Semantics</a></h3>
<p><code>when</code> is the following syntactic sugar:</p>
<pre><code class="language-neut">when cond {
  e
}

↓

if cond {
  e
} else {
  Unit
}
</code></pre>
<h3 id="type-37"><a class="header" href="#type-37">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="e1-e2"><a class="header" href="#e1-e2"><code>e1; e2</code></a></h2>
<p>You can use <code>e1; e2</code> to perform sequential operations.</p>
<h3 id="example-39"><a class="header" href="#example-39">Example</a></h3>
<pre><code class="language-neut">define foo(): unit {
  print(&quot;hello&quot;);
  print(&quot;, &quot;);
  print(&quot;world!&quot;);
  print(&quot;\n&quot;)
}
</code></pre>
<h3 id="syntax-37"><a class="header" href="#syntax-37">Syntax</a></h3>
<pre><code class="language-neut">e1;
e2
</code></pre>
<h3 id="semantics-36"><a class="header" href="#semantics-36">Semantics</a></h3>
<p><code>e1; e2</code> is the following syntactic sugar:</p>
<pre><code class="language-neut">let _: unit = e1;
e2
</code></pre>
<h3 id="type-38"><a class="header" href="#type-38">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="try-x--e1-e2"><a class="header" href="#try-x--e1-e2"><code>try x = e1; e2</code></a></h2>
<p><code>try</code> is a shorthand for <code>match</code> + <code>either</code>.</p>
<h3 id="example-40"><a class="header" href="#example-40">Example</a></h3>
<pre><code class="language-neut">define get-value-or-fail(): either(error, int) {
  //  ...
}

define foo(): either(error, int) {
  try x1 = get-value-or-fail();
  try x2 = get-value-or-fail();
  Right(add-int(x1, x2))
}
</code></pre>
<h3 id="syntax-38"><a class="header" href="#syntax-38">Syntax</a></h3>
<pre><code class="language-neut">try x = e1;
e2
</code></pre>
<h3 id="semantics-37"><a class="header" href="#semantics-37">Semantics</a></h3>
<p><code>try x = e1; e2</code> is a shorthand of the below:</p>
<pre><code class="language-neut">match e1 {
| Left(err) =&gt;
  Left(err)
| Right(x) =&gt;
  e2
}
</code></pre>
<h3 id="type-39"><a class="header" href="#type-39">Type</a></h3>
<p>Derived from the desugared form.</p>
<h3 id="note-28"><a class="header" href="#note-28">Note</a></h3>
<p>The definition of <code>either</code> is as follows:</p>
<pre><code class="language-neut">data either(a, b) {
| Left(a)
| Right(b)
}
</code></pre>
<h2 id="tie-x--e1-e2"><a class="header" href="#tie-x--e1-e2"><code>tie x = e1; e2</code></a></h2>
<p>You can use <code>tie</code> as a &quot;noetic&quot; <code>let</code>.</p>
<h3 id="example-41"><a class="header" href="#example-41">Example</a></h3>
<pre><code class="language-neut">data config {
| Config(
    foo: int,
    bar: bool,
  )
}

define use-noetic-config(c: &amp;config): int {
  tie Config of {foo} = c;
  *foo
}
</code></pre>
<h3 id="syntax-39"><a class="header" href="#syntax-39">Syntax</a></h3>
<pre><code class="language-neut">tie x = e1;
e2
</code></pre>
<h3 id="semantics-38"><a class="header" href="#semantics-38">Semantics</a></h3>
<p><code>tie x = e1; e2</code> is a shorthand of the below:</p>
<pre><code class="language-neut">case e1 {
| x =&gt;
  e2
}
</code></pre>
<h3 id="type-40"><a class="header" href="#type-40">Type</a></h3>
<p>Derived from the desugared form.</p>
<h2 id="pin-x--e1-e2"><a class="header" href="#pin-x--e1-e2"><code>pin x = e1; e2</code></a></h2>
<p>You can use <code>pin</code> to create a value and use it as a noema.</p>
<h3 id="example-42"><a class="header" href="#example-42">Example</a></h3>
<pre><code class="language-neut">// without `pin`
define foo(): unit {
  let xs = make-list(123);
  let result on xs = some-func(xs);
  let _ = xs;
  result
}

↓

// with `pin`
define foo(): unit {
  pin xs = make-list(123);
  some-func(xs)
}
</code></pre>
<h3 id="syntax-40"><a class="header" href="#syntax-40">Syntax</a></h3>
<pre><code class="language-neut">pin x = e1;
e2
</code></pre>
<h3 id="semantics-39"><a class="header" href="#semantics-39">Semantics</a></h3>
<pre><code class="language-neut">pin x = e1;
e2

↓

let x = e1;
let tmp on x = e2;
let _ = x;
tmp
</code></pre>
<h2 id="t"><a class="header" href="#t"><code>?t</code></a></h2>
<p>You can use <code>?t</code> to represent an optional type.</p>
<h3 id="example-43"><a class="header" href="#example-43">Example</a></h3>
<pre><code class="language-neut">define foo(x: int): ?int {
  if eq-int(x, 0) {
    Right(100)
  } else {
    Left(Unit)
  }
}
</code></pre>
<h3 id="syntax-41"><a class="header" href="#syntax-41">Syntax</a></h3>
<pre><code class="language-neut">?t
</code></pre>
<h3 id="semantics-40"><a class="header" href="#semantics-40">Semantics</a></h3>
<p><code>?t</code> is the following syntactic sugar:</p>
<pre><code class="language-neut">?t

↓

either(unit, t)
</code></pre>
<h3 id="type-41"><a class="header" href="#type-41">Type</a></h3>
<p>Derived from the syntactic sugar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives"><a class="header" href="#primitives">Primitives</a></h1>
<h2 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of Contents</a></h2>
<ul>
<li><a href="primitives.html#primitive-types-and-functions">Primitive Types and Functions</a></li>
<li><a href="primitives.html#core-types-and-functions">Core Types and Functions</a></li>
</ul>
<h2 id="primitive-types-and-functions"><a class="header" href="#primitive-types-and-functions">Primitive Types and Functions</a></h2>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<p>Neut supports integers and floats. More specifically, the following types are supported:</p>
<ul>
<li>integer types: <code>int1, int2, int4, int8, int16, int32, int64</code></li>
<li>float types: <code>float16, float32, float64</code></li>
</ul>
<p>You can also use <code>int</code> and <code>float</code>. These are just syntactic sugar for <code>int64</code> and <code>float64</code>, respectively.</p>
<h3 id="primitive-functions"><a class="header" href="#primitive-functions">Primitive Functions</a></h3>
<p>These primitive types have a lot of primitive functions from LLVM:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>integers</th><th>floats</th></tr></thead><tbody>
<tr><td>arithmetics</td><td>add, sub, mul, div, rem, udiv, urem, or, xor, shl, lshr, ashr</td><td>neg, add, sub, mul, div, rem</td></tr>
<tr><td>comparison</td><td>eq, ne, gt, ge, lt, le, ugt, uge, ult, ule</td><td>eq, gt, ge, lt, le, ne, ord, ueq, ugt, uge, ult, ule, une, uno, false, true</td></tr>
</tbody></table>
</div>
<p>For example, <code>add-int32</code>, <code>neg-float64</code>, <code>eq-int64</code>, and <code>gt-float32</code> are available.</p>
<p>Neut uses LLVM's integer types and float types for its primitive types. Thus, the primitive integer types in Neut are signless. More specifically, the signedness of an integer type in Neut resides in functions, not values.</p>
<p>For example, <code>div-int64</code> interprets its two arguments as signed integers and returns its (signed) result. <code>udiv-int64</code> interprets its two arguments as unsigned integers and returns its (unsigned) result. Integer functions prefixed with <code>u</code> are for unsigned functions.</p>
<p>The internal representation of the integer types in Neut is the same as that of LLVM. Therefore, they are based on the two's complement representation. That is why Neut doesn't have something like <code>uadd-int64</code>. The <code>u</code>-prefixed integer functions are there only when we need different behaviors for different signednesses.</p>
<p>The following conversion functions are also available: <code>trunc</code>, <code>zext</code>, <code>sext</code>, <code>fptrunc</code>, <code>fpext</code>, <code>fptoui</code>, <code>fptosi</code>, <code>uitofp</code>, and <code>sitofp</code>.</p>
<p>For example, <code>trunc-int64-int32</code>, <code>zext-int8-int32</code>, <code>fptoui-float32-int64</code>, and <code>uitofp-int64-float64</code> are available.</p>
<p>For their detailed behaviors, please refer to <a href="https://llvm.org/docs/LangRef.html">the LLVM language reference</a>.</p>
<div class="info-block">
<p>Primitive functions for <code>int</code> and <code>float</code> are also available. For example, you can use <code>div-int</code>, <code>eq-int</code>, <code>add-float</code>, etc.</p>
</div>
<h2 id="core-types-and-functions"><a class="header" href="#core-types-and-functions">Core Types and Functions</a></h2>
<p>The <a href="./modules.html#preset">preset</a> of the core library (something like Prelude in other languages) is imported automatically and provides some types and functions. These types and functions can also be used as primitives. Things like the below are defined in the library:</p>
<pre><code class="language-neut">data null {}

data unit {
| Unit
}

data bool {
| False
| True
}

data list(a) {
| Nil
| Cons(a, list(a))
}

// you can also write `?a` instead of `either(unit, a)`
data either(a, b) {
| Left(a)
| Right(b)
}

data pair(a, b) {
| Pair(left: a, right: b)
}
</code></pre>
<p>Functions for those types are also defined in the library. For more, please see <a href="https://github.com/vekatze/neut-core/tree/main/source">the source of the core library</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basis"><a class="header" href="#basis">Basis</a></h1>
<h2 id="table-of-contents-9"><a class="header" href="#table-of-contents-9">Table of Contents</a></h2>
<ul>
<li><a href="./basis.html#on-executing-types">On Executing Types</a></li>
<li><a href="./basis.html#allocation-canceling">Allocation Canceling</a></li>
<li><a href="./basis.html#name-resolution">Name Resolution</a></li>
<li><a href="./basis.html#leading-bars-and-trailing-commas">Leading Bars and Trailing Commas</a></li>
<li><a href="./basis.html#compiler-configuration">Compiler Configuration</a></li>
<li><a href="./basis.html#other-basic-facts">Other Basic Facts</a></li>
</ul>
<h2 id="on-executing-types"><a class="header" href="#on-executing-types">On Executing Types</a></h2>
<p>A type in Neut is compiled into a pointer to a binary function like the below (pseudo-code):</p>
<pre><code class="language-neut">define discard-or-copy-value(action-selector, value) {
  if eq-int(action-selector, 0) {
    discard-value(value);
    Unit
  } else {
    let new-value = copy-value(value);
    new-value
  }
}
</code></pre>
<p>These functions are then used to discard/copy values when necessary.</p>
<h3 id="discarding-values"><a class="header" href="#discarding-values">Discarding Values</a></h3>
<p>Let's see how types are executed when discarding values. For example, consider the following code:</p>
<pre><code class="language-neut">define foo(xs: list(int)): unit {
  Unit
}
</code></pre>
<p>Note that the variable <code>xs</code> isn't used. Because of that, the compiler translates the code above into the below (pseudo-code; won't typecheck):</p>
<pre><code class="language-neut">define foo(xs: list(int)): unit {
  let f = list(int);
  f(0, xs); // passing `0` to discard `xs`
  Unit
}
</code></pre>
<p>Note that the above example executes the type <code>list(int)</code> as a function.</p>
<h3 id="copying-values"><a class="header" href="#copying-values">Copying Values</a></h3>
<p>Let's see how types are executed when copying values. For example, consider the following code:</p>
<pre><code class="language-neut">define foo(!xs: list(int)): unit {
  some-func(!xs, !xs)
}
</code></pre>
<p>Note that the variable <code>!xs</code> is used twice. Because of that, the compiler translates the above code into the below (pseudo-code; won't typecheck):</p>
<pre><code class="language-neut">define foo(!xs: list(int)): unit {
  let f = list(int);
  let xs-clone = f(1, !xs); // passing `1` to copy `xs`
  some-func(xs-clone, !xs)
}
</code></pre>
<p>Note that the above example executes the type <code>list(int)</code> as a function.</p>
<p>You must prefix a variable with <code>!</code> if the variable needs to be copied. You must also prefix free variables in a term-level <code>define</code> with <code>!</code> if they cannot be copied for free.</p>
<p>The prefix <code>!</code> is unnecessary if the variable can be copied for free.</p>
<h3 id="on-immediate-values"><a class="header" href="#on-immediate-values">On Immediate Values</a></h3>
<p>We don't have to discard immediates like integers or floats because their internal representations don't depend on memory-related operations like <code>malloc</code> or <code>free</code>. Because of that, &quot;discarding&quot; immediate values does nothing. Also, &quot;copying&quot; immediate values means reusing original values.</p>
<p>More specifically, the type of an immediate is compiled into a pointer to the following function (pseudo-code):</p>
<pre><code class="language-neut">inline discard-or-copy-immediate(selector, value) {
  if eq-int(selector, 0) {
    0     // discard: we have nothing to do on `value`
  } else {
    value // copy: we can simply reuse the immediate `value`
  }
}
</code></pre>
<p>These fake discarding/copying are optimized away at compile-time.</p>
<p>Also, this function is internally called <code>&quot;base.#.imm&quot;</code>. Try compiling your project as follows:</p>
<pre><code class="language-sh">neut build TARGET --emit llvm --skip-link
</code></pre>
<p>Then, take a peek at the <code>build</code> directory. You'll find the name here and there.</p>
<div class="info-block">
<p>Since every type is translated into a pointer to a function, a type is an immediate value. Thus, <code>type</code> is compiled into <code>base.#.imm</code>.</p>
</div>
<h2 id="allocation-canceling"><a class="header" href="#allocation-canceling">Allocation Canceling</a></h2>
<p>Thanks to its static nature, memory allocation in Neut can sometimes be optimized away. Consider the following code:</p>
<pre><code class="language-neut">data int-list {
| Nil
| Cons(int, int-list)
}

// [1, 5, 9] =&gt; [2, 6, 10]
define increment(xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    Nil
  // ↓ the `Cons` clause
  | Cons(x, rest) =&gt;
    Cons(add-int(x, 1), increment(rest))
  }
}
</code></pre>
<p>The expected behavior of the <code>Cons</code> clause above would be something like the following:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li><code>free</code> the outer tuple of <code>xs</code></li>
<li>calculate <code>add-int(x, 1)</code> and <code>increment(rest)</code></li>
<li>allocate memory region using <code>malloc</code> to return the result</li>
<li>store the calculated values to the pointer and return it</li>
</ol>
<p>However, since the size of <code>Cons(x, rest)</code> and <code>Cons(add-int(x, 1), increment(rest))</code> are known to be the same at compile-time, the pair of <code>free</code> and <code>malloc</code> should be able to be optimized away, as follows:</p>
<ol>
<li>obtain <code>x</code> and <code>rest</code> from <code>xs</code></li>
<li>calculate <code>add-int(x, 1)</code> and <code>increment(rest)</code></li>
<li>store the calculated values to <code>xs</code> (overwrite)</li>
</ol>
<p>And Neut does this optimization. When a <code>free</code> is required, Neut looks for a <code>malloc</code> that is the same size and optimizes away such a pair if one exists. The resulting assembly code thus performs in-place updates.</p>
<h3 id="allocation-canceling-and-branching"><a class="header" href="#allocation-canceling-and-branching">Allocation Canceling and Branching</a></h3>
<p>This optimization &quot;penetrates&quot; branching. For example, consider the following:</p>
<pre><code class="language-neut">// (an `insert` function in bubble sort)
define insert(v: int, xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    // ...
  | Cons(y, ys) =&gt;           // (X)
    if gt-int(v, y) {
      Cons(y, insert(v, ys)) // (Y)
    } else {
      Cons(v, Cons(y, ys))   // (Z)
    }
  }
}
</code></pre>
<p>At point <code>(X)</code>, <code>free</code> against <code>xs</code> is required. However, this <code>free</code> can be canceled since <code>malloc</code>s of the same size can be found in all the possible branches (here, <code>(Y)</code> and <code>(Z)</code>). Thus, in the code above, the deallocation of <code>xs</code> at <code>(X)</code> is removed, and the memory region of <code>xs</code> is reused at <code>(Y)</code> and <code>(Z)</code>, resulting in an in-place update of <code>xs</code>.</p>
<p>On the other hand, consider rewriting the code above into something like the following:</p>
<pre><code class="language-neut">define foo(v: int, xs: int-list): int-list {
  match xs {
  | Nil =&gt;
    // ...
  | Cons(y, ys) =&gt;         // (X')
    if gt-int(v, y) {
      Nil                  // (Y')
    } else {
      Cons(v, Cons(y, ys)) // (Z')
    }
  }
}
</code></pre>
<p>At this time, the <code>free</code> against <code>xs</code> at <code>(X')</code> can't be optimized away since there exists a branch (namely, <code>(Y')</code>) that doesn't perform <code>malloc</code> that is of the same size as <code>xs</code>.</p>
<h2 id="name-resolution"><a class="header" href="#name-resolution">Name Resolution</a></h2>
<h3 id="resolving-module-aliases"><a class="header" href="#resolving-module-aliases">Resolving Module Aliases</a></h3>
<p>Let's see how the name of a module alias is resolved. Here, the name of a module alias is something like the <code>core</code> in <code>core.text.io.get-line</code>:</p>
<pre><code class="language-neut">import {
  core.text.io,
}

define use-external-module-function(): text {
           // 🌟
  let value = core.text.io.get-line();
  ...
}
</code></pre>
<p>When compiling a module, the compiler reads the field <code>dependency</code> in the <code>module.ens</code> and adds correspondences like the below to its internal state:</p>
<pre><code class="language-neut">// alias =&gt; (the digest of the library)
core =&gt; &quot;jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o&quot;
foo-module =&gt; &quot;JEpjuzZ0rlqxiVuCnD000jEKIA_Y6ku1L3J139h3M6Q&quot;
bar-module =&gt; &quot;zptXghmyD5druBl8kx2Qrei6O6fDsKCA7z2KoHp1aqA&quot;
...
</code></pre>
<p>The compiler then resolves aliases like below:</p>
<pre><code class="language-text">core.text.io.get-line

↓

jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o=.text.io.get-line

--------------

foo-module.path.to.some.file.my-function

↓

JEpjuzZ0rlqxiVuCnD000jEKIA_Y6ku1L3J139h3M6Q.path.to.some.file.my-function

--------------

...
</code></pre>
<h3 id="resolving-this"><a class="header" href="#resolving-this">Resolving <code>this</code></a></h3>
<p>Let's see how <code>this</code> is resolved. Here, <code>this</code> is a component of a global variables, like the below:</p>
<pre><code class="language-neut">import {
  this.path.to.file,
}

define use-my-function(): text {
           // 🌟
  let value = this.path.to.file.my-function();
  ...
}
</code></pre>
<p>The first thing to note here is that every module is marked as &quot;main&quot; or &quot;library&quot; when running compilation. The main module is the module in which <code>neut build</code> is executed. Library modules are all the other modules that are necessary for compilation.</p>
<p>All the occurrences of <code>this</code> in the main module are kept intact during compilation. Thus, the resulting assembly file contains symbols like <code>this.foo.bar</code>.</p>
<p>On the other hand, all the occurrences of <code>this</code> in a library module are resolved into their corresponding digests. More specifically, when processing a library module, the compiler adds correspondences like the below:</p>
<pre><code class="language-neut">// this =&gt; (the digest of the library)
this =&gt; &quot;jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o&quot;
</code></pre>
<p>The compiler then resolves <code>this</code> like below:</p>
<pre><code class="language-text">this.text.io.get-line

↓

jIx5FxfoymZ-X0jLXGcALSwK4J7NlR1yCdXqH2ij67o=.text.io.get-line
</code></pre>
<p>Thus, the resulting assembly file contains symbols like the above.</p>
<h2 id="leading-bars-and-trailing-commas"><a class="header" href="#leading-bars-and-trailing-commas">Leading Bars and Trailing Commas</a></h2>
<h3 id="comma-separated-sequences-and-sequences"><a class="header" href="#comma-separated-sequences-and-sequences">Comma-Separated Sequences (And-Sequences)</a></h3>
<p>Every comma-separated sequence like <code>a, b, c</code> can have a trailing comma like <code>a, b, c,</code>.</p>
<p>If a comma-separated sequence has a trailing comma, the sequence is formatted vertically by the built-in formatter.</p>
<h3 id="bar-separated-sequences-or-sequences"><a class="header" href="#bar-separated-sequences-or-sequences">Bar-Separated Sequences (Or-Sequences)</a></h3>
<p>Every bar-separated sequence like <code>a | b | c</code> can have a leading bar like <code>| a | b | c</code>.</p>
<p>If a bar-separated sequence has a leading bar, the sequence is formatted vertically by the built-in formatter.</p>
<h2 id="compiler-configuration"><a class="header" href="#compiler-configuration">Compiler Configuration</a></h2>
<p>The behavior of the compiler can be adjusted using the following environment variables:</p>
<div class="table-wrapper"><table><thead><tr><th>Environment Variable</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>NEUT_CLANG</code></td><td>the command to call <code>clang</code></td></tr>
<tr><td><code>NEUT_CORE_MODULE_DIGEST</code></td><td>the digest of the core module</td></tr>
<tr><td><code>NEUT_CORE_MODULE_URL</code></td><td>the URL of the core module</td></tr>
</tbody></table>
</div>
<p>The default values are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Environment Variable</th><th>Default Value</th></tr></thead><tbody>
<tr><td><code>NEUT_CLANG</code></td><td><code>clang</code></td></tr>
<tr><td><code>NEUT_CORE_MODULE_DIGEST</code></td><td>(undefined; you must set one)</td></tr>
<tr><td><code>NEUT_CORE_MODULE_URL</code></td><td>(undefined; you must set one)</td></tr>
</tbody></table>
</div>
<h2 id="other-basic-facts"><a class="header" href="#other-basic-facts">Other Basic Facts</a></h2>
<ul>
<li>Neut is call-by-value</li>
<li>Neut is impure</li>
<li>The type of <code>main</code> must be <code>() -&gt; unit</code></li>
<li>A module named <code>core</code> is treated specially (treated as the &quot;prelude&quot; library)
<ul>
<li>Syntactic constructs like <code>List[1, 2, 3]</code> depends on functions in <code>core</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-next"><a class="header" href="#what-is-next">What is Next?</a></h1>
<p>You can improve this book, this language, or this world by:</p>
<ul>
<li>Writing libraries or executables</li>
<li>Opening PRs to fix typos, grammatical errors, or other issues in this book</li>
<li>Finding bugs and reporting them on GitHub, hopefully with PRs</li>
<li>Sharing the language on SNS</li>
<li>Starring the <a href="https://github.com/vekatze/neut">repository</a></li>
<li>...</li>
</ul>
<h2 id="introducing-some-libraries"><a class="header" href="#introducing-some-libraries">Introducing Some Libraries</a></h2>
<p>I've been enjoying this language by myself and have written several libraries:</p>
<ul>
<li><a href="https://github.com/vekatze/argot">argot</a> - An option parser</li>
<li><a href="https://github.com/vekatze/ars-postgres">ars-postgres</a> - A PostgreSQL client over libpq</li>
<li><a href="https://github.com/vekatze/dotenv-nt">dotenv</a> - Locates and loads env files</li>
<li><a href="https://github.com/vekatze/http-base-nt">http-base</a> - Provides basic HTTP entities</li>
<li><a href="https://github.com/vekatze/json-nt">json</a> - Handles JSON values</li>
<li><a href="https://github.com/vekatze/noa">noa</a> - A test kit emphasizing the property-based approach</li>
<li><a href="https://github.com/vekatze/path-nt">path</a> - Provides path-related operations</li>
<li><a href="https://github.com/vekatze/rin">rin</a> - An HTTP client over libcurl</li>
<li><a href="https://github.com/vekatze/sero">sero</a> - Saves and loads values using files</li>
<li><a href="https://github.com/vekatze/socket-nt">socket</a> - A thin layer over network sockets</li>
<li><a href="https://github.com/vekatze/time-nt">time</a> - Provides time-related operations</li>
<li><a href="https://github.com/vekatze/zonk">zonk</a> - A parser combinator</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h1>
<p>Make sure all the following dependencies are on your system:</p>
<ul>
<li><code>clang (&gt;= 15.0.0)</code></li>
<li><code>curl</code></li>
<li><code>tar</code></li>
<li><code>zstd</code></li>
</ul>
<p>Add the below to your <code>.bashrc</code>, <code>.zshrc</code>, etc.</p>
<pre><code class="language-sh"># this sets the core module (or &quot;prelude&quot;) that is used in `neut create`
export NEUT_CORE_MODULE_URL=&quot;https://github.com/vekatze/neut-core/raw/main/archive/0-51-15.tar.zst&quot;
export NEUT_CORE_MODULE_DIGEST=&quot;guc1czS094uWsejaCtdp9MQXUcrUfDzItpqT3_w7wfE&quot;
</code></pre>
<p>Then, get the compiler:</p>
<pre><code class="language-sh"># macOS (arm64)
curl -L -o ~/.local/bin/neut https://github.com/vekatze/neut/releases/latest/download/neut-arm64-darwin
# Linux (amd64)
curl -L -o ~/.local/bin/neut https://github.com/vekatze/neut/releases/latest/download/neut-amd64-linux
# Linux (arm64)
curl -L -o ~/.local/bin/neut https://github.com/vekatze/neut/releases/latest/download/neut-arm64-linux

# make it executable
chmod +x ~/.local/bin/neut
</code></pre>
<p>Ensure that <code>~/.local/bin</code> is in your <code>$PATH</code>.</p>
<div class="info-block">
<p>You can put the binary anywhere you want as long as the location is in your <code>$PATH</code>.</p>
</div>
<p>You can check if the compiler is installed correctly by running <code>neut version</code>:</p>
<pre><code class="language-sh">neut version
#=&gt; X.Y.Z
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h1>
<p>This chapter provides some tools for writing programs in Neut.</p>
<p><a href="./lovely-lsp-showcase.html">Lovely LSP Showcase</a> shows what the LSP server is like using GIF animations.</p>
<p><a href="./rapid-prototyping.html">Rapid Prototyping</a> shows how the subcommand <code>neut zen</code> works in harmony with editors.</p>
<p><a href="./editor-setup.html">Editor Setup</a> explains how to set up editors like Emacs, Neovim, Vim, or Visual Studio Code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lovely-lsp-showcase"><a class="header" href="#lovely-lsp-showcase">Lovely LSP Showcase</a></h1>
<p>The compiler contains an LSP server. Let's see what it is like.</p>
<h2 id="showcase"><a class="header" href="#showcase">Showcase</a></h2>
<p>The LSP server currently has the following features:</p>
<ul>
<li><a href="lovely-lsp-showcase.html#lint">Lint</a></li>
<li><a href="lovely-lsp-showcase.html#completion--automatic-import">Completion (+ automatic import)</a></li>
<li><a href="lovely-lsp-showcase.html#jump-to-definition">Jump to Definition</a></li>
<li><a href="lovely-lsp-showcase.html#find-references">Find References</a></li>
<li><a href="lovely-lsp-showcase.html#format-on-save">Format on Save</a></li>
<li><a href="lovely-lsp-showcase.html#remove-unused-imports">Remove Unused Imports</a></li>
<li><a href="lovely-lsp-showcase.html#show-the-type-of-a-variable">Show the Type of a Variable</a></li>
<li><a href="lovely-lsp-showcase.html#highlight-symbols">Highlight Symbols</a></li>
</ul>
<h3 id="lint"><a class="header" href="#lint">Lint</a></h3>
<p><img src="./image/screencasts/lint.gif" alt="lint" title="lint" /></p>
<h3 id="completion--automatic-import"><a class="header" href="#completion--automatic-import">Completion (+ automatic import)</a></h3>
<p><img src="./image/screencasts/completion.gif" alt="completion" title="completion" /></p>
<h3 id="jump-to-definition"><a class="header" href="#jump-to-definition">Jump to Definition</a></h3>
<p><img src="./image/screencasts/jump-to-definition.gif" alt="jump to definition" title="jump to definition" /></p>
<h3 id="find-references"><a class="header" href="#find-references">Find References</a></h3>
<p><img src="./image/screencasts/find-references.gif" alt="find references" title="find references" /></p>
<h3 id="format-on-save"><a class="header" href="#format-on-save">Format on Save</a></h3>
<p><img src="./image/screencasts/format-on-save.gif" alt="format on save" title="format on save" /></p>
<h3 id="remove-unused-imports"><a class="header" href="#remove-unused-imports">Remove Unused Imports</a></h3>
<p><img src="./image/screencasts/minimize.gif" alt="remove unused imports" title="remove unused imports" /></p>
<h3 id="show-the-type-of-a-variable"><a class="header" href="#show-the-type-of-a-variable">Show the Type of a Variable</a></h3>
<p><img src="./image/screencasts/hover-type.gif" alt="hover type" title="show the type of a variable" /></p>
<h3 id="highlight-symbols"><a class="header" href="#highlight-symbols">Highlight Symbols</a></h3>
<p><img src="./image/screencasts/highlight.gif" alt="highlight" title="highlight symbols" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rapid-prototyping"><a class="header" href="#rapid-prototyping">Rapid Prototyping</a></h1>
<p>You can use <a href="./commands.html#neut-zen">the subcommand</a> <code>neut zen</code> to sketch a function.</p>
<p>Below is an example in which Emacs runs <code>neut zen path/to/file.nt</code> when <code>C-c C-c</code> is typed:</p>
<p><img src="./image/screencasts/zen.gif" alt="zen" title="zen" /></p>
<p>This feels a bit like a scripting language, doesn't it?</p>
<h3 id="notes-for-emacs"><a class="header" href="#notes-for-emacs">Notes for Emacs</a></h3>
<p>The configuration for Emacs in the above example is like the one below:</p>
<pre><code class="language-text">(defun ext/neut-compile ()
  (interactive)
  (compile (concat &quot;neut zen &quot; (buffer-file-name))))

(bind-key &quot;C-c C-c&quot; 'ext/neut-compile 'neut-mode-map)
</code></pre>
<p>The above example also uses the package <code>fancy-compilation</code>:</p>
<pre><code class="language-text">(use-package fancy-compilation
  :init
  (fancy-compilation-mode t)
  (setq compilation-error-regexp-alist nil)
  (setq compilation-highlight-regexp nil)
  (setq compilation-mode-font-lock-keywords nil)
  (setq fancy-compilation-quiet-prelude t))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-setup"><a class="header" href="#editor-setup">Editor Setup</a></h1>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p><a href="https://github.com/vekatze/neut-mode">https://github.com/vekatze/neut-mode</a></p>
<p><code>neut-mode</code> is an Emacs major mode for Neut. The mode provides syntax highlighting and automatic indentation. It also provides a way to use the LSP server via <code>lsp-mode</code> and <code>eglot</code>.</p>
<p><code>neut-mode</code> is available on <a href="https://melpa.org/#/neut-mode">Melpa</a>. You can install the package by:</p>
<pre><code class="language-text">M-x package-install RET neut-mode RET
</code></pre>
<p>Below is an example configuration:</p>
<pre><code class="language-lisp">(use-package neut-mode
  :init
  (defun my/neut-initialize ()
    (interactive)
    (when (featurep 'lsp-mode)
      (setq-local lsp-before-save-edits t)
      (lsp)))
  (defun my/neut-compile ()
    (interactive)
    (compile (concat &quot;neut zen &quot; (buffer-file-name))))
  (add-hook 'neut-mode-hook 'my/neut-initialize)
  :bind
  (:map neut-mode-map
        (&quot;C-c C-c&quot; . 'my/neut-compile)))
</code></pre>
<h2 id="neovim"><a class="header" href="#neovim">Neovim</a></h2>
<p><a href="https://github.com/vekatze/vim-neut">https://github.com/vekatze/vim-neut</a></p>
<p>You can install <code>vim-neut</code> for syntax highlighting and automatic indentation.</p>
<p>The installation process is as usual. Just use your favorite plugin manager like <a href="https://github.com/folke/lazy.nvim">lazy.nvim</a>.</p>
<p>If you want to use the built-in LSP client, for example, you can do something like the following:</p>
<pre><code class="language-vim">vim.api.nvim_create_autocmd(&quot;FileType&quot;, {
  desc = &quot;Launch Neut's LSP server&quot;,
  pattern = &quot;neut&quot;,
  callback = function()
    vim.lsp.start({
      name = &quot;neut lsp&quot;,
      cmd = { &quot;neut&quot;, &quot;lsp&quot; },
      root_dir = vim.fs.dirname(vim.fs.find({ &quot;module.ens&quot; }, { upward = true })[1]),
    })
  end
})
</code></pre>
<p>The points are as follows:</p>
<ul>
<li>Run <code>neut lsp</code> to start the LSP server</li>
<li>Look for <code>module.ens</code> to find the root of a module</li>
</ul>
<p>You should be able to use any other LSP clients for Neovim.</p>
<h2 id="vim"><a class="header" href="#vim">Vim</a></h2>
<p><a href="https://github.com/vekatze/vim-neut">https://github.com/vekatze/vim-neut</a></p>
<p>You can install <code>vim-neut</code> for syntax highlighting and automatic indentation.</p>
<p>The installation process is as usual. Just use your favorite plugin manager like <a href="https://github.com/junegunn/vim-plug">vim-plug</a>.</p>
<p>If you want to use <a href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a>, for example, you can do something like the following:</p>
<pre><code class="language-vim">call plug#begin()

&quot; ...

Plug 'vekatze/vim-neut'

Plug 'prabirshrestha/vim-lsp'

&quot; ...

call plug#end()

if executable('neut')
    au User lsp_setup call lsp#register_server({
        \ 'name': 'neut',
        \ 'cmd': {server_info-&gt;['neut', 'lsp']},
        \ 'allowlist': ['neut'],
        \ })
endif


function! s:on_lsp_buffer_enabled() abort
    &quot; ... (see the readme of vim-lsp)
endfunction


augroup lsp_install
    &quot; ... (see the readme of vim-lsp)
augroup END
</code></pre>
<p>The points are as follows:</p>
<ul>
<li>Run <code>neut lsp</code> to start the LSP server</li>
<li>Look for <code>module.ens</code> to find the root of a module</li>
</ul>
<p>You should be able to use any other LSP clients for Vim.</p>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p><a href="https://github.com/vekatze/vscode-neut">https://github.com/vekatze/vscode-neut</a></p>
<p>You can install <code>vscode-neut</code> for syntax highlighting, automatic indentation, and LSP support. This extension is available on the <a href="https://marketplace.visualstudio.com/items?itemName=vekatze.vscode-neut">Visual Studio Marketplace</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-execute-types"><a class="header" href="#how-to-execute-types">How to Execute Types</a></h1>
<h2 id="table-of-contents-10"><a class="header" href="#table-of-contents-10">Table of Contents</a></h2>
<ul>
<li><a href="how-to-execute-types.html#types-as-closed-functions">Types as Closed Functions</a></li>
<li><a href="how-to-execute-types.html#example-behavior-of-types">Example Behavior of Types</a></li>
<li><a href="how-to-execute-types.html#immediate-types">Immediate Types</a></li>
<li><a href="how-to-execute-types.html#polymorphic-types">Polymorphic Types</a></li>
<li><a href="how-to-execute-types.html#algebraic-data-types">Algebraic Data Types</a></li>
<li><a href="how-to-execute-types.html#advanced-function-types">Advanced: Function Types</a></li>
</ul>
<h2 id="types-as-closed-functions"><a class="header" href="#types-as-closed-functions">Types as Closed Functions</a></h2>
<p>Here, we'll see how a type is translated into a function that discards/copies the terms of the type. To see the basic idea, let's take a simple ADT for example:</p>
<pre><code class="language-neut">data item {
| New(int, int)
}
</code></pre>
<p>The internal representation of <code>New(10, 20)</code> is something like the below:</p>
<pre><code class="language-neut">New(10, 20)

// ↓ (compile)

let ptr = malloc({2-words});
store(ptr[0], 10); // ptr[0] := 10
store(ptr[1], 20); // ptr[1] := 20
ptr
</code></pre>
<h3 id="discardingcopying-a-value"><a class="header" href="#discardingcopying-a-value">Discarding/Copying a Value</a></h3>
<p>Now, let's see how to discard and copy the values of the type <code>item</code>.</p>
<p>A value <code>v</code> of type <code>item</code> can be discarded as follows:</p>
<pre><code class="language-neut">free(v)
</code></pre>
<p>The value <code>v</code> can be copied as follows:</p>
<pre><code class="language-neut">// copy `v`, keeping the original `v` intact
let ptr = malloc({2-words});
store(ptr[0], v[0]); // ptr[0] := v[0]
store(ptr[1], v[1]); // ptr[1] := v[1]
ptr
</code></pre>
<p>Not a big deal, right?</p>
<h3 id="combining-discardingcopying-functions"><a class="header" href="#combining-discardingcopying-functions">Combining Discarding/Copying Functions</a></h3>
<p>Using the two procedures above, we can construct a closed function that discards and copies the values of the type <code>item</code>:</p>
<pre><code class="language-neut">define exp-item(selector, v) {
  if selector == 0 {
    // discard
    free(v)
  } else {
    // copy `v`
    let ptr = malloc({2-words});
    store(ptr[0], v[0]);
    store(ptr[1], v[1]);
    ptr
  }
}
</code></pre>
<p><code>exp-item(selector, v)</code> discards <code>v</code> if <code>selector</code> is 0. Otherwise, this function creates a copy of <code>v</code> and then returns it, keeping the original <code>v</code> intact.</p>
<p>The type <code>item</code> is compiled into a pointer to this function.</p>
<p>More generally, a type <code>a</code> is translated into a pointer to a closed function like below:</p>
<pre><code class="language-neut">define exp-a(selector, v) {
  if selector == 0 {
    // a procedure that discards `v`
  } else {
    // a procedure that copies `v` (keeping the original `v` intact)
  }
}
</code></pre>
<p>We'll call such a closed function a resource exponential of <code>a</code>.</p>
<h2 id="example-behavior-of-types"><a class="header" href="#example-behavior-of-types">Example Behavior of Types</a></h2>
<p>This <code>exp-item</code> is called when a variable isn't used:</p>
<pre><code class="language-neut">let x = New(10, 20);
print(&quot;hello&quot;) // `x` isn't used

// ↓ (compile)

let x = New(10, 20);
let _ = exp-item(0, x); // discard `x` by passing 0 as `selector`
print(&quot;hello&quot;)
</code></pre>
<p>This <code>exp-item</code> is also called when a variable is used more than twice:</p>
<pre><code class="language-neut">let x = New(10, 20);
let a = foo(x); // first use of `x`
let b = bar(x); // second use of `x`
cont(a, b)

// ↓ (compile)

let x = New(10, 20);
let x-copy = exp-item(1, x); // copy `x` by passing 1 as `selector`
let a = foo(x-copy);
let b = bar(x);
cont(a, b)
</code></pre>
<div class="info-block">
<p>This discarding/copying procedure happens <em>immediately after a variable is defined</em>.</p>
</div>
<h2 id="immediate-types"><a class="header" href="#immediate-types">Immediate Types</a></h2>
<p>Immediates like integers or floats don't have to be discarded or copied since they don't rely on memory-related operations like <code>malloc</code> or <code>free</code>. This fact is reflected in the resulting function that <code>int</code> or <code>float</code> are translated into:</p>
<pre><code class="language-neut">define base.#.imm(selector, value) {
  if selector == 0 {
    0 // &quot;discarding&quot; doesn't have to do anything
  } else {
    value // &quot;copying&quot; simply reuses the original value
  }
}
</code></pre>
<p>Immediate types are compiled into this function. Noema types like <code>&amp;list(int)</code> are also translated into this function.</p>
<p>Uses of <code>base.#.imm</code> like <code>base.#.imm(1, some-value)</code> are optimized away by inlining.</p>
<div class="info-block">
<p>A type is compiled into a pointer to a closed function. This means that types are immediate values. Because of that, the type of types (<code>type</code>) is also compiled into <code>base.#.imm</code>.</p>
</div>
<h2 id="polymorphic-types"><a class="header" href="#polymorphic-types">Polymorphic Types</a></h2>
<p>Let's see how polymorphic values are copied. Consider the following code:</p>
<pre><code class="language-neut">define foo(a: type, x: a): pair(a, a) {
  Pair(x, x)
}
</code></pre>
<p>The code uses the variable <code>x</code> twice. Thus, this <code>x</code> must be copied according to the type <code>a</code>.</p>
<p>This can be done because the internal representation of <code>a</code> is a function that can discard and copy the values of type <code>a</code>. Thus, the above code is compiled into something like the below:</p>
<pre><code class="language-neut">define foo(a: type, x: a): pair(a, a) {
  let x-clone = a(1, x);
  Pair(x, x-clone)
}
</code></pre>
<p>Thus, we can discard and copy values of polymorphic types.</p>
<h2 id="algebraic-data-types-1"><a class="header" href="#algebraic-data-types-1">Algebraic Data Types</a></h2>
<p>ADTs like the below also have resource exponentials, of course:</p>
<pre><code class="language-neut">data list(a) {
| Nil
| Cons(a, list(a))
}
</code></pre>
<p>The first thing to note is that the values of an ADT must be able to be discarded/copied using a closed function (since all the types in Neut are compiled into closed functions). This means the information about <code>a</code> in <code>list(a)</code> must be contained in the values.</p>
<p>That is, for example, the internal representation of <code>Nil</code> is something like below:</p>
<pre><code class="language-neut">(a, 0)
</code></pre>
<p>Here, the <code>0</code> is the discriminant for <code>Nil</code>. Also, that of <code>Cons(10, xs)</code> is:</p>
<pre><code class="language-neut">(a, 1, 10, xs)
</code></pre>
<p>Here, the <code>1</code> is the discriminant for <code>Cons</code>.</p>
<p>With that in mind, the resource exponential of <code>list(a)</code> will be something like the below (A bit lengthy; Skip it and just read the succeeding note if you aren't that interested in details):</p>
<pre><code class="language-neut">define exp-list(selector, v) {
  if selector == 0 {
    let d = get-discriminant(v);
    if d == 0 {
      // discard Nil
      free(v)
    } else {
      // discard Cons
      let a = v[0];
      let cons-head = v[1];
      let cons-tail = v[2];
      free(v);
      let () = a(0, v[1]); // ← discard the head of cons using v[0]
      exp-list(0, v[2])
    }
  } else {
    let d = get-discriminant(v);
    if d == 0 {
      // copy Nil
      let ptr = malloc({2-words});
      let a = v[0];
      store(ptr[0], a);
      store(ptr[1], d);
      ptr
    } else {
      // copy Cons
      let ptr = malloc({4-words});
      let a = v[0];
      let cons-head-copy = a(1, v[2]); // ← copy the head of cons using v[0]
      let cons-tail-copy = exp-list(1, v[3]);
      store(ptr[0], a);
      store(ptr[1], d);
      store(ptr[2], cons-head-copy);
      store(ptr[3], cons-tail-copy);
      ptr
    }
  }
}
</code></pre>
<p>The point is that <em>the type information in a value is loaded at runtime and used to discard/copy values</em>. This utilization of types is the main point of first-class types in Neut.</p>
<p>The main part of this section is now over. What follows is for curious cats.</p>
<h2 id="advanced-function-types"><a class="header" href="#advanced-function-types">Advanced: Function Types</a></h2>
<p>We'll see how function types like <code>(int) -&gt; bool</code> are translated.</p>
<p>Suppose we have a function like the below:</p>
<pre><code class="language-neut">define foo(a: type): int {
  let x: int = 10;
  let y = type;
  let f =
    function (z: a) {  // lambda
      let foo = x;     // ← x is a free var of this lambda
      let bar = y;     // ← y is also a free var of this lambda
      let buz = z;
      bar
    };
  0
}
</code></pre>
<p>Let's see how the <code>function</code> is compiled.</p>
<h3 id="extracting-a-closed-chain-from-a-lambda"><a class="header" href="#extracting-a-closed-chain-from-a-lambda">Extracting a Closed Chain From a Lambda</a></h3>
<p>First, the compiler collects all the free variables in the lambda. Here, the compiler also collects all the free variables in the types of the free variables. Thus, in this case, the compiler constructs a list like below:</p>
<pre><code class="language-neut">[a, x, y, z]
</code></pre>
<p>This list is &quot;closed&quot; in the following sense. Consider annotating all the variables in the list by their variables, like below:</p>
<pre><code class="language-neut">[a: type, x: int, y: type, z: a]
</code></pre>
<p>This list is closed in that the term</p>
<pre><code class="language-neut">function (a: type, x: int, y: type, z: a) {
  Unit
}
</code></pre>
<p>contains no free variables. We'll call a list like this a closed chain.</p>
<h3 id="closure-conversion"><a class="header" href="#closure-conversion">Closure Conversion</a></h3>
<p>We'll use this closed chain to compile a lambda. The internal representation of a closure for the lambda will be a 3-word tuple like the following:</p>
<pre><code class="language-text">(Σ (a: type, x: int, y: type). a , (a, x, y, z), LABEL-TO-FUNCTION-DEFINITION)
 -----------------------------   ------------
 the type of the environment     the closed chain (i.e. environment)
</code></pre>
<p>This is more or less the usual closure conversion, except that we now have the types of the free variables in the closure.</p>
<h3 id="discardingcopying-a-closure"><a class="header" href="#discardingcopying-a-closure">Discarding/Copying a Closure</a></h3>
<p>Knowing its internal representation, we can now discard/copy a closure. To copy a closure, we can do the following:</p>
<pre><code class="language-neut">// copy a closure `cls`

let env-type = cls[0]; // get the type of the environment
let env      = cls[1]; // get the pointer to the environment
let label    = cls[2]; // get the label to the function

let env-clone = env-type(1, env); // copy the environment using the type of it

// allocate new memory region for our new closure
let new-ptr = malloc(mul-int(3, word-size));

// store cloned values
store(new-ptr[0], env-type);  // remember that a type is an immediate
store(new-ptr[1], env-clone);
store(new-ptr[2], label);     // note that a label is an immediate

new-ptr // ... and return the new closure
</code></pre>
<p>Discarding a closure can also be done with the same idea: discard the environment using the type information in the closure.</p>
<h3 id="translating-a-function-type"><a class="header" href="#translating-a-function-type">Translating a Function Type</a></h3>
<p>This leads us to translate the function type as follows:</p>
<pre><code class="language-neut">(x1: A1, ..., xn: An) -&gt; B

// ↓

define base.#.cls(action-selector, cls) {
  if action-selector == 0 {
    // discard

    // discard the environment using the type of it
    let env-type = cls[0];
    let env      = cls[1];
    env-type(0, env);

    // discard the tuple of the closure
    free(cls)
  } else {
    // copy

    // get the original values
    let env-type = cls[0];
    let env      = cls[1];
    let label    = cls[2];

    // copy the environment using the type of it
    let env-clone = env-type(1, env);

    let new-ptr = malloc(mul-int(3, word-size));
    // copy the original values
    store(new-ptr[0], env-type);
    store(new-ptr[1], env-clone);
    store(new-ptr[2], label);

    // ... and return the new closure
    new-ptr
  }
}
</code></pre>
<div class="info-block">
<p>Every function type is translated into this same <code>base.#.cls</code>, no matter its argument types and the result types.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>You can find the source files for the following benchmarks <a href="https://github.com/vekatze/neut/tree/main/bench/action">here</a>.</p>
<h2 id="table-of-contents-11"><a class="header" href="#table-of-contents-11">Table of Contents</a></h2>
<ul>
<li><a href="benchmarks.html#bubble-sort">Bubble Sort</a></li>
<li><a href="benchmarks.html#dictionary-create--lookup">Dictionary (Create &amp; Lookup)</a></li>
<li><a href="benchmarks.html#intmap-create--lookup">IntMap (Create &amp; Lookup)</a></li>
<li><a href="benchmarks.html#notes">Notes</a></li>
</ul>
<h2 id="bubble-sort"><a class="header" href="#bubble-sort">Bubble Sort</a></h2>
<p>This test creates a random list of length <code>N</code> and performs bubble-sort on the list<sup class="footnote-reference"><a href="#bubble">1</a></sup>.</p>
<h3 id="linux-amd64"><a class="header" href="#linux-amd64">Linux (AMD64)</a></h3>
<p><img src="./image/graph/amd64-linux/bubble.png" alt="bubble sort" title="bubble sort" /></p>
<h3 id="macos-arm64"><a class="header" href="#macos-arm64">macOS (ARM64)</a></h3>
<p><img src="./image/graph/arm64-darwin/bubble.png" alt="bubble sort" title="bubble sort" /></p>
<h2 id="dictionary-create--lookup"><a class="header" href="#dictionary-create--lookup">Dictionary (Create &amp; Lookup)</a></h2>
<p>This test creates a random dictionary of size <code>N</code> and performs random lookups from the dictionary for <code>N</code> times.</p>
<h3 id="linux-amd64-1"><a class="header" href="#linux-amd64-1">Linux (AMD64)</a></h3>
<p><img src="./image/graph/amd64-linux/dictionary.png" alt="dictionary" title="dictionary" /></p>
<h3 id="macos-arm64-1"><a class="header" href="#macos-arm64-1">macOS (ARM64)</a></h3>
<p><img src="./image/graph/arm64-darwin/dictionary.png" alt="dictionary" title="dictionary" /></p>
<h2 id="intmap-create--lookup"><a class="header" href="#intmap-create--lookup">IntMap (Create &amp; Lookup)</a></h2>
<p>This test creates a random intmap of size <code>N</code> and performs random lookups from the intmap for <code>N</code> times.</p>
<h3 id="linux-amd64-2"><a class="header" href="#linux-amd64-2">Linux (AMD64)</a></h3>
<p><img src="./image/graph/amd64-linux/intmap.png" alt="IntMap" title="IntMap" /></p>
<h3 id="macos-arm64-2"><a class="header" href="#macos-arm64-2">macOS (ARM64)</a></h3>
<p><img src="./image/graph/arm64-darwin/intmap.png" alt="IntMap" title="IntMap" /></p>
<h2 id="notes-2"><a class="header" href="#notes-2">Notes</a></h2>
<p>I used the following hardware in the above benchmarks:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Hardware</th></tr></thead><tbody>
<tr><td>Linux (AMD64)</td><td>HP OMEN 16 2023 (7840HS, 32 GB, Debian)</td></tr>
<tr><td>macOS (ARM64)</td><td>Apple MacBook Pro 14 (M1 Max, 32 GB)</td></tr>
</tbody></table>
</div>
<p>I used the following commands to run benchmarks and generate the graphs:</p>
<pre><code class="language-sh">just bench-linux amd64-linux # Linux (AMD64)
just bench-darwin arm64-darwin # macOS (ARM64)
</code></pre>
<p>You may want to read <a href="https://github.com/vekatze/neut/blob/main/build/Dockerfile">the Dockerfile in the repository</a> to get the list of additional dependencies for running benchmarks. The list includes npm, hyperfine, etc.</p>
<p>Please tell me (hopefully gently) if some of the results are unfair because of reasons I overlooked.</p>
<div class="footnote-definition" id="bubble"><sup class="footnote-definition-label">1</sup>
<p>I honestly don't know why the faster one changes depending on the environment here. Please let me know if you find out why.</p>
</div>

            <footer id="footer-paginator">

              <div id="footer-spacer"></div>

            </footer>
          </article>
          <div id="footer-wrapper">
            <footer id="footer-nav">
              <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="modules-and-sources.html"><strong aria-hidden="true">3.1.</strong> Modules and Sources</a></li><li class="chapter-item expanded "><a href="programming-in-neut.html"><strong aria-hidden="true">3.2.</strong> Programming in Neut</a></li><li class="chapter-item expanded "><a href="static-memory-management.html"><strong aria-hidden="true">3.3.</strong> Static Memory Management</a></li><li class="chapter-item expanded "><a href="modality-and-memory.html"><strong aria-hidden="true">3.4.</strong> Modality and Memory</a></li></ol></li><li class="chapter-item expanded "><a href="language-reference.html"><strong aria-hidden="true">4.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">4.1.</strong> Commands</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">4.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="statements.html"><strong aria-hidden="true">4.3.</strong> Statements</a></li><li class="chapter-item expanded "><a href="terms.html"><strong aria-hidden="true">4.4.</strong> Terms</a></li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">4.5.</strong> Primitives</a></li><li class="chapter-item expanded "><a href="basis.html"><strong aria-hidden="true">4.6.</strong> Basis</a></li></ol></li><li class="chapter-item expanded "><a href="what-is-next.html"><strong aria-hidden="true">5.</strong> What is Next?</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="manual-installation.html"><strong aria-hidden="true">6.</strong> Manual Installation</a></li><li class="chapter-item expanded "><a href="development-environment.html"><strong aria-hidden="true">7.</strong> Development Environment</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lovely-lsp-showcase.html"><strong aria-hidden="true">7.1.</strong> Lovely LSP Showcase</a></li><li class="chapter-item expanded "><a href="rapid-prototyping.html"><strong aria-hidden="true">7.2.</strong> Rapid Prototyping</a></li><li class="chapter-item expanded "><a href="editor-setup.html"><strong aria-hidden="true">7.3.</strong> Editor Setup</a></li></ol></li><li class="chapter-item expanded "><a href="how-to-execute-types.html"><strong aria-hidden="true">8.</strong> How to Execute Types</a></li><li class="chapter-item expanded "><a href="benchmarks.html"><strong aria-hidden="true">9.</strong> Benchmarks</a></li></ol>
            </footer>
          </div>
        </main>
      </div>


      <script src="highlight.js"></script>
      <script src="book.js"></script>
    </div>
  </body>
</html>
